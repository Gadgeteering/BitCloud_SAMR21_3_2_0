###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:41:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclMemoryManager.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclMemoryManager.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\zclMemoryManager.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\zclMemoryManager.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclMemoryManager.c
      1          /************************************************************************//**
      2            \file zclMemoryManager.c
      3          
      4            \brief
      5              The ZCL Memory Manager implementation
      6          
      7            \author
      8              Atmel Corporation: http://www.atmel.com \n
      9              Support email: avr@atmel.com
     10          
     11            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     12            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     13          
     14            \internal
     15              History:
     16              03.12.08 A. Potashov - Created.
     17          ******************************************************************************/
     18          #if ZCL_SUPPORT == 1
     19          /******************************************************************************
     20                             Includes section
     21          ******************************************************************************/
     22          #include <sysUtils.h>
     23          #include <zclMemoryManager.h>
     24          #include <configServer.h>
     25          #include <zclDbg.h>
     26          #include <sysAssert.h>
     27          
     28          /******************************************************************************
     29                                           Types section
     30           ******************************************************************************/
     31          typedef uint8_t ZclQuota_t;
     32          
     33          /******************************************************************************
     34                                         Definitions section
     35           ******************************************************************************/
     36          #define ZCL_MAX_BUF_WITH_QUOTAS  5U
     37          #define ZCL_READ_BUF_QUOTA(ptr, offset, pktType) \
     38            memcpy_P(ptr, &quotas[offset][pktType-1U], sizeof(ZclQuota_t))
     39          
     40          /******************************************************************************
     41                                         Constants section
     42           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     43          static PROGMEM_DECLARE (ZclQuota_t
     44          quotas[ZCL_MAX_BUF_WITH_QUOTAS + 1U][ZCL_BUFFER_TYPE_LAST - 1U]) =
   \                     quotas:
   \   00000000   0x02 0x03          DC8 2, 3, 2, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 3, 2, 1, 2, 3, 2
   \              0x02 0x02    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x02    
   \              0x02 0x01    
   \              0x02 0x02    
   \              0x02 0x01    
   \              0x02 0x03    
   \              0x02 0x01    
   \              0x02 0x03    
   \              0x02         
   \   00000017   0x02               DC8 2
     45          {
     46          /* OUT_DATA IN_DATA RESP_DATA REP_DATA*/
     47            {  2U,      3U,      2U,       2U    }, /* (quota * totalAmount)/4 */
     48            {  1U,      1U,      1U,       1U    }, /* totalAmount == 1 */
     49            {  1U,      2U,      2U,       1U    }, /* totalAmount == 2 */
     50            {  2U,      2U,      2U,       1U    }, /* totalAmount == 3 */
     51            {  2U,      3U,      2U,       1U    }, /* totalAmount == 4 */
     52            {  2U,      3U,      2U,       2U    }, /* totalAmount == 5 */
     53          };
     54          
     55          /******************************************************************************
     56                             Implementation section
     57          ******************************************************************************/
     58          static bool checkBufferQuotas(ZclBufferType_t type, uint8_t typeAmount, uint8_t totalAmount);
     59          
     60          /******************************************************************************
     61                             Implementation section
     62          ******************************************************************************/
     63          /*************************************************************************//**
     64          \brief Looks for and returns free zcl memory buffer
     65          
     66          \param[in] type - the type of a buffer
     67          
     68          \returns pointer to memory buffer or NULL if there is no free buffer
     69          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     70          ZclMmBuffer_t *zclMmGetMem(ZclBufferType_t type)
     71          {
   \                     zclMmGetMem: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
     72            uint8_t bufferAmount;
     73            uint8_t bufferSize;
     74            ZclMmBufferDescriptor_t *descriptor, *freeBuffer = NULL;
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x2400             MOVS     R4,#+0
     75            uint8_t *tmp = NULL;
   \   00000008   0x9602             STR      R6,[SP, #+8]
     76            uint8_t typeAmount = 0U;
   \   0000000A   0x2500             MOVS     R5,#+0
     77          
     78            CS_ReadParameter(CS_ZCL_MEMORY_BUFFERS_AMOUNT_ID, (void *)&bufferAmount);
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x208D             MOVS     R0,#+141
   \   00000012   0x0040             LSLS     R0,R0,#+1        ;; #+282
   \   00000014   0x.... 0x....      BL       CS_ReadParameter
     79            CS_ReadParameter(CS_ZCL_BUFFER_SIZE_ID, (void *)&bufferSize);
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x301C             ADDS     R0,R0,#+28       ;; #+283
   \   0000001E   0x.... 0x....      BL       CS_ReadParameter
     80            CS_GetMemory(CS_ZCL_BUFFER_DESCRIPTORS_ID, (void *)&descriptor);
   \   00000022   0xA901             ADD      R1,SP,#+4
   \   00000024   0x2085             MOVS     R0,#+133
   \   00000026   0x0080             LSLS     R0,R0,#+2        ;; #+532
   \   00000028   0x.... 0x....      BL       CS_GetMemory
     81            CS_GetMemory(CS_ZCL_BUFFERS_ID, (void *)&tmp);
   \   0000002C   0xA902             ADD      R1,SP,#+8
   \   0000002E   0x....             LDR      R0,??DataTable3  ;; 0x213
   \   00000030   0x.... 0x....      BL       CS_GetMemory
     82            if (NULL == descriptor)
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD119             BNE      ??zclMmGetMem_0
     83            {
     84              SYS_E_ASSERT_ERROR(false, ZCL_THERE_ARE_NO_BUFFERS);
   \   0000003A   0x....             LDR      R0,??DataTable3_1  ;; 0xc301
   \   0000003C   0x....             LDR      R1,??DataTable3_2
   \   0000003E   0x8008             STRH     R0,[R1, #+0]
   \   00000040   0x.... 0x....      BL       SYS_DefAssertCallbackError
     85              return NULL;
   \   00000044   0xE03B             B.N      ??zclMmGetMem_1
     86            }
     87            /* if descriptor is NULL, control breaks here */
     88          
     89            // Look for free buffer
     90            for (uint8_t i = 0U; i < bufferAmount; i++)
     91            {
     92              if (descriptor->type == type)
   \                     ??zclMmGetMem_2: (+1)
   \   00000046   0x9801             LDR      R0,[SP, #+4]
   \   00000048   0x7900             LDRB     R0,[R0, #+4]
   \   0000004A   0x42B8             CMP      R0,R7
   \   0000004C   0xD100             BNE      ??zclMmGetMem_3
     93                typeAmount++;
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
     94              if (ZCL_UNKNOWN_BUFFER == descriptor->type)
   \                     ??zclMmGetMem_3: (+1)
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD102             BNE      ??zclMmGetMem_4
     95              {
     96                freeBuffer = descriptor;
   \   00000054   0x9C01             LDR      R4,[SP, #+4]
     97                freeBuffer->buf.frame = tmp;
   \   00000056   0x9802             LDR      R0,[SP, #+8]
   \   00000058   0x67A0             STR      R0,[R4, #+120]
     98              }
     99              tmp += bufferSize + APS_AFFIX_LENGTH + 2U;
   \                     ??zclMmGetMem_4: (+1)
   \   0000005A   0x9802             LDR      R0,[SP, #+8]
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x7809             LDRB     R1,[R1, #+0]
   \   00000060   0x1840             ADDS     R0,R0,R1
   \   00000062   0x3044             ADDS     R0,R0,#+68
   \   00000064   0x9002             STR      R0,[SP, #+8]
    100              descriptor++;
   \   00000066   0x9801             LDR      R0,[SP, #+4]
   \   00000068   0x3080             ADDS     R0,R0,#+128
   \   0000006A   0x9001             STR      R0,[SP, #+4]
    101            }
   \   0000006C   0x1C76             ADDS     R6,R6,#+1
   \                     ??zclMmGetMem_0: (+1)
   \   0000006E   0x4668             MOV      R0,SP
   \   00000070   0x7840             LDRB     R0,[R0, #+1]
   \   00000072   0xB2F6             UXTB     R6,R6
   \   00000074   0x4286             CMP      R6,R0
   \   00000076   0xD3E6             BCC      ??zclMmGetMem_2
    102          
    103            if (freeBuffer && checkBufferQuotas(type, typeAmount, bufferAmount))
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD020             BEQ      ??zclMmGetMem_1
   \   0000007C   0x4668             MOV      R0,SP
   \   0000007E   0x7842             LDRB     R2,[R0, #+1]
   \   00000080   0xB2E9             UXTB     R1,R5
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0x.... 0x....      BL       checkBufferQuotas
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD018             BEQ      ??zclMmGetMem_1
    104            {
    105              freeBuffer->type = type;
   \   0000008C   0x7127             STRB     R7,[R4, #+4]
    106              memset((void *)&(freeBuffer->buf.primitive), 0U, sizeof(freeBuffer->buf.primitive));
   \   0000008E   0x2168             MOVS     R1,#+104
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x3010             ADDS     R0,R0,#+16
   \   00000094   0x.... 0x....      BL       __aeabi_memclr
    107              memset(freeBuffer->buf.frame, 0U, bufferSize + APS_AFFIX_LENGTH + 2U);
   \   00000098   0x4668             MOV      R0,SP
   \   0000009A   0x7801             LDRB     R1,[R0, #+0]
   \   0000009C   0x3144             ADDS     R1,R1,#+68
   \   0000009E   0x6FA0             LDR      R0,[R4, #+120]
   \   000000A0   0x.... 0x....      BL       __aeabi_memclr
    108              freeBuffer->buf.frame[0U] = TOP_GUARD_VALUE;
   \   000000A4   0x2055             MOVS     R0,#+85
   \   000000A6   0x6FA1             LDR      R1,[R4, #+120]
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
    109              freeBuffer->buf.frame[bufferSize + APS_AFFIX_LENGTH + 1U] = BOTTOM_GUARD_VALUE;
   \   000000AA   0x20AA             MOVS     R0,#+170
   \   000000AC   0x6FA1             LDR      R1,[R4, #+120]
   \   000000AE   0x466A             MOV      R2,SP
   \   000000B0   0x7812             LDRB     R2,[R2, #+0]
   \   000000B2   0x1889             ADDS     R1,R1,R2
   \   000000B4   0x3143             ADDS     R1,R1,#+67
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
    110              return &freeBuffer->buf;
   \   000000B8   0x3410             ADDS     R4,R4,#+16
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0xBDFE             POP      {R1-R7,PC}
    111            }
    112          
    113            return NULL;
   \                     ??zclMmGetMem_1: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xBDFE             POP      {R1-R7,PC}       ;; return
    114          }
    115          
    116          /*************************************************************************//**
    117          \brief Frees zcl buffer
    118          
    119          \param[in] mem - pointer to used zcl buffer
    120          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    121          void zclMmFreeMem(ZclMmBuffer_t *mem)
    122          {
   \                     zclMmFreeMem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    123            ZclMmBufferDescriptor_t *descriptor = GET_STRUCT_BY_FIELD_POINTER(ZclMmBufferDescriptor_t, buf, mem);
   \   00000006   0x3C10             SUBS     R4,R4,#+16
    124            uint8_t bufferSize;
    125          
    126            CS_ReadParameter(CS_ZCL_BUFFER_SIZE_ID, (void *)&bufferSize);
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x301C             ADDS     R0,R0,#+28       ;; #+283
   \   0000000E   0x.... 0x....      BL       CS_ReadParameter
    127            SYS_E_ASSERT_FATAL(((TOP_GUARD_VALUE == descriptor->buf.frame[0U]) &&
    128              (BOTTOM_GUARD_VALUE == descriptor->buf.frame[bufferSize + APS_AFFIX_LENGTH + 1U])),
    129              ZCL_MEMORY_CORRUPTION_0);
   \   00000012   0x6FA0             LDR      R0,[R4, #+120]
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0x2955             CMP      R1,#+85
   \   00000018   0xD106             BNE      ??zclMmFreeMem_0
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x1840             ADDS     R0,R0,R1
   \   00000020   0x3043             ADDS     R0,R0,#+67
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x28AA             CMP      R0,#+170
   \   00000026   0xD005             BEQ      ??zclMmFreeMem_1
   \                     ??zclMmFreeMem_0: (+1)
   \   00000028   0x20C6             MOVS     R0,#+198
   \   0000002A   0x0200             LSLS     R0,R0,#+8        ;; #+50688
   \   0000002C   0x....             LDR      R1,??DataTable3_2
   \   0000002E   0x8008             STRH     R0,[R1, #+0]
   \   00000030   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    130            descriptor->link = NULL;
   \                     ??zclMmFreeMem_1: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x60A0             STR      R0,[R4, #+8]
    131            descriptor->type = ZCL_UNKNOWN_BUFFER;
   \   00000038   0x7120             STRB     R0,[R4, #+4]
    132            descriptor->timeout = 0;
   \   0000003A   0x6020             STR      R0,[R4, #+0]
    133          }
   \   0000003C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    134          
    135          /*************************************************************************//**
    136          \brief Gets next busy zcl memory buffer descriptor or
    137            the first one if descr is NULL
    138          
    139          \param[in] descr - pointer to current zcl buffer descriptor
    140          
    141          \returns pointer to the next busy zcl memory buffer descriptor
    142            or NULL if no next busy zcl memory buffer descriptor is available
    143          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    144          ZclMmBufferDescriptor_t *zclMmGetNextOutputMemDescriptor(ZclMmBufferDescriptor_t *descr)
    145          {
   \                     zclMmGetNextOutputMemDescriptor: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    146            uint8_t bufferAmount;
    147            bool bool_exp;
    148            ZclMmBufferDescriptor_t *descriptor, *iter;
    149           
    150            CS_ReadParameter(CS_ZCL_MEMORY_BUFFERS_AMOUNT_ID, (void *)&bufferAmount);
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x208D             MOVS     R0,#+141
   \   00000008   0x0040             LSLS     R0,R0,#+1        ;; #+282
   \   0000000A   0x.... 0x....      BL       CS_ReadParameter
    151            CS_GetMemory(CS_ZCL_BUFFER_DESCRIPTORS_ID, (void *)&descriptor);
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x2085             MOVS     R0,#+133
   \   00000012   0x0080             LSLS     R0,R0,#+2        ;; #+532
   \   00000014   0x.... 0x....      BL       CS_GetMemory
    152            bool_exp = (((descr >= descriptor) && (descr < descriptor + bufferAmount)) || (NULL == descr));
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x7909             LDRB     R1,[R1, #+4]
   \   0000001E   0x01C9             LSLS     R1,R1,#+7
   \   00000020   0x1840             ADDS     R0,R0,R1
   \   00000022   0x9900             LDR      R1,[SP, #+0]
   \   00000024   0x428C             CMP      R4,R1
   \   00000026   0xD301             BCC      ??zclMmGetNextOutputMemDescriptor_0
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD30E             BCC      ??zclMmGetNextOutputMemDescriptor_1
   \                     ??zclMmGetNextOutputMemDescriptor_0: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD105             BNE      ??zclMmGetNextOutputMemDescriptor_2
    153            if (false == bool_exp)
    154            {
    155              SYS_E_ASSERT_ERROR(false,ZCLMEMORYMANAGER_ZCLMMGETNEXTBUSYDESCRIPTOR_0);
    156              return NULL;
    157            }
    158            if ((descr < descriptor) && (descr >= descriptor + bufferAmount))
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD001             BEQ      ??zclMmGetNextOutputMemDescriptor_3
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ      ??zclMmGetNextOutputMemDescriptor_4
    159              return NULL;
    160          
    161            if (descr)
    162              iter = descr + 1;
    163            else
    164              iter = descriptor;
   \                     ??zclMmGetNextOutputMemDescriptor_3: (+1)
   \   00000038   0x460C             MOV      R4,R1
   \   0000003A   0xE009             B        ??zclMmGetNextOutputMemDescriptor_5
   \                     ??zclMmGetNextOutputMemDescriptor_2: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable3_3  ;; 0xc709
   \   0000003E   0x....             LDR      R1,??DataTable3_2
   \   00000040   0x8008             STRH     R0,[R1, #+0]
   \   00000042   0x.... 0x....      BL       SYS_DefAssertCallbackError
    165          
    166            while (iter < (descriptor + bufferAmount))
    167            {
    168              if (ZCL_OUTPUT_DATA_BUFFER == iter->type)
    169                return iter;
    170              iter++;
    171            }
    172          
    173            return NULL;
   \                     ??zclMmGetNextOutputMemDescriptor_4: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   \                     ??zclMmGetNextOutputMemDescriptor_1: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD0F4             BEQ      ??zclMmGetNextOutputMemDescriptor_3
   \                     ??zclMmGetNextOutputMemDescriptor_6: (+1)
   \   0000004E   0x3480             ADDS     R4,R4,#+128
   \                     ??zclMmGetNextOutputMemDescriptor_5: (+1)
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD2F8             BCS      ??zclMmGetNextOutputMemDescriptor_4
   \   00000054   0x7921             LDRB     R1,[R4, #+4]
   \   00000056   0x2901             CMP      R1,#+1
   \   00000058   0xD1F9             BNE      ??zclMmGetNextOutputMemDescriptor_6
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xBD16             POP      {R1,R2,R4,PC}
    174          }
    175          
    176          /**************************************************************************//**
    177          \brief Checks quotas for buffer with given type
    178          
    179          \param[in] type - type of input packet;
    180          \param[in] typeAmount - current number of packet with given type;
    181          \param[in] totalAmount - maximum packet buffers
    182          
    183          \returns 'true' if quotas are not exceeded otherwise 'false'
    184           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    185          static bool checkBufferQuotas(ZclBufferType_t type, uint8_t typeAmount, uint8_t totalAmount)
    186          {
   \                     checkBufferQuotas: (+1)
   \   00000000   0xB518             PUSH     {R3,R4,LR}
    187            ZclQuota_t quota;
    188          
    189            if (totalAmount <= ZCL_MAX_BUF_WITH_QUOTAS)
   \   00000002   0x0013             MOVS     R3,R2
   \   00000004   0x....             ADR.N    R4,quotas
   \   00000006   0x2A06             CMP      R2,#+6
   \   00000008   0xD20B             BCS      ??checkBufferQuotas_0
    190            {
    191              ZCL_READ_BUF_QUOTA(&quota, totalAmount, type);
   \   0000000A   0x009A             LSLS     R2,R3,#+2
   \   0000000C   0x18A2             ADDS     R2,R4,R2
   \   0000000E   0x1810             ADDS     R0,R2,R0
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x7803             LDRB     R3,[R0, #0]
   \   00000016   0x7013             STRB     R3,[R2, #0]
    192              return typeAmount < quota;
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x4299             CMP      R1,R3
   \   0000001C   0x4180             SBCS     R0,R0,R0
   \   0000001E   0x0FC0             LSRS     R0,R0,#+31
   \   00000020   0xBD12             POP      {R1,R4,PC}
    193            }
    194            else
    195            {
    196              ZCL_READ_BUF_QUOTA(&quota, 0U, type);
   \                     ??checkBufferQuotas_0: (+1)
   \   00000022   0x1820             ADDS     R0,R4,R0
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x466A             MOV      R2,SP
   \   00000028   0x7804             LDRB     R4,[R0, #0]
   \   0000002A   0x7014             STRB     R4,[R2, #0]
    197              return typeAmount < ((quota * totalAmount) >> 2U);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x4358             MULS     R0,R3,R0
   \   00000030   0x1080             ASRS     R0,R0,#+2
   \   00000032   0x4281             CMP      R1,R0
   \   00000034   0xDA01             BGE      ??checkBufferQuotas_1
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD12             POP      {R1,R4,PC}
   \                     ??checkBufferQuotas_1: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD12             POP      {R1,R4,PC}       ;; return
    198            }
    199          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x00000213         DC32     0x213

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x0000C301         DC32     0xc301

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     gAssertDbgCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x0000C709         DC32     0xc709
    200          
    201          #endif // ZCL_SUPPORT == 1
    202          //eof zclMemoryManager.c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   checkBufferQuotas
      16   zclMmFreeMem
        16   -> CS_ReadParameter
        16   -> SYS_DefAssertCallbackFatal
      32   zclMmGetMem
        32   -> CS_GetMemory
        32   -> CS_ReadParameter
        32   -> SYS_DefAssertCallbackError
        32   -> __aeabi_memclr
        32   -> checkBufferQuotas
      16   zclMmGetNextOutputMemDescriptor
        16   -> CS_GetMemory
        16   -> CS_ReadParameter
        16   -> SYS_DefAssertCallbackError


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      62  checkBufferQuotas
      24  quotas
      62  zclMmFreeMem
     194  zclMmGetMem
      94  zclMmGetNextOutputMemDescriptor

 
 452 bytes in section .text
 
 452 bytes of CODE memory

Errors: none
Warnings: none
