###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:41:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\PersistDataServer\wl\src\wlPdsTypesConverter.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\PersistDataServer\wl\src\wlPdsTypesConverter.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\wlPdsTypesConverter.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\wlPdsTypesConverter.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\PersistDataServer\wl\src\wlPdsTypesConverter.c
      1          /**************************************************************************//**
      2            \file wlPdsTypesConverter.c
      3          
      4            \brief PDS types converter implementation.
      5          
      6            \author
      7              Atmel Corporation: http://www.atmel.com \n
      8              Support email: avr@atmel.com
      9          
     10            Copyright (c) 2008-2013, Atmel Corporation. All rights reserved.
     11            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     12          
     13            \internal
     14             History:
     15              22.05.13 A. Fomin - Created.
     16          ******************************************************************************/
     17          
     18          #if PDS_ENABLE_WEAR_LEVELING == 1
     19          #ifdef _ENABLE_PERSISTENT_SERVER_
     20          /******************************************************************************
     21                              Includes section
     22          ******************************************************************************/
     23          #include <wlPdsBindings.h>
     24          #include <wlPdsMemIds.h>
     25          #include <wlPdsTypesConverter.h>
     26          #include <csBuffers.h>
     27          #include <csSIB.h>
     28          #include <zdoConfigServer.h>
     29          #include <zdoZib.h>
     30          #include <N_ErrH.h>
     31          
     32          /******************************************************************************
     33                              Definitions section
     34          ******************************************************************************/
     35          #define COMPID "wlPdsTypesConverter"
     36          
     37          /******************************************************************************
     38                              Types section
     39          ******************************************************************************/
     40          
     41          
     42          /******************************************************************************
     43                              Externals section
     44          ******************************************************************************/
     45          extern CS_StackBuffers_t stackBuffers;
     46          
     47          extern NIB_t csNIB;
     48          extern SIB_t csSIB;
     49          extern ZIB_t csZIB;
     50          extern AIB_t csAIB;
     51          
     52          /******************************************************************************
     53                              Prototypes section
     54          ******************************************************************************/
     55          static void verifyItemSizes(S_Nv_ItemId_t id, uint16_t size, uint16_t oldSize);
     56          
     57          static bool updateExtendedBcSet(void *data);
     58          #ifdef _SECURITY_
     59          static void updateSecurityCounters(void *data);
     60          #ifdef _NWK_IN_FRAME_COUNTERS_
     61          static void updateSecurityKeys(void *data);
     62          #endif  // _NWK_IN_FRAME_COUNTERS_
     63          #endif  // _SECURITY_
     64          static void updateTable(void *data, uint16_t size, uint16_t oldSize);
     65          #ifdef _BINDING_
     66          static void updateBindTable(void *data, uint16_t size, uint16_t oldSize);
     67          #endif //_BINDING_
     68          #ifdef _GROUP_TABLE_
     69          static void updateGroupTable(void *data, uint16_t size, uint16_t oldSize);
     70          #endif //_GROUP_TABLE_
     71          static void updateNeighborTable(void *data, uint16_t size, uint16_t oldSize);
     72          
     73          /******************************************************************************
     74                              Static variables section
     75          ******************************************************************************/

   \                                 In section .bss, align 8
     76          ExtGetMem_t extGenMem;
   \                     extGenMem:
   \   00000000                      DS8 96
     77          
     78          /******************************************************************************
     79                              Implementation section
     80          ******************************************************************************/
     81          /******************************************************************************
     82          \brief Checks whether item is under security control
     83          
     84          \param[in] id - item id
     85          
     86          \returns true if item is under security control, false - otherwise
     87          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     88          bool pdsIsItemUnderSecurityControl(S_Nv_ItemId_t id)
     89          {
     90          #ifdef PDS_SECURITY_CONTROL_ENABLE
     91            ItemIdToMemoryMapping_t mapItem;
     92          
     93            if (pdsGetItemDescr(id, &mapItem))
     94            {
     95              if (mapItem.flags & ITEM_UNDER_SECURITY_CONTROL)
     96                return true;
     97            }
     98          #else
     99            // To avoid compiler warning
    100            (void)id;
    101          #endif
    102            return false;
   \                     pdsIsItemUnderSecurityControl: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    103          }
    104          
    105          /******************************************************************************
    106          \brief Updates BC parameters after restoring taking into account possible size
    107            changes
    108          
    109          \param[in] id      - item id;
    110          \param[in] data    - pointer to data;
    111          \param[in] size    - current item size;
    112          \param[in] oldSize - last size of item
    113          
    114          returns true if memory was updated successfully, false - otherwise
    115          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    116          bool pdsUpdateMemory(S_Nv_ItemId_t id, void *data, uint16_t size, uint16_t oldSize)
    117          {
   \                     pdsUpdateMemory: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001C             MOVS     R4,R3
    118            verifyItemSizes(id, size, oldSize);
   \   0000000A   0x42A6             CMP      R6,R4
   \   0000000C   0xD011             BEQ      ??pdsUpdateMemory_1
   \   0000000E   0xA902             ADD      R1,SP,#+8
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x8B00             LDRH     R0,[R0, #+24]
   \   00000014   0x.... 0x....      BL       pdsGetItemDescr
   \   00000018   0xA902             ADD      R1,SP,#+8
   \   0000001A   0x7B09             LDRB     R1,[R1, #+12]
   \   0000001C   0x07CA             LSLS     R2,R1,#+31
   \   0000001E   0x0FD2             LSRS     R2,R2,#+31
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x4051             EORS     R1,R1,R2
   \   00000024   0x4208             TST      R0,R1
   \   00000026   0xD004             BEQ      ??pdsUpdateMemory_1
   \   00000028   0x21D3             MOVS     R1,#+211
   \   0000002A   0xBF00             Nop      
   \   0000002C   0x....             ADR.N    R0,?_0
   \   0000002E   0x.... 0x....      BL       N_ErrH_Fatal
    119          
    120            switch (id)
   \                     ??pdsUpdateMemory_1: (+1)
   \   00000032   0x2500             MOVS     R5,#+0
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x8B00             LDRH     R0,[R0, #+24]
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD900             BLS      .+4
   \   0000003E   0xE087             B        ??pdsUpdateMemory_2
   \   00000040   0xA101             ADR      R1,??pdsUpdateMemory_0
   \   00000042   0x5C09             LDRB     R1,[R1, R0]
   \   00000044   0x0049             LSLS     R1,R1,#+1
   \   00000046   0x448F             ADD      PC,PC,R1
   \                     ??pdsUpdateMemory_0:
   \   00000048   0x04 0x0E          DC8      0x4,0xE,0x88,0x88
   \              0x88 0x88    
   \   0000004C   0x59 0x08          DC8      0x59,0x8,0x2A,0x47
   \              0x2A 0x47    
   \   00000050   0x88 0x00          DC8      0x88,0x0
    121            {
    122              case BC_EXT_GEN_MEMORY_ITEM_ID:
    123                return updateExtendedBcSet(data);
   \                     ??pdsUpdateMemory_3: (+1)
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x.... 0x....      BL       updateExtendedBcSet
   \   00000058   0xE080             B        ??pdsUpdateMemory_4
    124          #ifdef _SECURITY_
    125              case NWK_SECURITY_COUNTERS_ITEM_ID:
    126                updateSecurityCounters(data);
   \                     ??pdsUpdateMemory_5: (+1)
   \   0000005A   0x8838             LDRH     R0,[R7, #+0]
   \   0000005C   0x....             LDR      R1,??DataTable5  ;; 0xffff
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD17B             BNE      ??pdsUpdateMemory_6
   \   00000062   0x803D             STRH     R5,[R7, #+0]
   \   00000064   0xE079             B        ??pdsUpdateMemory_6
    127                break;
    128          #endif
    129              case CS_NEIB_TABLE_ITEM_ID:
    130                updateNeighborTable(data, size, oldSize);
   \                     ??pdsUpdateMemory_7: (+1)
   \   00000066   0x42A6             CMP      R6,R4
   \   00000068   0xD077             BEQ      ??pdsUpdateMemory_6
   \   0000006A   0x0022             MOVS     R2,R4
   \   0000006C   0x0031             MOVS     R1,R6
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       updateTable
   \   00000074   0x42B4             CMP      R4,R6
   \   00000076   0xD270             BCS      ??pdsUpdateMemory_6
   \   00000078   0x1938             ADDS     R0,R7,R4
   \   0000007A   0x2106             MOVS     R1,#+6
   \                     ??pdsUpdateMemory_8: (+1)
   \   0000007C   0x7001             STRB     R1,[R0, #+0]
   \   0000007E   0x3020             ADDS     R0,R0,#+32
   \   00000080   0x3420             ADDS     R4,R4,#+32
   \   00000082   0xB2A4             UXTH     R4,R4
   \   00000084   0x42B4             CMP      R4,R6
   \   00000086   0xD3F9             BCC      ??pdsUpdateMemory_8
   \   00000088   0x003B             MOVS     R3,R7
   \   0000008A   0x0032             MOVS     R2,R6
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x.... 0x....      BL       S_Nv_Write_Impl
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD060             BEQ      ??pdsUpdateMemory_6
   \   00000098   0x21CD             MOVS     R1,#+205
   \   0000009A   0x0049             LSLS     R1,R1,#+1        ;; #+410
   \   0000009C   0xE059             B        ??pdsUpdateMemory_9
    131                break;
    132          #ifdef _BINDING_
    133              case CS_APS_BINDING_TABLE_ITEM_ID:
    134                updateBindTable(data, size, oldSize);
   \                     ??pdsUpdateMemory_10: (+1)
   \   0000009E   0x42A6             CMP      R6,R4
   \   000000A0   0xD05B             BEQ      ??pdsUpdateMemory_6
   \   000000A2   0x0022             MOVS     R2,R4
   \   000000A4   0x0031             MOVS     R1,R6
   \   000000A6   0x0038             MOVS     R0,R7
   \   000000A8   0x.... 0x....      BL       updateTable
   \   000000AC   0x42B4             CMP      R4,R6
   \   000000AE   0xD254             BCS      ??pdsUpdateMemory_6
   \   000000B0   0x1938             ADDS     R0,R7,R4
   \   000000B2   0x21A8             MOVS     R1,#+168
   \   000000B4   0x2220             MOVS     R2,#+32
   \                     ??pdsUpdateMemory_11: (+1)
   \   000000B6   0x5481             STRB     R1,[R0, R2]
   \   000000B8   0x3028             ADDS     R0,R0,#+40
   \   000000BA   0x3428             ADDS     R4,R4,#+40
   \   000000BC   0xB2A4             UXTH     R4,R4
   \   000000BE   0x42B4             CMP      R4,R6
   \   000000C0   0xD3F9             BCC      ??pdsUpdateMemory_11
   \   000000C2   0x003B             MOVS     R3,R7
   \   000000C4   0x0032             MOVS     R2,R6
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x2007             MOVS     R0,#+7
   \   000000CA   0x.... 0x....      BL       S_Nv_Write_Impl
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD043             BEQ      ??pdsUpdateMemory_6
   \   000000D2   0x21FF             MOVS     R1,#+255
   \   000000D4   0x3166             ADDS     R1,R1,#+102      ;; #+357
   \   000000D6   0xE03C             B        ??pdsUpdateMemory_9
    135                break;
    136          #endif
    137          #ifdef _GROUP_TABLE_
    138              case CS_GROUP_TABLE_ITEM_ID:
    139                updateGroupTable(data, size, oldSize);
   \                     ??pdsUpdateMemory_12: (+1)
   \   000000D8   0x42A6             CMP      R6,R4
   \   000000DA   0xD03E             BEQ      ??pdsUpdateMemory_6
   \   000000DC   0x0022             MOVS     R2,R4
   \   000000DE   0x0031             MOVS     R1,R6
   \   000000E0   0x0038             MOVS     R0,R7
   \   000000E2   0x.... 0x....      BL       updateTable
   \   000000E6   0x003B             MOVS     R3,R7
   \   000000E8   0x0032             MOVS     R2,R6
   \   000000EA   0x2100             MOVS     R1,#+0
   \   000000EC   0x2008             MOVS     R0,#+8
   \   000000EE   0x.... 0x....      BL       S_Nv_Write_Impl
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD031             BEQ      ??pdsUpdateMemory_6
   \   000000F6   0x21FF             MOVS     R1,#+255
   \   000000F8   0x317C             ADDS     R1,R1,#+124      ;; #+379
   \   000000FA   0xE02A             B        ??pdsUpdateMemory_9
    140                break;
    141          #endif //_GROUP_TABLE_
    142          #ifdef _SECURITY_
    143              case CS_NWK_SECURITY_KEYS_ITEM_ID:
    144          #ifdef _NWK_IN_FRAME_COUNTERS_
    145                updateSecurityKeys(data);
   \                     ??pdsUpdateMemory_13: (+1)
   \   000000FC   0xA900             ADD      R1,SP,#+0
   \   000000FE   0x1C49             ADDS     R1,R1,#+1
   \   00000100   0x2090             MOVS     R0,#+144
   \   00000102   0x0040             LSLS     R0,R0,#+1        ;; #+288
   \   00000104   0x.... 0x....      BL       CS_ReadParameter
   \   00000108   0x4669             MOV      R1,SP
   \   0000010A   0x2081             MOVS     R0,#+129
   \   0000010C   0x0040             LSLS     R0,R0,#+1        ;; #+258
   \   0000010E   0x.... 0x....      BL       CS_ReadParameter
   \   00000112   0xA901             ADD      R1,SP,#+4
   \   00000114   0x....             LDR      R0,??DataTable5_1  ;; 0x21b
   \   00000116   0x.... 0x....      BL       CS_GetMemory
   \   0000011A   0x4668             MOV      R0,SP
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \                     ??pdsUpdateMemory_14: (+1)
   \   0000011E   0x4669             MOV      R1,SP
   \   00000120   0x7849             LDRB     R1,[R1, #+1]
   \   00000122   0x428D             CMP      R5,R1
   \   00000124   0xDA19             BGE      ??pdsUpdateMemory_6
   \   00000126   0x211C             MOVS     R1,#+28
   \   00000128   0x4369             MULS     R1,R5,R1
   \   0000012A   0x1879             ADDS     R1,R7,R1
   \   0000012C   0x780A             LDRB     R2,[R1, #+0]
   \   0000012E   0x2A00             CMP      R2,#+0
   \   00000130   0xD00C             BEQ      ??pdsUpdateMemory_15
   \   00000132   0x9A01             LDR      R2,[SP, #+4]
   \   00000134   0x784B             LDRB     R3,[R1, #+1]
   \   00000136   0x4343             MULS     R3,R0,R3
   \   00000138   0x011B             LSLS     R3,R3,#+4
   \   0000013A   0x18D2             ADDS     R2,R2,R3
   \   0000013C   0x614A             STR      R2,[R1, #+20]
   \   0000013E   0x9A01             LDR      R2,[SP, #+4]
   \   00000140   0x784B             LDRB     R3,[R1, #+1]
   \   00000142   0x1C5B             ADDS     R3,R3,#+1
   \   00000144   0x4343             MULS     R3,R0,R3
   \   00000146   0x011B             LSLS     R3,R3,#+4
   \   00000148   0x18D2             ADDS     R2,R2,R3
   \   0000014A   0x618A             STR      R2,[R1, #+24]
   \                     ??pdsUpdateMemory_15: (+1)
   \   0000014C   0x1C6D             ADDS     R5,R5,#+1
   \   0000014E   0xE7E6             B        ??pdsUpdateMemory_14
    146          #endif
    147                break;
    148              case CS_APS_KEY_PAIR_DESCRIPTORS_ITEM_ID:
    149              case CS_NWK_SECURITY_IB_ITEM_ID:
    150          #endif
    151              case NWK_RREQ_IDENTIFIER_ITEM_ID:
    152                break;
    153              default:
    154          #ifndef ATMEL_APPLICATION_SUPPORT
    155                N_ERRH_FATAL();
   \                     ??pdsUpdateMemory_2: (+1)
   \   00000150   0x219B             MOVS     R1,#+155
   \                     ??pdsUpdateMemory_9: (+1)
   \   00000152   0xBF00             Nop      
   \   00000154   0x....             ADR.N    R0,?_0
   \   00000156   0x.... 0x....      BL       N_ErrH_Fatal
    156          #endif
    157                break;
    158            }
    159          
    160            return true;
   \                     ??pdsUpdateMemory_6: (+1)
   \   0000015A   0x2001             MOVS     R0,#+1
   \                     ??pdsUpdateMemory_4: (+1)
   \   0000015C   0xB007             ADD      SP,SP,#+28
   \   0000015E   0xBDF0             POP      {R4-R7,PC}       ;; return
    161          }
    162          /******************************************************************************
    163          \brief Fills extended BC set
    164          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    165          void fillExtendedBcSet(void)
    166          {
   \                     fillExtendedBcSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    167            extGenMem.csUid = csPIB.macAttr.extAddr;
   \   00000002   0x....             LDR      R4,??DataTable5_2
   \   00000004   0x....             LDR      R0,??DataTable5_3
   \   00000006   0xC803             LDM      R0,{R0,R1}
   \   00000008   0xC403             STM      R4!,{R0,R1}
   \   0000000A   0x3C08             SUBS     R4,R4,#+8
    168            extGenMem.txPower = csSIB.csRfTxPower;
   \   0000000C   0x....             LDR      R2,??DataTable5_4
   \   0000000E   0x1D15             ADDS     R5,R2,#+4
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x7220             STRB     R0,[R4, #+8]
    169            extGenMem.extPanId = csSIB.csExtPANID;
   \   00000014   0x0017             MOVS     R7,R2
   \   00000016   0x3748             ADDS     R7,R7,#+72
   \   00000018   0xCF03             LDM      R7!,{R0,R1}
   \   0000001A   0x3F08             SUBS     R7,R7,#+8
   \   0000001C   0x0023             MOVS     R3,R4
   \   0000001E   0x3310             ADDS     R3,R3,#+16
   \   00000020   0xC303             STM      R3!,{R0,R1}
    170            extGenMem.channelMask = csZIB.channelMask;
   \   00000022   0x....             LDR      R0,??DataTable5_5
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x61A0             STR      R0,[R4, #+24]
    171            extGenMem.channelPage = csNIB.channelPage;
   \   00000028   0x....             LDR      R6,??DataTable5_6
   \   0000002A   0x2077             MOVS     R0,#+119
   \   0000002C   0x5C30             LDRB     R0,[R6, R0]
   \   0000002E   0x7720             STRB     R0,[R4, #+28]
    172            extGenMem.deviceType = csNIB.deviceType;
   \   00000030   0x206E             MOVS     R0,#+110
   \   00000032   0x5C30             LDRB     R0,[R6, R0]
   \   00000034   0x7760             STRB     R0,[R4, #+29]
    173            extGenMem.rxOnWhenIdle = csSIB.csRxOnWhenIdle;
   \   00000036   0x7F28             LDRB     R0,[R5, #+28]
   \   00000038   0x77A0             STRB     R0,[R4, #+30]
    174            extGenMem.complexDescrAvailable = csSIB.csComplexDescriptorAvailable;
   \   0000003A   0x7F68             LDRB     R0,[R5, #+29]
   \   0000003C   0x77E0             STRB     R0,[R4, #+31]
    175            extGenMem.userDescrAvailable = csSIB.csUserDescriptorAvailable;
   \   0000003E   0x7FA8             LDRB     R0,[R5, #+30]
   \   00000040   0x2120             MOVS     R1,#+32
   \   00000042   0x5460             STRB     R0,[R4, R1]
    176            extGenMem.userDescr = csSIB.csUserDescriptor;
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x3021             ADDS     R0,R0,#+33
   \   00000048   0x3230             ADDS     R2,R2,#+48
   \   0000004A   0x0011             MOVS     R1,R2
   \   0000004C   0x2211             MOVS     R2,#+17
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy
    177            extGenMem.panId = csSIB.csNwkPanid;
   \   00000052   0x8868             LDRH     R0,[R5, #+2]
   \   00000054   0x8660             STRH     R0,[R4, #+50]
    178            extGenMem.predefinedPanId = csSIB.csNwkPredefinedPanid;
   \   00000056   0x7A28             LDRB     R0,[R5, #+8]
   \   00000058   0x2134             MOVS     R1,#+52
   \   0000005A   0x5460             STRB     R0,[R4, R1]
    179            extGenMem.shortAddress = csNIB.networkAddress;
   \   0000005C   0x207A             MOVS     R0,#+122
   \   0000005E   0x5A30             LDRH     R0,[R6, R0]
   \   00000060   0x86E0             STRH     R0,[R4, #+54]
    180            extGenMem.uniqueNwkAddress = csNIB.uniqueAddr;
   \   00000062   0x2071             MOVS     R0,#+113
   \   00000064   0x5C30             LDRB     R0,[R6, R0]
   \   00000066   0x2138             MOVS     R1,#+56
   \   00000068   0x5460             STRB     R0,[R4, R1]
    181            extGenMem.leaveReqAllowed = csNIB.leaveReqAllowed;
   \   0000006A   0x2092             MOVS     R0,#+146
   \   0000006C   0x5C30             LDRB     R0,[R6, R0]
   \   0000006E   0x2139             MOVS     R1,#+57
   \   00000070   0x5460             STRB     R0,[R4, R1]
    182            extGenMem.dtrWakeUp = csSIB.csDtrWakeup;
   \   00000072   0x7A38             LDRB     R0,[R7, #+8]
   \   00000074   0x213A             MOVS     R1,#+58
   \   00000076   0x5460             STRB     R0,[R4, R1]
    183            extGenMem.updateId = csNIB.updateId;
   \   00000078   0x7C30             LDRB     R0,[R6, #+16]
   \   0000007A   0x213B             MOVS     R1,#+59
   \   0000007C   0x5460             STRB     R0,[R4, R1]
    184          #if defined _SECURITY_
    185            extGenMem.extTcAddress = csAIB.trustCenterAddress;
   \   0000007E   0x....             LDR      R2,??DataTable5_7
   \   00000080   0x0010             MOVS     R0,R2
   \   00000082   0x3008             ADDS     R0,R0,#+8
   \   00000084   0xC803             LDM      R0,{R0,R1}
   \   00000086   0x6420             STR      R0,[R4, #+64]
   \   00000088   0x6461             STR      R1,[R4, #+68]
    186            extGenMem.nwkTcAddress = csAIB.tcNwkAddr;
   \   0000008A   0x8A10             LDRH     R0,[R2, #+16]
   \   0000008C   0x2148             MOVS     R1,#+72
   \   0000008E   0x5260             STRH     R0,[R4, R1]
    187            extGenMem.securityStatus = csSIB.csZdoSecurityStatus;
   \   00000090   0x7AB8             LDRB     R0,[R7, #+10]
   \   00000092   0x214A             MOVS     R1,#+74
   \   00000094   0x5460             STRB     R0,[R4, R1]
    188          #endif 
    189            extGenMem.parentNwkAddress = csNIB.parentNetworkAddress;
   \   00000096   0x8830             LDRH     R0,[R6, #+0]
   \   00000098   0x214C             MOVS     R1,#+76
   \   0000009A   0x5260             STRH     R0,[R4, R1]
    190            extGenMem.nwkDepth = csNIB.depth;
   \   0000009C   0x7A70             LDRB     R0,[R6, #+9]
   \   0000009E   0x214E             MOVS     R1,#+78
   \   000000A0   0x5460             STRB     R0,[R4, R1]
    191            extGenMem.nwkExtPanId = csNIB.extendedPanId;
   \   000000A2   0x3680             ADDS     R6,R6,#+128
   \   000000A4   0xCE03             LDM      R6!,{R0,R1}
   \   000000A6   0x6520             STR      R0,[R4, #+80]
   \   000000A8   0x6561             STR      R1,[R4, #+84]
    192            extGenMem.logicalChannel = csSIB.csNwkLogicalChannel;
   \   000000AA   0x79E8             LDRB     R0,[R5, #+7]
   \   000000AC   0x3458             ADDS     R4,R4,#+88
   \   000000AE   0x7020             STRB     R0,[R4, #+0]
    193          }
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    194          
    195          /******************************************************************************
    196          \brief Verifies whether size change is allowed for given item
    197          
    198          \param[in] id      - item id;
    199          \param[in] size    - current item size;
    200          \param[in] oldSize - last size of item
    201          ******************************************************************************/
    202          static void verifyItemSizes(S_Nv_ItemId_t id, uint16_t size, uint16_t oldSize)
    203          {
    204            ItemIdToMemoryMapping_t mapItem;
    205          
    206            if (size == oldSize)
    207              return;
    208          
    209            if (pdsGetItemDescr(id, &mapItem))
    210            {
    211              N_ERRH_ASSERT_FATAL(mapItem.flags & SIZE_MODIFICATION_ALLOWED);
    212            }
    213          }
    214          
    215          /******************************************************************************
    216          \brief Updates extneded BC set of stack parameters
    217          
    218          \param[in] data - pointer to data with BC set
    219          
    220          \returns returns true extended BC set was updated successfully,
    221            false - otherwise
    222          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          static bool updateExtendedBcSet(void *data)
    224          {
   \                     updateExtendedBcSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    225            ExtGetMem_t *extGenMem = (ExtGetMem_t *)data;
    226            uint8_t *ptr = (uint8_t *)data;
    227            bool inconsistentFlag = true;
    228          
    229            // check network parameters for inconsistence
    230            for (uint8_t i = 0U; i < sizeof(ExtGetMem_t); i++)
   \   00000004   0x2000             MOVS     R0,#+0
    231              if (0xFFU != ptr[i])
   \                     ??updateExtendedBcSet_0: (+1)
   \   00000006   0x5C21             LDRB     R1,[R4, R0]
   \   00000008   0x29FF             CMP      R1,#+255
   \   0000000A   0xD055             BEQ      ??updateExtendedBcSet_1
    232              {
    233                inconsistentFlag = false;
    234                break;
    235              }
    236          
    237            if (inconsistentFlag)
    238              return false;
    239          
    240            // update appropriate BC structures
    241            csPIB.macAttr.extAddr = extGenMem->csUid;
   \   0000000C   0xCC03             LDM      R4!,{R0,R1}
   \   0000000E   0x3C08             SUBS     R4,R4,#+8
   \   00000010   0x....             LDR      R2,??DataTable5_3
   \   00000012   0xC203             STM      R2!,{R0,R1}
    242            csSIB.csRfTxPower = extGenMem->txPower;
   \   00000014   0x....             LDR      R2,??DataTable5_4
   \   00000016   0x1D15             ADDS     R5,R2,#+4
   \   00000018   0x0026             MOVS     R6,R4
   \   0000001A   0x3608             ADDS     R6,R6,#+8
   \   0000001C   0x7830             LDRB     R0,[R6, #+0]
   \   0000001E   0x7028             STRB     R0,[R5, #+0]
    243            csSIB.csExtPANID = extGenMem->extPanId;
   \   00000020   0x0010             MOVS     R0,R2
   \   00000022   0x3048             ADDS     R0,R0,#+72
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x3008             ADDS     R0,R0,#+8
   \   0000002A   0xC803             LDM      R0,{R0,R1}
   \   0000002C   0x9B00             LDR      R3,[SP, #+0]
   \   0000002E   0xC303             STM      R3!,{R0,R1}
    244            csZIB.channelMask = extGenMem->channelMask;
   \   00000030   0x6930             LDR      R0,[R6, #+16]
   \   00000032   0x....             LDR      R1,??DataTable5_5
   \   00000034   0x6008             STR      R0,[R1, #+0]
    245            csNIB.channelPage = extGenMem->channelPage;
   \   00000036   0x....             LDR      R7,??DataTable5_6
   \   00000038   0x7D30             LDRB     R0,[R6, #+20]
   \   0000003A   0x2177             MOVS     R1,#+119
   \   0000003C   0x5478             STRB     R0,[R7, R1]
    246            csNIB.deviceType = extGenMem->deviceType;
   \   0000003E   0x7D70             LDRB     R0,[R6, #+21]
   \   00000040   0x216E             MOVS     R1,#+110
   \   00000042   0x5478             STRB     R0,[R7, R1]
    247            csSIB.csRxOnWhenIdle = extGenMem->rxOnWhenIdle;
   \   00000044   0x7DB0             LDRB     R0,[R6, #+22]
   \   00000046   0x7728             STRB     R0,[R5, #+28]
    248            csSIB.csComplexDescriptorAvailable = extGenMem->complexDescrAvailable;
   \   00000048   0x7DF0             LDRB     R0,[R6, #+23]
   \   0000004A   0x7768             STRB     R0,[R5, #+29]
    249            csSIB.csUserDescriptorAvailable = extGenMem->userDescrAvailable;
   \   0000004C   0x7E30             LDRB     R0,[R6, #+24]
   \   0000004E   0x77A8             STRB     R0,[R5, #+30]
    250            csSIB.csUserDescriptor = extGenMem->userDescr;
   \   00000050   0x3230             ADDS     R2,R2,#+48
   \   00000052   0x0010             MOVS     R0,R2
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x3121             ADDS     R1,R1,#+33
   \   00000058   0x2211             MOVS     R2,#+17
   \   0000005A   0x.... 0x....      BL       __aeabi_memcpy
    251            csSIB.csNwkPanid = extGenMem->panId;
   \   0000005E   0x8D70             LDRH     R0,[R6, #+42]
   \   00000060   0x8068             STRH     R0,[R5, #+2]
    252            csSIB.csNwkPredefinedPanid = extGenMem->predefinedPanId;
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x3034             ADDS     R0,R0,#+52
   \   00000066   0x7801             LDRB     R1,[R0, #+0]
   \   00000068   0x7229             STRB     R1,[R5, #+8]
    253            csNIB.networkAddress = extGenMem->shortAddress;
   \   0000006A   0x8841             LDRH     R1,[R0, #+2]
   \   0000006C   0x227A             MOVS     R2,#+122
   \   0000006E   0x52B9             STRH     R1,[R7, R2]
    254            csNIB.uniqueAddr = extGenMem->uniqueNwkAddress;
   \   00000070   0x7901             LDRB     R1,[R0, #+4]
   \   00000072   0x2271             MOVS     R2,#+113
   \   00000074   0x54B9             STRB     R1,[R7, R2]
    255            csNIB.leaveReqAllowed = extGenMem->leaveReqAllowed;
   \   00000076   0x7941             LDRB     R1,[R0, #+5]
   \   00000078   0x2292             MOVS     R2,#+146
   \   0000007A   0x54B9             STRB     R1,[R7, R2]
    256            csSIB.csDtrWakeup = extGenMem->dtrWakeUp;
   \   0000007C   0x7981             LDRB     R1,[R0, #+6]
   \   0000007E   0x9A00             LDR      R2,[SP, #+0]
   \   00000080   0x7211             STRB     R1,[R2, #+8]
    257            csNIB.updateId = extGenMem->updateId;
   \   00000082   0x79C0             LDRB     R0,[R0, #+7]
   \   00000084   0x7438             STRB     R0,[R7, #+16]
    258          #ifdef _SECURITY_  
    259            csAIB.trustCenterAddress = extGenMem->extTcAddress;
   \   00000086   0x3440             ADDS     R4,R4,#+64
   \   00000088   0x....             LDR      R3,??DataTable5_7
   \   0000008A   0xCC03             LDM      R4!,{R0,R1}
   \   0000008C   0x3C08             SUBS     R4,R4,#+8
   \   0000008E   0x001A             MOVS     R2,R3
   \   00000090   0x3208             ADDS     R2,R2,#+8
   \   00000092   0xC203             STM      R2!,{R0,R1}
    260            csAIB.tcNwkAddr = extGenMem->nwkTcAddress;
   \   00000094   0x8920             LDRH     R0,[R4, #+8]
   \   00000096   0x8218             STRH     R0,[R3, #+16]
    261            csSIB.csZdoSecurityStatus = extGenMem->securityStatus;
   \   00000098   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000009A   0x9900             LDR      R1,[SP, #+0]
   \   0000009C   0x7288             STRB     R0,[R1, #+10]
    262          #endif  
    263            csNIB.parentNetworkAddress = extGenMem->parentNwkAddress;
   \   0000009E   0x89A0             LDRH     R0,[R4, #+12]
   \   000000A0   0x8038             STRH     R0,[R7, #+0]
    264            csNIB.depth = extGenMem->nwkDepth;
   \   000000A2   0x7BA0             LDRB     R0,[R4, #+14]
   \   000000A4   0x7278             STRB     R0,[R7, #+9]
    265            csNIB.extendedPanId = extGenMem->nwkExtPanId;
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x3010             ADDS     R0,R0,#+16
   \   000000AA   0xC803             LDM      R0,{R0,R1}
   \   000000AC   0x3780             ADDS     R7,R7,#+128
   \   000000AE   0xC703             STM      R7!,{R0,R1}
    266            csSIB.csNwkLogicalChannel = extGenMem->logicalChannel;
   \   000000B0   0x7E20             LDRB     R0,[R4, #+24]
   \   000000B2   0x71E8             STRB     R0,[R5, #+7]
    267          
    268            return true;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??updateExtendedBcSet_1: (+1)
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \   000000BA   0xB2C0             UXTB     R0,R0
   \   000000BC   0x2860             CMP      R0,#+96
   \   000000BE   0xD3A2             BCC      ??updateExtendedBcSet_0
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    269          }
    270          #ifdef _SECURITY_ 
    271          /******************************************************************************
    272          \brief Updates outgoing security counters
    273          
    274          \param[in] data - pointer to data top part of security counter
    275          ******************************************************************************/
    276          static void updateSecurityCounters(void *data)
    277          {
    278            NwkOutFrameCounterTop_t *counterTop = (NwkOutFrameCounterTop_t *)data;
    279          
    280            // we restored default after-init value
    281            if (0xFFFF == *counterTop)
    282              *counterTop = 0;
    283          }
    284          
    285          #ifdef _NWK_IN_FRAME_COUNTERS_
    286          /******************************************************************************
    287          \brief Updates security keys
    288          
    289          \param[in] data - pointer to key
    290          ******************************************************************************/
    291          static void updateSecurityKeys(void *data)
    292          {
    293            NWK_SecurityKey_t *keys = (NWK_SecurityKey_t *)data;
    294            NWK_InFrameCounterEntry_t *inFrameCounterSet;
    295            NwkKeyAmount_t keyAmount;
    296            uint8_t keyIndex;
    297            uint8_t neighborsAmount;
    298          
    299            CS_ReadParameter(CS_NWK_SECURITY_KEYS_AMOUNT_ID, &keyAmount);
    300            CS_ReadParameter(CS_NEIB_TABLE_SIZE_ID, &neighborsAmount);
    301            CS_GetMemory(CS_NWK_INCOMING_FRAME_COUNTER_SET_ID, NWK_ADDR_OF_TABLE(inFrameCounterSet));
    302          
    303            for (keyIndex = 0U; keyIndex < keyAmount; ++keyIndex)
    304            {
    305              if (keys[keyIndex].isSet)
    306              {
    307                keys[keyIndex].inFrameCounterSet.table = inFrameCounterSet + neighborsAmount * keys[keyIndex].seqNum;
    308                keys[keyIndex].inFrameCounterSet.end   = inFrameCounterSet + neighborsAmount * (keys[keyIndex].seqNum + 1);
    309              }
    310            }
    311          }
    312          #endif
    313          #endif
    314          /******************************************************************************
    315          \brief Updates table
    316          
    317          \param[in] data    - pointer to data with table;
    318          \param[in] size    - current item size;
    319          \param[in] oldSize - last size of item
    320          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    321          static void updateTable(void *data, uint16_t size, uint16_t oldSize)
    322          {
    323            uint8_t *ptr = (uint8_t *)data;
    324          
    325            if (size > oldSize)
   \                     updateTable: (+1)
   \   00000000   0x428A             CMP      R2,R1
   \   00000002   0xD300             BCC      ??updateTable_0
   \   00000004   0x4770             BX       LR
    326              memset(ptr + oldSize, 0U, size - oldSize);
   \                     ??updateTable_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x1A89             SUBS     R1,R1,R2
   \   0000000A   0x1880             ADDS     R0,R0,R2
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr
    327          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    328          #ifdef _BINDING_
    329          /******************************************************************************
    330          \brief Updates binding table
    331          
    332          \param[in] data    - pointer to data with binding table;
    333          \param[in] size    - current item size;
    334          \param[in] oldSize - last size of item
    335          ******************************************************************************/
    336          static void updateBindTable(void *data, uint16_t size, uint16_t oldSize)
    337          {
    338            if (size == oldSize)
    339              return;
    340          
    341            updateTable(data, size, oldSize);
    342          
    343            if (size > oldSize)
    344            {
    345              uint8_t *ptr = (uint8_t *)data + oldSize; // points to added records;
    346              ApsBindingEntry_t *entry = (ApsBindingEntry_t *)ptr;
    347              S_Nv_ReturnValue_t ret;
    348          
    349              // go through all new records and mark them as free
    350              while (oldSize < size)
    351              {
    352                entry->confirm.status = APS_NO_BOUND_DEVICE_STATUS;
    353                entry++;
    354                oldSize += sizeof(ApsBindingEntry_t);
    355              }
    356              ret = S_Nv_Write(CS_APS_BINDING_TABLE_ITEM_ID, 0U, size, data);
    357              N_ERRH_ASSERT_FATAL(ret == S_Nv_ReturnValue_Ok);
    358            }
    359          }
    360          #endif // _BINDING_
    361          #ifdef _GROUP_TABLE_
    362          /******************************************************************************
    363          \brief Updates group table
    364          
    365          \param[in] data    - pointer to data with group table;
    366          \param[in] size    - current item size;
    367          \param[in] oldSize - last size of item
    368          ******************************************************************************/
    369          static void updateGroupTable(void *data, uint16_t size, uint16_t oldSize)
    370          {
    371            S_Nv_ReturnValue_t ret;
    372          
    373            if (size == oldSize)
    374              return;
    375          
    376            updateTable(data, size, oldSize);
    377          
    378            ret = S_Nv_Write(CS_GROUP_TABLE_ITEM_ID, 0U, size, data);
    379            N_ERRH_ASSERT_FATAL(ret == S_Nv_ReturnValue_Ok);
    380          }
    381          #endif //_GROUP_TABLE_
    382          /******************************************************************************
    383          \brief Updates neighbor table
    384          
    385          \param[in] data    - pointer to data with neighbor table;
    386          \param[in] size    - current item size;
    387          \param[in] oldSize - last size of item
    388          ******************************************************************************/
    389          static void updateNeighborTable(void *data, uint16_t size, uint16_t oldSize)
    390          {
    391            if (size == oldSize)
    392              return;
    393          
    394            updateTable(data, size, oldSize);
    395          
    396            if (size > oldSize)
    397            {
    398              uint8_t *ptr = (uint8_t *)data + oldSize; // points to added records;
    399              Neib_t *entry = (Neib_t *)ptr;
    400              S_Nv_ReturnValue_t ret;
    401          
    402              // go through all new records and mark them as free
    403              while (oldSize < size)
    404              {
    405                entry->relationship = RELATIONSHIP_EMPTY;
    406                entry++;
    407                oldSize += sizeof(Neib_t);
    408              }
    409              ret = S_Nv_Write(CS_NEIB_TABLE_ITEM_ID, 0U, size, data);
    410              N_ERRH_ASSERT_FATAL(ret == S_Nv_ReturnValue_Ok);
    411            }
    412          }
    413          /******************************************************************************
    414          \brief To get the item descriptor for the given item ID
    415          
    416          \param[in] itemId            - item id;
    417          \param[in] itemDescrToGet    - pointer to item descriptor to be loaded;
    418          
    419          returns true if descriptor is found out for the given item ID, false - otherwise
    420          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          bool pdsGetItemDescr(S_Nv_ItemId_t itemId, ItemIdToMemoryMapping_t *itemDescrToGet )
    422          {
   \                     pdsGetItemDescr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    423            ItemIdToMemoryMapping_t *itemDescrPtr = (ItemIdToMemoryMapping_t *)PDS_FF_START;
   \   00000008   0x....             LDR      R6,??DataTable5_8
    424          
    425            /* Calculate raw data size */
    426            for (uint8_t fileIdx = 0; fileIdx < PDS_ITEM_AMOUNT; fileIdx++)
   \   0000000A   0x2729             MOVS     R7,#+41
    427            {
    428              ItemIdToMemoryMapping_t itemDescr;
    429          
    430              memcpy_P(&itemDescr, (void const FLASH_PTR *)itemDescrPtr, sizeof(ItemIdToMemoryMapping_t));
   \                     ??pdsGetItemDescr_0: (+1)
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x0031             MOVS     R1,R6
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    431              if(itemDescr.itemId == itemId)
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD104             BNE      ??pdsGetItemDescr_1
    432              {
    433                memcpy(itemDescrToGet, &itemDescr, sizeof(ItemIdToMemoryMapping_t));
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0xC81E             LDM      R0!,{R1-R4}
   \   00000022   0xC51E             STM      R5!,{R1-R4}
    434                return true;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE003             B        ??pdsGetItemDescr_2
    435              }
    436              itemDescrPtr++;
   \                     ??pdsGetItemDescr_1: (+1)
   \   00000028   0x3610             ADDS     R6,R6,#+16
    437            }
   \   0000002A   0x1E7F             SUBS     R7,R7,#+1
   \   0000002C   0xD1EE             BNE      ??pdsGetItemDescr_0
    438            return false;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??pdsGetItemDescr_2: (+1)
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBDF0             POP      {R4-R7,PC}       ;; return
    439          }
    440          /******************************************************************************
    441          \brief To get the directory descriptor for the given dir ID
    442          
    443          \param[in] itemId           - item id;
    444          \param[in] dirDescrToGet    - pointer to dir descriptor to be loaded;
    445          
    446          returns true if descriptor is found out for the given dir ID, false - otherwise
    447          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    448          bool pdsGetDirDescr(S_Nv_ItemId_t itemId, PDS_DirDescr_t *dirDescrToGet )
    449          {
   \                     pdsGetDirDescr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    450            PDS_DirDescr_t *dirDescrPtr = (PDS_DirDescr_t *)PDS_FD_START;
   \   00000008   0x....             LDR      R6,??DataTable5_9
    451          
    452            /* Calculate raw data size */
    453            for (uint8_t fileIdx = 0; fileIdx < PDS_DIRECTORIES_AMOUNT; fileIdx++)
   \   0000000A   0x2705             MOVS     R7,#+5
    454            {
    455              PDS_DirDescr_t dirDescr;
    456          
    457              memcpy_P(&dirDescr, (void const FLASH_PTR *)dirDescrPtr, sizeof(PDS_DirDescr_t));
   \                     ??pdsGetDirDescr_0: (+1)
   \   0000000C   0x2208             MOVS     R2,#+8
   \   0000000E   0x0031             MOVS     R1,R6
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    458              if(dirDescr.memoryId == itemId)
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x88C0             LDRH     R0,[R0, #+6]
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD104             BNE      ??pdsGetDirDescr_1
    459              {
    460                memcpy(dirDescrToGet, &dirDescr, sizeof(PDS_DirDescr_t));
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0xC806             LDM      R0!,{R1,R2}
   \   00000022   0xC506             STM      R5!,{R1,R2}
    461                return true;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBDFE             POP      {R1-R7,PC}
    462              }
    463              dirDescrPtr++;
   \                     ??pdsGetDirDescr_1: (+1)
   \   00000028   0x3608             ADDS     R6,R6,#+8
    464            }
   \   0000002A   0x1E7F             SUBS     R7,R7,#+1
   \   0000002C   0xD1EE             BNE      ??pdsGetDirDescr_0
    465            return false;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBDFE             POP      {R1-R7,PC}       ;; return
    466          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x0000021B         DC32     0x21b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     extGenMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     csPIB+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     csSIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     csZIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     csNIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     csAIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     SFB(PDS_FF)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     SFB(PDS_FD)

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x77 0x6C          DC8 "wlPdsTypesConverter"
   \              0x50 0x64    
   \              0x73 0x54    
   \              0x79 0x70    
   \              0x65 0x73    
   \              0x43 0x6F    
   \              0x6E 0x76    
   \              0x65 0x72    
   \              0x74 0x65    
   \              0x72 0x00    
    467          #endif // _ENABLE_PERSISTENT_SERVER_
    468          #endif // PDS_ENABLE_WEAR_LEVELING == 1
    469          // eof wlPdsTypesConverter.c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   fillExtendedBcSet
        24   -> __aeabi_memcpy
      32   pdsGetDirDescr
        32   -> __aeabi_memcpy
      40   pdsGetItemDescr
        40   -> __aeabi_memcpy
       0   pdsIsItemUnderSecurityControl
      48   pdsUpdateMemory
        48   -> CS_GetMemory
        48   -> CS_ReadParameter
        48   -> N_ErrH_Fatal
        48   -> S_Nv_Write_Impl
        48   -> pdsGetItemDescr
        48   -> updateExtendedBcSet
        48   -> updateTable
      24   updateExtendedBcSet
        24   -> __aeabi_memcpy
       8   updateTable
         8   -> __aeabi_memclr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      20  ?_0
      96  extGenMem
     178  fillExtendedBcSet
      50  pdsGetDirDescr
      52  pdsGetItemDescr
       4  pdsIsItemUnderSecurityControl
     352  pdsUpdateMemory
     196  updateExtendedBcSet
      18  updateTable

 
  96 bytes in section .bss
 910 bytes in section .text
 
 910 bytes of CODE memory
  96 bytes of DATA memory

Errors: none
Warnings: none
