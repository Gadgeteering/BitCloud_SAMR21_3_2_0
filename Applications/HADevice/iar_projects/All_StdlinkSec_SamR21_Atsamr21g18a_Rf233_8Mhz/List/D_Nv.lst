###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:40:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZLLPlatform\ZLL\D_Nv\src\D_Nv.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZLLPlatform\ZLL\D_Nv\src\D_Nv.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\D_Nv.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\D_Nv.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZLLPlatform\ZLL\D_Nv\src\D_Nv.c
      1          /**
      2            \file D_Nv.c
      3          
      4            \brief NV component implementation.
      5          
      6            \author
      7              Atmel Corporation: http://www.atmel.com \n
      8              Support email: avr@atmel.com
      9          
     10            Copyright (c) 2008-2013, Atmel Corporation. All rights reserved.
     11            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     12          
     13            \internal
     14              History:
     15              15.06.13 N. Fomin - created
     16              24.06.13 M. E. Johansen - modified
     17          */
     18          
     19          #if PDS_ENABLE_WEAR_LEVELING == 1
     20          #ifdef _ENABLE_PERSISTENT_SERVER_
     21          /******************************************************************************
     22                             Includes section
     23          ******************************************************************************/
     24          #include <D_Nv_Bindings.h>
     25          #include <D_Nv.h>
     26          #include <D_Nv_Init.h>
     27          #include <flash.h>
     28          #include <N_ErrH.h>
     29          #include <N_Types.h>
     30          #include <sysUtils.h>
     31          
     32          /******************************************************************************
     33                             Definitions section
     34          ******************************************************************************/
     35          #define COMPID "D_Nv"
     36          
     37          #ifdef  __IAR_SYSTEMS_ICC__
     38          #pragma segment="D_NV_MEMORY"
     39          #define D_NV_MEMORY_START  ((uint32_t)__sfb("D_NV_MEMORY"))
     40          // Location of last memory element, NOT the first memory location after it
     41          #define D_NV_MEMORY_END  ((uint32_t)__sfe("D_NV_MEMORY") - 1U)
     42          #elif __GNUC__
     43          #define D_NV_MEMORY_START (uint32_t)&__d_nv_mem_start
     44          #define D_NV_MEMORY_END (((uint32_t)&__d_nv_mem_end) - 1U)
     45          #else
     46            #error "Unsupported compiler"
     47          #endif
     48          
     49          /******************************************************************************
     50                             Extern section
     51          ******************************************************************************/
     52          #ifdef __GNUC__
     53          extern uint32_t __d_nv_mem_start;
     54          extern uint32_t __d_nv_mem_end;
     55          #endif
     56          
     57          /***************************************************************************************************
     58          * LOCAL FUNCTION DECLARATIONS
     59          ***************************************************************************************************/
     60          static bool CompareData(uint8_t sector, uint16_t offset, uint8_t *pBuffer, D_Nv_Size_t numberOfBytes);
     61          
     62          /******************************************************************************
     63                             Implementations section
     64          ******************************************************************************/
     65          /** Initializes the component -- checks that parameters are correct.
     66          */

   \                                 In section .text, align 4, keep-with-next
     67          void D_Nv_Init(void)
     68          {
   \                     D_Nv_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     69            // Ensure that the memory range starts on a page boundary
     70            N_ERRH_ASSERT_FATAL((D_NV_MEMORY_START % D_NV_PAGE_SIZE) == 0U);
   \   00000002   0xBF00             Nop      
   \   00000004   0x....             ADR.N    R4,?_0
   \   00000006   0x....             LDR      R5,??DataTable5
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD003             BEQ      ??D_Nv_Init_0
   \   0000000C   0x2146             MOVS     R1,#+70
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       N_ErrH_Fatal
     71            // Ensure that sector size is an integer number of pages
     72            N_ERRH_ASSERT_FATAL((D_NV_SECTOR_SIZE % D_NV_PAGE_SIZE) == 0U);
     73            // Ensure that segment is as large as we need
     74            N_ERRH_ASSERT_FATAL((D_NV_MEMORY_END - D_NV_MEMORY_START + 1U) == D_NV_MEMORY_SIZE);
   \                     ??D_Nv_Init_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable5_1
   \   00000016   0x1B40             SUBS     R0,R0,R5
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD003             BEQ      ??D_Nv_Init_1
   \   00000022   0x214A             MOVS     R1,#+74
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       N_ErrH_Fatal
     75          }
   \                     ??D_Nv_Init_1: (+1)
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     76          
     77          /** Read bytes from the internal NV.
     78              \param sector The sector to use (0..D_NV_SECTOR_COUNT)
     79              \param offset The offset to start reading at
     80              \param[out] pBuffer The start address of the buffer to store the read data to
     81              \param numberOfBytes The number of bytes to read
     82              \note offset+numberOfBytes must be <= D_NV_SECTOR_SIZE (meaning sector crossing is not permitted)
     83          */

   \                                 In section .text, align 4, keep-with-next
     84          void D_Nv_Read(uint8_t sector, uint16_t offset, uint8_t *pBuffer, D_Nv_Size_t numberOfBytes)
     85          {
   \                     D_Nv_Read_Impl: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
     86            uint32_t address = D_NV_MEMORY_START + (uint32_t)(sector - D_NV_FIRST_SECTOR) * D_NV_SECTOR_SIZE + offset;
   \   00000004   0x....             LDR      R1,??DataTable5
   \   00000006   0x0340             LSLS     R0,R0,#+13
   \   00000008   0x1808             ADDS     R0,R1,R0
   \   0000000A   0x1907             ADDS     R7,R0,R4
   \   0000000C   0x....             LDR      R5,??DataTable5_2
   \   0000000E   0xBF00             Nop      
   \   00000010   0x....             ADR.N    R6,?_0
   \   00000012   0x1E68             SUBS     R0,R5,#+1
   \   00000014   0x42B8             CMP      R0,R7
   \   00000016   0xD203             BCS      ??D_Nv_Read_Impl_0
     87          
     88            N_ERRH_ASSERT_FATAL(address <= D_NV_MEMORY_END);
   \   00000018   0x2158             MOVS     R1,#+88
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       N_ErrH_Fatal
   \                     ??D_Nv_Read_Impl_0: (+1)
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x8900             LDRH     R0,[R0, #+8]
   \   00000024   0x1838             ADDS     R0,R7,R0
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD203             BCS      ??D_Nv_Read_Impl_1
     89            N_ERRH_ASSERT_FATAL((address + numberOfBytes) <= (D_NV_MEMORY_END + 1U));
   \   0000002A   0x2159             MOVS     R1,#+89
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       N_ErrH_Fatal
     90            N_ERRH_ASSERT_FATAL((offset + numberOfBytes) <= D_NV_SECTOR_SIZE);
   \                     ??D_Nv_Read_Impl_1: (+1)
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x8900             LDRH     R0,[R0, #+8]
   \   00000036   0x1820             ADDS     R0,R4,R0
   \   00000038   0x....             LDR      R1,??DataTable5_3  ;; 0x2001
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD303             BCC      ??D_Nv_Read_Impl_2
   \   0000003E   0x215A             MOVS     R1,#+90
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       N_ErrH_Fatal
     91          
     92            memcpy_P(pBuffer, (uint8_t FLASH_PTR *)address, numberOfBytes);
   \                     ??D_Nv_Read_Impl_2: (+1)
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x8902             LDRH     R2,[R0, #+8]
   \   0000004A   0x0039             MOVS     R1,R7
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy
     93          }
   \   00000052   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
     94          
     95          /** Write bytes to the internal NV.
     96              \param sector The sector to use (0..D_NV_SECTOR_COUNT)
     97              \param offset The offset to start writing to
     98              \param[in] pBuffer The start address of the buffer that contains the data to write
     99              \param numberOfBytes The number of bytes to write
    100              \note offset+numberOfBytes must be <= D_NV_SECTOR_SIZE (meaning sector crossing is not permitted)
    101              \note pBuffer cannot be const because it is passed to HAL_FillFlashPageBuffer()
    102          */

   \                                 In section .text, align 4, keep-with-next
    103          void D_Nv_Write(uint8_t sector, uint16_t offset, uint8_t *pBuffer, D_Nv_Size_t numberOfBytes)
    104          {
   \                     D_Nv_Write_Impl: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
    105            uint32_t address = D_NV_MEMORY_START + (uint32_t)(sector - D_NV_FIRST_SECTOR) * D_NV_SECTOR_SIZE + offset;
   \   00000004   0x....             LDR      R1,??DataTable5
   \   00000006   0x0340             LSLS     R0,R0,#+13
   \   00000008   0x1808             ADDS     R0,R1,R0
   \   0000000A   0x1907             ADDS     R7,R0,R4
    106            uint16_t pageOffset;
    107            D_Nv_Size_t numberOfPageBytes;
    108          
    109            N_ERRH_ASSERT_FATAL(numberOfBytes);
   \   0000000C   0x....             ADR.N    R6,?_0
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD103             BNE      ??D_Nv_Write_Impl_0
   \   00000012   0x216D             MOVS     R1,#+109
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       N_ErrH_Fatal
   \                     ??D_Nv_Write_Impl_0: (+1)
   \   0000001A   0x....             LDR      R5,??DataTable5_2
   \   0000001C   0x1E68             SUBS     R0,R5,#+1
   \   0000001E   0x42B8             CMP      R0,R7
   \   00000020   0xD203             BCS      ??D_Nv_Write_Impl_1
    110            N_ERRH_ASSERT_FATAL(address <= D_NV_MEMORY_END);
   \   00000022   0x216E             MOVS     R1,#+110
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       N_ErrH_Fatal
    111            N_ERRH_ASSERT_FATAL((address + numberOfBytes) <= (D_NV_MEMORY_END + 1U));
   \                     ??D_Nv_Write_Impl_1: (+1)
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x8900             LDRH     R0,[R0, #+8]
   \   0000002E   0x1838             ADDS     R0,R7,R0
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD203             BCS      ??D_Nv_Write_Impl_2
   \   00000034   0x216F             MOVS     R1,#+111
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       N_ErrH_Fatal
    112            N_ERRH_ASSERT_FATAL((offset + numberOfBytes) <= D_NV_SECTOR_SIZE);
   \                     ??D_Nv_Write_Impl_2: (+1)
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x8905             LDRH     R5,[R0, #+8]
   \   00000040   0x1960             ADDS     R0,R4,R5
   \   00000042   0x....             LDR      R1,??DataTable5_3  ;; 0x2001
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD303             BCC      ??D_Nv_Write_Impl_3
   \   00000048   0x2170             MOVS     R1,#+112
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0x.... 0x....      BL       N_ErrH_Fatal
    113          
    114            pageOffset = address % D_NV_PAGE_SIZE;
   \                     ??D_Nv_Write_Impl_3: (+1)
   \   00000050   0xB2F8             UXTB     R0,R7
   \   00000052   0x2180             MOVS     R1,#+128
   \   00000054   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000056   0x1A09             SUBS     R1,R1,R0
   \   00000058   0x42A9             CMP      R1,R5
   \   0000005A   0xDA03             BGE      ??D_Nv_Write_Impl_4
   \   0000005C   0x2180             MOVS     R1,#+128
   \   0000005E   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000060   0x1A0C             SUBS     R4,R1,R0
   \   00000062   0xE001             B        ??D_Nv_Write_Impl_5
   \                     ??D_Nv_Write_Impl_4: (+1)
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x890C             LDRH     R4,[R1, #+8]
    115            numberOfPageBytes = MIN((D_NV_PAGE_SIZE - pageOffset), numberOfBytes);
    116          
    117            HAL_FillFlashPageBuffer(pageOffset, numberOfPageBytes, pBuffer);
   \                     ??D_Nv_Write_Impl_5: (+1)
   \   00000068   0x9A01             LDR      R2,[SP, #+4]
   \   0000006A   0xB2A1             UXTH     R1,R4
   \   0000006C   0x.... 0x....      BL       HAL_FillFlashPageBuffer
    118            HAL_WriteFlashPage(address);
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       HAL_WriteFlashPage
    119          
    120            numberOfBytes -= numberOfPageBytes;
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x8900             LDRH     R0,[R0, #+8]
   \   0000007A   0x1B06             SUBS     R6,R0,R4
    121            address += numberOfPageBytes;
   \   0000007C   0xB2A4             UXTH     R4,R4
   \   0000007E   0x193F             ADDS     R7,R7,R4
    122            pBuffer += numberOfPageBytes;
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x1905             ADDS     R5,R0,R4
   \   00000084   0xE00B             B        ??D_Nv_Write_Impl_6
    123          
    124            while (0U < numberOfBytes)
    125            {
    126              numberOfPageBytes = MIN(D_NV_PAGE_SIZE, numberOfBytes);
   \                     ??D_Nv_Write_Impl_7: (+1)
   \   00000086   0x0034             MOVS     R4,R6
    127          
    128              HAL_FillFlashPageBuffer(0U, numberOfPageBytes, pBuffer);
   \                     ??D_Nv_Write_Impl_8: (+1)
   \   00000088   0x002A             MOVS     R2,R5
   \   0000008A   0x0021             MOVS     R1,R4
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      BL       HAL_FillFlashPageBuffer
    129              HAL_WriteFlashPage(address);
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       HAL_WriteFlashPage
    130          
    131              numberOfBytes -= numberOfPageBytes;
   \   00000098   0x1B36             SUBS     R6,R6,R4
    132              address += numberOfPageBytes;
   \   0000009A   0x193F             ADDS     R7,R7,R4
    133              pBuffer += numberOfPageBytes;
   \   0000009C   0x192D             ADDS     R5,R5,R4
   \                     ??D_Nv_Write_Impl_6: (+1)
   \   0000009E   0xB2B6             UXTH     R6,R6
   \   000000A0   0x2E00             CMP      R6,#+0
   \   000000A2   0xD005             BEQ      ??D_Nv_Write_Impl_9
   \   000000A4   0x20FF             MOVS     R0,#+255
   \   000000A6   0x1C80             ADDS     R0,R0,#+2        ;; #+257
   \   000000A8   0x4286             CMP      R6,R0
   \   000000AA   0xDBEC             BLT      ??D_Nv_Write_Impl_7
   \   000000AC   0x1E44             SUBS     R4,R0,#+1
   \   000000AE   0xE7EB             B        ??D_Nv_Write_Impl_8
    134            }
    135          }
   \                     ??D_Nv_Write_Impl_9: (+1)
   \   000000B0   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    136          
    137          /** Erases a sector of the internal NV.
    138             \param sector The sector to erase (0..D_NV_SECTOR_COUNT)
    139          */

   \                                 In section .text, align 4, keep-with-next
    140          void D_Nv_EraseSector(uint8_t sector)
    141          {
   \                     D_Nv_EraseSector_Impl: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    142            uint32_t address = D_NV_MEMORY_START + (uint32_t)(sector - D_NV_FIRST_SECTOR) * D_NV_SECTOR_SIZE;
   \   00000002   0x....             LDR      R1,??DataTable5
   \   00000004   0x0340             LSLS     R0,R0,#+13
   \   00000006   0x180C             ADDS     R4,R1,R0
    143          
    144            N_ERRH_ASSERT_FATAL(address <= D_NV_MEMORY_END);
   \   00000008   0x....             LDR      R0,??DataTable5_1
   \   0000000A   0x42A0             CMP      R0,R4
   \   0000000C   0xD203             BCS      ??D_Nv_EraseSector_Impl_0
   \   0000000E   0x2190             MOVS     R1,#+144
   \   00000010   0x....             ADR.N    R0,?_0
   \   00000012   0x.... 0x....      BL       N_ErrH_Fatal
    145          
    146            for (uint8_t i = 0U; i < (D_NV_SECTOR_SIZE / D_NV_PAGE_SIZE); i++)
   \                     ??D_Nv_EraseSector_Impl_0: (+1)
   \   00000016   0x2520             MOVS     R5,#+32
    147            {
    148              HAL_EraseFlashPage(address);
   \                     ??D_Nv_EraseSector_Impl_1: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_EraseFlashPage
    149              address += D_NV_PAGE_SIZE;
   \   0000001E   0x2080             MOVS     R0,#+128
   \   00000020   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   00000022   0x1824             ADDS     R4,R4,R0
    150            }
   \   00000024   0x1E6D             SUBS     R5,R5,#+1
   \   00000026   0xD1F7             BNE      ??D_Nv_EraseSector_Impl_1
    151          }
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    152          
    153          /** Compare bytes with contents of the internal NV.
    154              \param sector The sector to use (0..D_NV_SECTOR_COUNT)
    155              \param offset The offset to start comparing with
    156              \param[in] pBuffer If NULL then read buffer will be compared with 0xFF
    157               Otherwise it is the start address of the buffer that contains the data to compare with
    158              \param numberOfBytes The number of bytes to compare
    159              \note offset+numberOfBytes must be <= D_NV_SECTOR_SIZE (meaning sector crossing is not permitted)
    160          */

   \                                 In section .text, align 4, keep-with-next
    161          static bool CompareData(uint8_t sector, uint16_t offset, uint8_t *pBuffer, D_Nv_Size_t numberOfBytes)
    162          {
   \                     CompareData: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x001D             MOVS     R5,R3
    163            uint32_t address = D_NV_MEMORY_START + (uint32_t)(sector - D_NV_FIRST_SECTOR) * D_NV_SECTOR_SIZE + offset;
   \   00000008   0x....             LDR      R1,??DataTable5
   \   0000000A   0x0340             LSLS     R0,R0,#+13
   \   0000000C   0x1808             ADDS     R0,R1,R0
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x8A09             LDRH     R1,[R1, #+16]
   \   00000012   0x1846             ADDS     R6,R0,R1
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD104             BNE      ??CompareData_0
    164            uint8_t  buffer[16U];
    165          
    166            N_ERRH_ASSERT_FATAL(numberOfBytes);
   \   00000018   0x21A6             MOVS     R1,#+166
   \   0000001A   0xBF00             Nop      
   \   0000001C   0x....             ADR.N    R0,?_0
   \   0000001E   0x.... 0x....      BL       N_ErrH_Fatal
   \                     ??CompareData_0: (+1)
   \   00000022   0x....             LDR      R7,??DataTable5_2
   \   00000024   0x1E78             SUBS     R0,R7,#+1
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD203             BCS      ??CompareData_1
    167            N_ERRH_ASSERT_FATAL(address <= D_NV_MEMORY_END);
   \   0000002A   0x21A7             MOVS     R1,#+167
   \   0000002C   0x....             ADR.N    R0,?_0
   \   0000002E   0x.... 0x....      BL       N_ErrH_Fatal
    168            N_ERRH_ASSERT_FATAL((address + numberOfBytes) <= (D_NV_MEMORY_END + 1U));
   \                     ??CompareData_1: (+1)
   \   00000032   0x1970             ADDS     R0,R6,R5
   \   00000034   0x4287             CMP      R7,R0
   \   00000036   0xD204             BCS      ??CompareData_2
   \   00000038   0x21A8             MOVS     R1,#+168
   \   0000003A   0xBF00             Nop      
   \   0000003C   0x....             ADR.N    R0,?_0
   \   0000003E   0x.... 0x....      BL       N_ErrH_Fatal
    169            N_ERRH_ASSERT_FATAL((offset + numberOfBytes) <= D_NV_SECTOR_SIZE);
   \                     ??CompareData_2: (+1)
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x8A00             LDRH     R0,[R0, #+16]
   \   00000046   0x1940             ADDS     R0,R0,R5
   \   00000048   0x....             LDR      R1,??DataTable5_3  ;; 0x2001
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD306             BCC      ??CompareData_3
   \   0000004E   0x21A9             MOVS     R1,#+169
   \   00000050   0x....             ADR.N    R0,?_0
   \   00000052   0x.... 0x....      BL       N_ErrH_Fatal
   \   00000056   0xE001             B        ??CompareData_3
    170          
    171            while(numberOfBytes)
    172            {
    173              uint16_t bytesToRead = MIN(sizeof(buffer), numberOfBytes);
    174          
    175              memcpy_P(buffer, (uint8_t FLASH_PTR *)address, bytesToRead);
    176              for (uint8_t i = 0U; i < bytesToRead; i++)
    177                if (buffer[i] != ((pBuffer != NULL) ? *(pBuffer++) : 0xFF))
    178                  return false;
    179          
    180              numberOfBytes -= bytesToRead;
   \                     ??CompareData_4: (+1)
   \   00000058   0x1BED             SUBS     R5,R5,R7
    181              address += bytesToRead;
   \   0000005A   0x19F6             ADDS     R6,R6,R7
   \                     ??CompareData_3: (+1)
   \   0000005C   0xB2AD             UXTH     R5,R5
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD01A             BEQ      ??CompareData_5
   \   00000062   0x002F             MOVS     R7,R5
   \   00000064   0x2F11             CMP      R7,#+17
   \   00000066   0xD300             BCC      ??CompareData_6
   \   00000068   0x2710             MOVS     R7,#+16
   \                     ??CompareData_6: (+1)
   \   0000006A   0x003A             MOVS     R2,R7
   \   0000006C   0x0031             MOVS     R1,R6
   \   0000006E   0x4668             MOV      R0,SP
   \   00000070   0x.... 0x....      BL       __aeabi_memcpy
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x466B             MOV      R3,SP
   \   00000078   0xE000             B        ??CompareData_7
   \                     ??CompareData_8: (+1)
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \                     ??CompareData_7: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0
   \   0000007E   0x42B8             CMP      R0,R7
   \   00000080   0xDAEA             BGE      ??CompareData_4
   \   00000082   0x2C00             CMP      R4,#+0
   \   00000084   0xD002             BEQ      ??CompareData_9
   \   00000086   0x7821             LDRB     R1,[R4, #+0]
   \   00000088   0x1C64             ADDS     R4,R4,#+1
   \   0000008A   0xE000             B        ??CompareData_10
   \                     ??CompareData_9: (+1)
   \   0000008C   0x21FF             MOVS     R1,#+255
   \                     ??CompareData_10: (+1)
   \   0000008E   0x5C1A             LDRB     R2,[R3, R0]
   \   00000090   0x428A             CMP      R2,R1
   \   00000092   0xD0F2             BEQ      ??CompareData_8
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE000             B        ??CompareData_11
    182            }
    183          
    184            return true;
   \                     ??CompareData_5: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \                     ??CompareData_11: (+1)
   \   0000009A   0xB005             ADD      SP,SP,#+20
   \   0000009C   0xBDF0             POP      {R4-R7,PC}       ;; return
    185          }
    186          
    187          /** Checks if the requested range is empty (containing all 0xFF).
    188              \param sector The sector to use (0..D_NV_SECTOR_COUNT)
    189              \param offset The start offset to check
    190              \param numberOfBytes The number of bytes to check
    191              \returns TRUE if the range is empty, FALSE otherwise.
    192              \note Sector crossing is not permitted
    193          */

   \                                 In section .text, align 2, keep-with-next
    194          bool D_Nv_IsEmpty(uint8_t sector, uint16_t offset, D_Nv_Size_t numberOfBytes)
    195          {
   \                     D_Nv_IsEmpty_Impl: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196            return CompareData(sector, offset, NULL, numberOfBytes);
   \   00000002   0x0013             MOVS     R3,R2
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      BL       CompareData
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    197          }
    198          
    199          /** Compare bytes with contents of the internal NV.
    200              \param sector The sector to use (0..D_NV_SECTOR_COUNT)
    201              \param offset The offset to start comparing with
    202              \param[in] pBuffer The start address of the buffer that contains the data to compare with
    203              \param numberOfBytes The number of bytes to compare
    204              \note offset+numberOfBytes must be <= D_NV_SECTOR_SIZE (meaning sector crossing is not permitted)
    205          */

   \                                 In section .text, align 2, keep-with-next
    206          bool D_Nv_IsEqual(uint8_t sector, uint16_t offset, uint8_t *pBuffer, D_Nv_Size_t numberOfBytes)
    207          {
   \                     D_Nv_IsEqual_Impl: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    208            return CompareData(sector, offset, pBuffer, numberOfBytes);
   \   00000002   0x.... 0x....      BL       CompareData
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    209          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     SFB(D_NV_MEMORY)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     SFE(D_NV_MEMORY)+0xFFFFFFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     SFE(D_NV_MEMORY)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x00002001         DC32     0x2001

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x5F          DC8 "D_Nv"
   \              0x4E 0x76    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    210          #endif // _ENABLE_PERSISTENT_SERVER_
    211          #endif // #if PDS_ENABLE_WEAR_LEVELING == 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   CompareData
        40   -> N_ErrH_Fatal
        40   -> __aeabi_memcpy
      16   D_Nv_EraseSector_Impl
        16   -> HAL_EraseFlashPage
        16   -> N_ErrH_Fatal
      16   D_Nv_Init
        16   -> N_ErrH_Fatal
       8   D_Nv_IsEmpty_Impl
         8   -> CompareData
       8   D_Nv_IsEqual_Impl
         8   -> CompareData
      32   D_Nv_Read_Impl
        32   -> N_ErrH_Fatal
        32   -> __aeabi_memcpy
      32   D_Nv_Write_Impl
        32   -> HAL_FillFlashPageBuffer
        32   -> HAL_WriteFlashPage
        32   -> N_ErrH_Fatal


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       8  ?_0
     158  CompareData
      42  D_Nv_EraseSector_Impl
      44  D_Nv_Init
      12  D_Nv_IsEmpty_Impl
       8  D_Nv_IsEqual_Impl
      84  D_Nv_Read_Impl
     178  D_Nv_Write_Impl

 
 550 bytes in section .text
 
 550 bytes of CODE memory

Errors: none
Warnings: none
