###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:41:16
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclAttributes.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclAttributes.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\zclAttributes.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\zclAttributes.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclAttributes.c
      1          /************************************************************************//**
      2            \file zclAttributes.c
      3          
      4            \brief
      5              Implementation of state-independent attributes logic for ZCL.
      6          
      7            \author
      8              Atmel Corporation: http://www.atmel.com \n
      9              Support email: avr@atmel.com
     10          
     11            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     12            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     13          
     14            \internal
     15              History:
     16              16.03.2012 - D.Loskutnikov - extracted from zcl.c
     17          ******************************************************************************/
     18          #if ZCL_SUPPORT == 1
     19          /******************************************************************************
     20                             Includes section
     21          ******************************************************************************/
     22          #include <zcl.h>
     23          #include <zclInt.h>
     24          #include <sysUtils.h>
     25          #include <zclParser.h>
     26          #include <zclAttributes.h>
     27          #include <zclDbg.h>
     28          #include <sysAssert.h>
     29          
     30          /******************************************************************************
     31                             Static function prototypes section
     32          ******************************************************************************/
     33          static ZCL_Status_t zclWriteAttribute(Endpoint_t endpointId, ClusterId_t clusterId, uint8_t clusterSide, ZCL_AttributeId_t attrId,
     34                                                uint8_t attrType, uint8_t *attrValue, bool isRemoteWrite, bool onlyCheck);
     35          static ZclStructureElement_t *zclObtainStructureElement(const ZclStructure_t *st, uint16_t idx);
     36          #if APP_CLUSTERS_IN_FLASH == 1
     37          static ZCL_Cluster_t * zclUpdateClusterImage(ZCL_ClusterPartFlash_t *flashPart, ZCL_ClusterPartRam_t *ramPart);
     38          #endif // APP_CLUSTERS_IN_FLASH == 1
     39          
     40          static uint64_t readUnsignedLE(const uint8_t *value, uint8_t length);
     41          static int64_t readSignedLE(const uint8_t *value, uint8_t length);
     42          static bool zclIsAttributeTypeUnsigned(uint8_t typeId);
     43          
     44          ZclCommand_t * zclGetNextCommand(ZclCommand_t *command);
     45          static bool isOnChangeReportingNeeded(const ZclAttribute_t *pAttr);
     46          static void zclReportOnChangeIfNeeded(ZclAttribute_t *attr, ZCL_DataTypeDescriptor_t *desc);
     47          
     48          /******************************************************************************
     49                             Implementation section
     50          ******************************************************************************/
     51          #if APP_CLUSTERS_IN_FLASH == 1
     52          static zclClusterImage_t clusterImage;
     53          #endif // APP_CLUSTERS_IN_FLASH == 1
     54          /*************************************************************************//**
     55            \brief  ZCL Data Type Unsigness get by Type Id function.
     56            \param  Id - ZCL Data Type Id (unsigned 8-bit integer)
     57            \return true if ZCL Data Type is unsigned, otherwise - false.
     58          *****************************************************************************/
     59          static bool zclIsAttributeTypeUnsigned(uint8_t typeId)
     60          {
     61            switch (typeId)
     62            {
     63              //General data
     64              case ZCL_S8BIT_DATA_TYPE_ID:
     65              case ZCL_S16BIT_DATA_TYPE_ID:
     66              case ZCL_S24BIT_DATA_TYPE_ID:
     67              case ZCL_S32BIT_DATA_TYPE_ID:
     68              case ZCL_S40BIT_DATA_TYPE_ID:
     69              case ZCL_S48BIT_DATA_TYPE_ID:
     70              case ZCL_S56BIT_DATA_TYPE_ID:
     71              case ZCL_S64BIT_DATA_TYPE_ID:
     72                return false;
     73              default:
     74                return true;
     75            }
     76          }
     77          
     78          /*************************************************************************//**
     79            \brief Schedules attribute reporting on change if it is needed.
     80          
     81            \param[in] attr - pointer to attribute;
     82            \param[in] desc - pointer to attribute data descriptor
     83          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     84          static void zclReportOnChangeIfNeeded(ZclAttribute_t *attr, ZCL_DataTypeDescriptor_t *desc)
     85          {
   \                     zclReportOnChangeIfNeeded: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     86            (void)desc;
     87            if ((attr->properties & ZCL_REPORTABLE_ATTRIBUTE) && isReportingPermitted(attr) && isOnChangeReportingNeeded(attr))
   \   00000004   0x78E0             LDRB     R0,[R4, #+3]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD511             BPL      ??zclReportOnChangeIfNeeded_0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       isReportingPermitted
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00C             BEQ      ??zclReportOnChangeIfNeeded_0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       isOnChangeReportingNeeded
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD007             BEQ      ??zclReportOnChangeIfNeeded_0
     88            {
     89              if (attr->properties & ZCL_ON_CHANGE_REPORT)
   \   0000001E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD103             BNE      ??zclReportOnChangeIfNeeded_0
     90                return;
     91          
     92              attr->properties |= ZCL_ON_CHANGE_REPORT;
   \   00000026   0x4301             ORRS     R1,R1,R0
   \   00000028   0x70E1             STRB     R1,[R4, #+3]
     93              zclStartReportTimer();
   \   0000002A   0x.... 0x....      BL       zclStartReportTimer
     94            }
     95          }
   \                     ??zclReportOnChangeIfNeeded_0: (+1)
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
     96          
     97          /*************************************************************************//**
     98            \brief Finds attribute in ZCL and rewrites its value by the new one.
     99            Triggers attribute reporting on change.
    100          
    101            \param[in] endpointId - endpoint on which cluster is registered.
    102            \param[in] clusterId - cluster unique identifier.
    103            \param[in] clusterSide - determs the cluster's side (client or server).
    104            \param[in] attrId - attribute unique identifier.
    105            \param[in] attrType - type of the attribute to be set.
    106            \param[in] attrValue - pointer to attribute value to be set.
    107            \param[in] isRemoteWrite - flag to ignore attempt of remote write
    108                                       to read-only attribute
    109            \param[in] onlyCheck - not to write, but only check attribute existance.
    110          
    111            \return status of operation.
    112          *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    113          static ZCL_Status_t zclWriteAttribute(Endpoint_t endpointId,
    114                                                ClusterId_t clusterId,
    115                                                uint8_t clusterSide,
    116                                                ZCL_AttributeId_t attrId,
    117                                                uint8_t attrType,
    118                                                uint8_t *attrValue,
    119                                                bool isRemoteWrite,
    120                                                bool onlyCheck)
    121          {
   \                     zclWriteAttribute: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0017             MOVS     R7,R2
    122            ZclAttribute_t *zclAttr;
    123            ZCLActionWriteAttrReq_t  zclWriteAttrReqInfo = 
    124            {
    125              .clusterId = clusterId,
    126              .clusterSide = clusterSide,
    127              .attrId = attrId,
    128              .attrType = attrType,
    129              .attrValue = attrValue
    130            };
   \   00000006   0xA806             ADD      R0,SP,#+24
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x8E09             LDRH     R1,[R1, #+48]
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0x7087             STRB     R7,[R0, #+2]
   \   00000010   0x8083             STRH     R3,[R0, #+4]
   \   00000012   0x9C12             LDR      R4,[SP, #+72]
   \   00000014   0x7184             STRB     R4,[R0, #+6]
   \   00000016   0x9813             LDR      R0,[SP, #+76]
   \   00000018   0x9008             STR      R0,[SP, #+32]
    131            BcZCLActionReq_t zclActionReq =
    132            {
    133              .action = ZCL_ACTION_WRITE_ATTR_REQUEST,
    134              .context = &zclWriteAttrReqInfo,
    135              .denied = 1U
    136            };
   \   0000001A   0xA801             ADD      R0,SP,#+4
   \   0000001C   0x....             ADR.N    R1,?_0
   \   0000001E   0xC964             LDM      R1!,{R2,R5,R6}
   \   00000020   0xC064             STM      R0!,{R2,R5,R6}
   \   00000022   0xA806             ADD      R0,SP,#+24
   \   00000024   0x9002             STR      R0,[SP, #+8]
    137          
    138            if (!attrValue)
   \   00000026   0x9813             LDR      R0,[SP, #+76]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD101             BNE      ??zclWriteAttribute_0
    139              return ZCL_INVALID_PARAMETER_STATUS;
   \   0000002C   0x20FF             MOVS     R0,#+255
   \   0000002E   0xE0A6             B        ??zclWriteAttribute_1
    140          
    141            zclAttr = zclGetAttribute(endpointId, clusterId, clusterSide, attrId);
   \                     ??zclWriteAttribute_0: (+1)
   \   00000030   0x003A             MOVS     R2,R7
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x8E01             LDRH     R1,[R0, #+48]
   \   00000036   0xA80B             ADD      R0,SP,#+44
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       zclGetAttribute
   \   0000003E   0x0006             MOVS     R6,R0
    142          
    143            if (!zclAttr)
   \   00000040   0xD101             BNE      ??zclWriteAttribute_2
    144              return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
   \   00000042   0x2086             MOVS     R0,#+134
   \   00000044   0xE09B             B        ??zclWriteAttribute_1
    145          
    146            if (zclAttr->type != attrType)
   \                     ??zclWriteAttribute_2: (+1)
   \   00000046   0x78B0             LDRB     R0,[R6, #+2]
   \   00000048   0x42A0             CMP      R0,R4
   \   0000004A   0xD001             BEQ      ??zclWriteAttribute_3
    147              return ZCL_INVALID_DATA_TYPE_STATUS;
   \   0000004C   0x208D             MOVS     R0,#+141
   \   0000004E   0xE096             B        ??zclWriteAttribute_1
    148          
    149            if (isRemoteWrite)
   \                     ??zclWriteAttribute_3: (+1)
   \   00000050   0x9914             LDR      R1,[SP, #+80]
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD002             BEQ      ??zclWriteAttribute_4
    150            {
    151              if (zclAttr->properties & ZCL_READONLY_ATTRIBUTE)
   \   00000056   0x78F1             LDRB     R1,[R6, #+3]
   \   00000058   0x0789             LSLS     R1,R1,#+30
   \   0000005A   0xD421             BMI      ??zclWriteAttribute_5
    152                return ZCL_READ_ONLY_STATUS;
    153            }
    154          
    155            if (!onlyCheck)
   \                     ??zclWriteAttribute_4: (+1)
   \   0000005C   0x9915             LDR      R1,[SP, #+84]
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD000             BEQ      .+4
   \   00000062   0xE08B             B        ??zclWriteAttribute_6
    156            {
    157              ZCL_DataTypeDescriptor_t desc;
    158              ZCL_GetDataTypeDescriptor(zclAttr->type, zclAttr->value, &desc);
   \   00000064   0x466A             MOV      R2,SP
   \   00000066   0x1D31             ADDS     R1,R6,#+4
   \   00000068   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x7880             LDRB     R0,[R0, #+2]
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0xD117             BNE      ??zclWriteAttribute_7
    159          
    160              if (ZCL_DATA_TYPE_STRUCTURED_KIND == desc.kind)
    161              {
    162                // Structured data. A few more checks
    163                const ZclArraySetBag_t *src = (const ZclArraySetBag_t*)attrValue;
    164                ZclArraySetBag_t *dst = (ZclArraySetBag_t*)zclAttr->value;
   \   00000074   0x1D30             ADDS     R0,R6,#+4
    165          
    166                // TODO: Support structure write. Structures are read-only until then.
    167                if (ZCL_STRUCTURE_DATA_TYPE_ID == zclAttr->type)
   \   00000076   0x78B1             LDRB     R1,[R6, #+2]
   \   00000078   0x294C             CMP      R1,#+76
   \   0000007A   0xD011             BEQ      ??zclWriteAttribute_5
    168                  return ZCL_READ_ONLY_STATUS;
    169          
    170                // Collection type may not be changed
    171                if (src->type != dst->type)
   \   0000007C   0x9913             LDR      R1,[SP, #+76]
   \   0000007E   0x7809             LDRB     R1,[R1, #+0]
   \   00000080   0x7802             LDRB     R2,[R0, #+0]
   \   00000082   0x4291             CMP      R1,R2
   \   00000084   0xD10C             BNE      ??zclWriteAttribute_5
    172                  return ZCL_READ_ONLY_STATUS;
    173          
    174                // We disallow collection resize
    175                if (src->cnt != dst->cnt)
   \   00000086   0x9A13             LDR      R2,[SP, #+76]
   \   00000088   0x7851             LDRB     R1,[R2, #+1]
   \   0000008A   0x7893             LDRB     R3,[R2, #+2]
   \   0000008C   0x061B             LSLS     R3,R3,#+24
   \   0000008E   0x0C1B             LSRS     R3,R3,#+16
   \   00000090   0x4319             ORRS     R1,R1,R3
   \   00000092   0x7842             LDRB     R2,[R0, #+1]
   \   00000094   0x7883             LDRB     R3,[R0, #+2]
   \   00000096   0x061B             LSLS     R3,R3,#+24
   \   00000098   0x0C1B             LSRS     R3,R3,#+16
   \   0000009A   0x431A             ORRS     R2,R2,R3
   \   0000009C   0x4291             CMP      R1,R2
   \   0000009E   0xD001             BEQ      ??zclWriteAttribute_7
    176                  return ZCL_READ_ONLY_STATUS;
   \                     ??zclWriteAttribute_5: (+1)
   \   000000A0   0x2088             MOVS     R0,#+136
   \   000000A2   0xE06C             B        ??zclWriteAttribute_1
    177              }
    178              if (zclAttr->properties & ZCL_BOUNDARY_CHECK)
   \                     ??zclWriteAttribute_7: (+1)
   \   000000A4   0x78F0             LDRB     R0,[R6, #+3]
   \   000000A6   0x06C1             LSLS     R1,R0,#+27
   \   000000A8   0xD555             BPL      ??zclWriteAttribute_8
    179              {
    180                uint8_t *minValRef = NULL;
    181                uint8_t *maxValRef = NULL;
    182                // finding out min & max value position
    183                uint8_t *minValPos = ((uint8_t *)zclAttr) + SLICE_SIZE(ZclAttribute_t, id, properties) + desc.length;
   \   000000AA   0x4669             MOV      R1,SP
   \   000000AC   0x8809             LDRH     R1,[R1, #+0]
   \   000000AE   0x1874             ADDS     R4,R6,R1
   \   000000B0   0x1D24             ADDS     R4,R4,#+4
    184                if (zclAttr->properties & ZCL_REPORTABLE_ATTRIBUTE)
   \   000000B2   0x07C2             LSLS     R2,R0,#+31
   \   000000B4   0xD502             BPL      ??zclWriteAttribute_9
    185                  // adding report parameters
    186                  minValPos = minValPos + sizeof(ZclReportableAttributeTail_t) + 2 * desc.length + sizeof(ZCL_ReportTime_t);
   \   000000B6   0x004A             LSLS     R2,R1,#+1
   \   000000B8   0x18A4             ADDS     R4,R4,R2
   \   000000BA   0x3408             ADDS     R4,R4,#+8
    187          
    188                if (zclAttr->properties & ZCL_CHECK_OTHER_ATTR)
   \                     ??zclWriteAttribute_9: (+1)
   \   000000BC   0x0680             LSLS     R0,R0,#+26
   \   000000BE   0xD51F             BPL      ??zclWriteAttribute_10
    189                {
    190                  // Read the attribute referred for boundry check
    191                  ZclAttribute_t *zclMinValAttr;
    192                  ZclAttribute_t *zclMaxValAttr;
    193                  ZCL_AttributeId_t minMaxAttrID;
    194                  minMaxAttrID = LE16_TO_CPU((ZCL_AttributeId_t)minValPos[0] | (minValPos[1] << 0x08));
    195                  zclMinValAttr = zclGetAttribute(endpointId, clusterId, clusterSide, minMaxAttrID);
   \   000000C0   0x7820             LDRB     R0,[R4, #+0]
   \   000000C2   0x7861             LDRB     R1,[R4, #+1]
   \   000000C4   0x020B             LSLS     R3,R1,#+8
   \   000000C6   0x4303             ORRS     R3,R3,R0
   \   000000C8   0x003A             MOVS     R2,R7
   \   000000CA   0x4668             MOV      R0,SP
   \   000000CC   0x8E01             LDRH     R1,[R0, #+48]
   \   000000CE   0xA80B             ADD      R0,SP,#+44
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x.... 0x....      BL       zclGetAttribute
   \   000000D6   0x0005             MOVS     R5,R0
    196                  minValPos += sizeof(ZCL_AttributeId_t);
   \   000000D8   0x1CA4             ADDS     R4,R4,#+2
    197                  minMaxAttrID = LE16_TO_CPU((ZCL_AttributeId_t)minValPos[0] | (minValPos[1] << 0x08));
    198                  zclMaxValAttr = zclGetAttribute(endpointId, clusterId, clusterSide, minMaxAttrID);
   \   000000DA   0x7820             LDRB     R0,[R4, #+0]
   \   000000DC   0x7861             LDRB     R1,[R4, #+1]
   \   000000DE   0x020B             LSLS     R3,R1,#+8
   \   000000E0   0x4303             ORRS     R3,R3,R0
   \   000000E2   0x003A             MOVS     R2,R7
   \   000000E4   0x4668             MOV      R0,SP
   \   000000E6   0x8E01             LDRH     R1,[R0, #+48]
   \   000000E8   0xA80B             ADD      R0,SP,#+44
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x.... 0x....      BL       zclGetAttribute
   \   000000F0   0x0004             MOVS     R4,R0
    199                  if (zclMinValAttr && zclMaxValAttr)
   \   000000F2   0x2D00             CMP      R5,#+0
   \   000000F4   0xD02F             BEQ      ??zclWriteAttribute_8
   \   000000F6   0x2C00             CMP      R4,#+0
   \   000000F8   0xD02D             BEQ      ??zclWriteAttribute_8
    200                  {
    201                    minValRef = (uint8_t *)zclMinValAttr->value;
   \   000000FA   0x1D28             ADDS     R0,R5,#+4
    202                    maxValRef = (uint8_t *)zclMaxValAttr->value;
   \   000000FC   0x1D24             ADDS     R4,R4,#+4
   \   000000FE   0xE001             B        ??zclWriteAttribute_11
    203                  }
    204                }
    205                else
    206                {
    207                  minValRef = minValPos;
   \                     ??zclWriteAttribute_10: (+1)
   \   00000100   0x0020             MOVS     R0,R4
    208                  maxValRef = minValPos + desc.length;
   \   00000102   0x1864             ADDS     R4,R4,R1
    209                }
    210                if (minValRef && maxValRef)
   \                     ??zclWriteAttribute_11: (+1)
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD026             BEQ      ??zclWriteAttribute_8
   \   00000108   0x2C00             CMP      R4,#+0
   \   0000010A   0xD024             BEQ      ??zclWriteAttribute_8
    211                {
    212                  if (zclIsAttributeTypeUnsigned(zclAttr->type))
   \   0000010C   0x78B1             LDRB     R1,[R6, #+2]
   \   0000010E   0x3928             SUBS     R1,R1,#+40
   \   00000110   0x2907             CMP      R1,#+7
   \   00000112   0x4669             MOV      R1,SP
   \   00000114   0x8809             LDRH     R1,[R1, #+0]
   \   00000116   0xD834             BHI      ??zclWriteAttribute_12
    213                  {
    214                    uint64_t minVal = readUnsignedLE(minValRef, desc.length);
    215                    uint64_t maxVal = readUnsignedLE(maxValRef, desc.length);
    216                    uint64_t attrVal = readUnsignedLE(attrValue, desc.length);
    217          
    218                    if (!((attrVal >= minVal) && (attrVal <= maxVal)))
    219                    {
    220                      return ZCL_INVALID_VALUE_STATUS;
    221                    }
    222                  }
    223                  else
    224                  {
    225                    int64_t minVal = readSignedLE(minValRef, desc.length);
   \   00000118   0xB2C9             UXTB     R1,R1
   \   0000011A   0x.... 0x....      BL       readSignedLE
   \   0000011E   0xAA04             ADD      R2,SP,#+16
   \   00000120   0xC203             STM      R2!,{R0,R1}
    226                    int64_t maxVal = readSignedLE(maxValRef, desc.length);
   \   00000122   0x4668             MOV      R0,SP
   \   00000124   0x8801             LDRH     R1,[R0, #+0]
   \   00000126   0xB2C9             UXTB     R1,R1
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x.... 0x....      BL       readSignedLE
   \   0000012E   0x0004             MOVS     R4,R0
   \   00000130   0x000D             MOVS     R5,R1
    227                    int64_t attrVal = readSignedLE(attrValue, desc.length);
   \   00000132   0x4668             MOV      R0,SP
   \   00000134   0x8801             LDRH     R1,[R0, #+0]
   \   00000136   0xB2C9             UXTB     R1,R1
   \   00000138   0x9813             LDR      R0,[SP, #+76]
   \   0000013A   0x.... 0x....      BL       readSignedLE
    228          
    229                    if (!((attrVal >= minVal) && (attrVal <= maxVal)))
   \   0000013E   0xAA04             ADD      R2,SP,#+16
   \   00000140   0xCA0C             LDM      R2,{R2,R3}
   \   00000142   0x4299             CMP      R1,R3
   \   00000144   0xDB3E             BLT      ??zclWriteAttribute_13
   \   00000146   0xDC01             BGT      ??zclWriteAttribute_14
   \   00000148   0x4290             CMP      R0,R2
   \   0000014A   0xD33B             BCC      ??zclWriteAttribute_13
   \                     ??zclWriteAttribute_14: (+1)
   \   0000014C   0x428D             CMP      R5,R1
   \   0000014E   0xDB39             BLT      ??zclWriteAttribute_13
   \   00000150   0xDC01             BGT      ??zclWriteAttribute_8
   \   00000152   0x4284             CMP      R4,R0
   \   00000154   0xD336             BCC      ??zclWriteAttribute_13
    230                    {
    231                      return ZCL_INVALID_VALUE_STATUS;
    232                    }
    233                  }
    234                }
    235              }
    236              zclActionReq.denied = 0;
   \                     ??zclWriteAttribute_8: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x9003             STR      R0,[SP, #+12]
    237              SYS_PostEvent(BC_ZCL_EVENT_ACTION_REQUEST, (SYS_EventData_t)&zclActionReq);
   \   0000015A   0xA901             ADD      R1,SP,#+4
   \   0000015C   0x203A             MOVS     R0,#+58
   \   0000015E   0x.... 0x....      BL       SYS_PostEvent
    238              if(!zclActionReq.denied)
   \   00000162   0x9803             LDR      R0,[SP, #+12]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD12D             BNE      ??zclWriteAttribute_13
    239              {
    240                memcpy(zclAttr->value, attrValue, desc.length);
   \   00000168   0x4668             MOV      R0,SP
   \   0000016A   0x8802             LDRH     R2,[R0, #+0]
   \   0000016C   0x9913             LDR      R1,[SP, #+76]
   \   0000016E   0x1D30             ADDS     R0,R6,#+4
   \   00000170   0x.... 0x....      BL       __aeabi_memcpy
    241                zclReportOnChangeIfNeeded(zclAttr, &desc);
   \   00000174   0x4669             MOV      R1,SP
   \   00000176   0x0030             MOVS     R0,R6
   \   00000178   0x.... 0x....      BL       zclReportOnChangeIfNeeded
    242              }
    243              else
    244              {
    245                return ZCL_INVALID_VALUE_STATUS;
    246              }
    247            }
    248            return ZCL_SUCCESS_STATUS;
   \                     ??zclWriteAttribute_6: (+1)
   \   0000017C   0x2000             MOVS     R0,#+0
   \                     ??zclWriteAttribute_1: (+1)
   \   0000017E   0xB00D             ADD      SP,SP,#+52
   \   00000180   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??zclWriteAttribute_12: (+1)
   \   00000182   0xB2C9             UXTB     R1,R1
   \   00000184   0x.... 0x....      BL       readUnsignedLE
   \   00000188   0xAA04             ADD      R2,SP,#+16
   \   0000018A   0xC203             STM      R2!,{R0,R1}
   \   0000018C   0x4668             MOV      R0,SP
   \   0000018E   0x8801             LDRH     R1,[R0, #+0]
   \   00000190   0xB2C9             UXTB     R1,R1
   \   00000192   0x0020             MOVS     R0,R4
   \   00000194   0x.... 0x....      BL       readUnsignedLE
   \   00000198   0x0004             MOVS     R4,R0
   \   0000019A   0x000D             MOVS     R5,R1
   \   0000019C   0x4668             MOV      R0,SP
   \   0000019E   0x8801             LDRH     R1,[R0, #+0]
   \   000001A0   0xB2C9             UXTB     R1,R1
   \   000001A2   0x9813             LDR      R0,[SP, #+76]
   \   000001A4   0x.... 0x....      BL       readUnsignedLE
   \   000001A8   0x0002             MOVS     R2,R0
   \   000001AA   0x000B             MOVS     R3,R1
   \   000001AC   0xA804             ADD      R0,SP,#+16
   \   000001AE   0xC803             LDM      R0,{R0,R1}
   \   000001B0   0x428B             CMP      R3,R1
   \   000001B2   0xD307             BCC      ??zclWriteAttribute_13
   \   000001B4   0xD801             BHI      ??zclWriteAttribute_15
   \   000001B6   0x4282             CMP      R2,R0
   \   000001B8   0xD304             BCC      ??zclWriteAttribute_13
   \                     ??zclWriteAttribute_15: (+1)
   \   000001BA   0x429D             CMP      R5,R3
   \   000001BC   0xD8CB             BHI      ??zclWriteAttribute_8
   \   000001BE   0xD301             BCC      ??zclWriteAttribute_13
   \   000001C0   0x4294             CMP      R4,R2
   \   000001C2   0xD2C8             BCS      ??zclWriteAttribute_8
   \                     ??zclWriteAttribute_13: (+1)
   \   000001C4   0x2087             MOVS     R0,#+135
   \   000001C6   0xE7DA             B        ??zclWriteAttribute_1
    249          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x0001             DC16 1
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x00000000         DC32 0H, 1
   \              0x00000001   
    250          
    251          /**************************************************************************//**
    252          \brief Jumps to the next attribute
    253          
    254          \param[in] attr - current attribute
    255          \return next attribute
    256          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    257          ZclAttribute_t *jumpToNextAttribute(ZclAttribute_t *attr)
    258          {
   \                     jumpToNextAttribute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    259            uint8_t *p = (uint8_t*) attr;
    260            // Get length of current attribute
    261            uint8_t attributeLength = ZCL_GetAttributeLength(attr->type, attr->value);
   \   00000004   0x1D21             ADDS     R1,R4,#+4
   \   00000006   0x78A0             LDRB     R0,[R4, #+2]
   \   00000008   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000000C   0xB2C0             UXTB     R0,R0
    262          
    263            // Account for additional fields if current attribute is reportable
    264            if (attr->properties & ZCL_REPORTABLE_ATTRIBUTE)
   \   0000000E   0x78E1             LDRB     R1,[R4, #+3]
   \   00000010   0x07CA             LSLS     R2,R1,#+31
   \   00000012   0xD502             BPL      ??jumpToNextAttribute_0
    265            {
    266              p +=  sizeof(ZCL_ReportTime_t)  /* report counter */
    267                  + sizeof(ZCL_ReportTime_t)  /* min report interval */
    268                  + sizeof(ZCL_ReportTime_t)  /* max report interval */
    269                  + attributeLength +         /* reportable change */
    270                  + sizeof(ZCL_ReportTime_t)  /* timeout period */
    271                  + attributeLength;          /* last reported value */
   \   00000014   0x0042             LSLS     R2,R0,#+1
   \   00000016   0x18A4             ADDS     R4,R4,R2
   \   00000018   0x3408             ADDS     R4,R4,#+8
    272            }
    273            if (attr->properties & ZCL_BOUNDARY_CHECK)
   \                     ??jumpToNextAttribute_0: (+1)
   \   0000001A   0x06CA             LSLS     R2,R1,#+27
   \   0000001C   0xD505             BPL      ??jumpToNextAttribute_1
    274            {
    275              if (attr->properties & ZCL_CHECK_OTHER_ATTR)
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD501             BPL      ??jumpToNextAttribute_2
    276          	  p += (sizeof(ZCL_AttributeId_t) * 2);
   \   00000022   0x1D24             ADDS     R4,R4,#+4
   \   00000024   0xE001             B        ??jumpToNextAttribute_1
    277          	else
    278          	  p += (attributeLength * 2);
   \                     ??jumpToNextAttribute_2: (+1)
   \   00000026   0x0041             LSLS     R1,R0,#+1
   \   00000028   0x1864             ADDS     R4,R4,R1
    279            }
    280          
    281            // Actually jump to next attribute
    282            p += SLICE_SIZE(ZclAttribute_t, id, properties) + attributeLength;
    283          
    284            return (ZclAttribute_t *)p;
   \                     ??jumpToNextAttribute_1: (+1)
   \   0000002A   0x1820             ADDS     R0,R4,R0
   \   0000002C   0x1D00             ADDS     R0,R0,#+4
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    285          }
    286          
    287          /*************************************************************************//**
    288            \brief Reads unsigned LE value submitted as array to uint64_t.
    289          
    290            \param[in] value - pointer to array that contains value.
    291            \param[in] length - array length (max == 6).
    292          
    293            \return value of uint64_t type.
    294          *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    295          static uint64_t readUnsignedLE(const uint8_t *value, uint8_t length)
    296          {
   \                     readUnsignedLE: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    297            union {
    298              uint64_t value;
    299              uint8_t bytes[sizeof(uint64_t)];
    300            } arrToVal = { .value = 0};
   \   00000002   0xBF00             Nop      
   \   00000004   0x....             ADR.N    R2,?_1
   \   00000006   0xCA0C             LDM      R2,{R2,R3}
   \   00000008   0x466C             MOV      R4,SP
   \   0000000A   0xC40C             STM      R4!,{R2,R3}
    301          
    302            if (sizeof(uint64_t) < length) // Invalid length
   \   0000000C   0x2909             CMP      R1,#+9
   \   0000000E   0xD302             BCC      ??readUnsignedLE_0
    303              return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xBD1C             POP      {R2-R4,PC}
    304          
    305            memcpy(arrToVal.bytes, value, length);
   \                     ??readUnsignedLE_0: (+1)
   \   00000016   0x000A             MOVS     R2,R1
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    306          
    307            return LE64_TO_CPU(arrToVal.value);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0xC803             LDM      R0,{R0,R1}
   \   00000024   0xBD1C             POP      {R2-R4,PC}       ;; return
    308          }

   \                                 In section .text, align 8, keep-with-next
   \                     ?_1:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
    309          
    310          /*************************************************************************//**
    311            \brief Reads signed LE value submitted as array to int64_t.
    312          
    313            \param[in] value - pointer to array that contains value.
    314            \param[in] length - array length (max == 6).
    315          
    316            \return value of int64_t type.
    317          *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    318          static int64_t readSignedLE(const uint8_t *value, uint8_t length)
    319          {
   \                     readSignedLE: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    320            union {
    321              int64_t value;
    322              uint8_t bytes[sizeof(uint64_t)];
    323            } arrToVal = { .value = 0};
   \   00000004   0x....             ADR.N    R1,?_2
   \   00000006   0xC90C             LDM      R1!,{R2,R3}
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0xC10C             STM      R1!,{R2,R3}
    324          
    325            if (sizeof(uint64_t) < length) // Invalid length
   \   0000000C   0x2C09             CMP      R4,#+9
   \   0000000E   0xD302             BCC      ??readSignedLE_0
    326              return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xBD1C             POP      {R2-R4,PC}
    327          
    328            memcpy(arrToVal.bytes, value, length);
   \                     ??readSignedLE_0: (+1)
   \   00000016   0x0022             MOVS     R2,R4
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    329          
    330            // Detect sign
    331            if (((int8_t)*(arrToVal.bytes + length - 1)) < 0)
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x1900             ADDS     R0,R0,R4
   \   00000024   0x1E41             SUBS     R1,R0,#+1
   \   00000026   0x7809             LDRB     R1,[R1, #+0]
   \   00000028   0x0609             LSLS     R1,R1,#+24
   \   0000002A   0xD504             BPL      ??readSignedLE_1
    332            {
    333              memset(arrToVal.bytes + length, 0xFF, sizeof(uint64_t)-length);
   \   0000002C   0x22FF             MOVS     R2,#+255
   \   0000002E   0x2108             MOVS     R1,#+8
   \   00000030   0x1B09             SUBS     R1,R1,R4
   \   00000032   0x.... 0x....      BL       __aeabi_memset
    334            }
    335          
    336            return LE64_TO_CPU(arrToVal.value);
   \                     ??readSignedLE_1: (+1)
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0xC803             LDM      R0,{R0,R1}
   \   0000003A   0xBD1C             POP      {R2-R4,PC}       ;; return
    337          }

   \                                 In section .text, align 8, keep-with-next
   \                     ?_2:
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
    338          
    339          /*************************************************************************//**
    340            \brief Finds attribute in ZCL and returns attribute value.
    341          
    342            \param[in] endpointId - endpoint on which cluster is registered.
    343            \param[in] clusterId - cluster unique identifier.
    344            \param[in] clusterSide - determs the cluster's side (client or server).
    345            \param[in] attrId - attribute unique identifier.
    346            \param[out] attrType - pointer to attribute type determined and returned.
    347            \param[out] attrValue - read out attribute value pointer.
    348          
    349            Caller is responsible for providing big enough attrValue buffer.
    350          
    351            \return status of operation.
    352          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          ZCL_Status_t ZCL_ReadAttributeValue(Endpoint_t endpointId,
    354                                              ClusterId_t clusterId,
    355                                              uint8_t clusterSide,
    356                                              ZCL_AttributeId_t attrId,
    357                                              uint8_t *attrType,
    358                                              uint8_t *attrValue)
    359          {
   \                     ZCL_ReadAttributeValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    360            const ZclAttribute_t *zclAttr = zclGetAttribute(endpointId, clusterId, clusterSide, attrId);
   \   00000002   0x.... 0x....      BL       zclGetAttribute
   \   00000006   0x0004             MOVS     R4,R0
    361            // if attribute is found it should be copied to user memory using macros
    362            if (zclAttr && attrType && attrValue)
   \   00000008   0xD017             BEQ      ??ZCL_ReadAttributeValue_0
   \   0000000A   0x9804             LDR      R0,[SP, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD014             BEQ      ??ZCL_ReadAttributeValue_0
   \   00000010   0x9D05             LDR      R5,[SP, #+20]
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD011             BEQ      ??ZCL_ReadAttributeValue_0
    363            {
    364              *attrType = zclAttr->type;
   \   00000016   0x78A1             LDRB     R1,[R4, #+2]
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    365              SYS_BYTE_MEMCPY(attrValue, zclAttr->value, ZCL_GetAttributeLength(zclAttr->type, zclAttr->value));
   \   0000001A   0x1D21             ADDS     R1,R4,#+4
   \   0000001C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001E   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000022   0x1D24             ADDS     R4,R4,#+4
   \   00000024   0xE003             B        ??ZCL_ReadAttributeValue_1
   \                     ??ZCL_ReadAttributeValue_2: (+1)
   \   00000026   0x7821             LDRB     R1,[R4, #+0]
   \   00000028   0x7029             STRB     R1,[R5, #+0]
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ZCL_ReadAttributeValue_1: (+1)
   \   0000002E   0x0001             MOVS     R1,R0
   \   00000030   0x1E48             SUBS     R0,R1,#+1
   \   00000032   0x0409             LSLS     R1,R1,#+16
   \   00000034   0xD1F7             BNE      ??ZCL_ReadAttributeValue_2
    366              return ZCL_SUCCESS_STATUS;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
    367            }
    368            return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
   \                     ??ZCL_ReadAttributeValue_0: (+1)
   \   0000003A   0x2086             MOVS     R0,#+134
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    369          }
    370          
    371          /**************************************************************************//**
    372          \brief Safe version of ZCL_ReadAttributeValue without caller buffer overflow
    373          
    374          \param[in] endpointId - endpoint of attribute to be read
    375          \param[in] clusterId - cluster of attribute to be read
    376          \param[in] clusterSide - client or server side
    377          \param[in] attrId - attribute identifier
    378          \param[out] attrType - attribute type
    379          \param[out] attrValue - buffer to read attribute value
    380          \param[in] maxSize - maximum size of buffer
    381          \return status of operation
    382          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    383          ZCL_Status_t zclReadAttributeValueSafe(Endpoint_t endpointId,
    384                                                 ClusterId_t clusterId,
    385                                                 uint8_t clusterSide,
    386                                                 ZCL_AttributeId_t attrId,
    387                                                 uint8_t *attrType,
    388                                                 uint8_t *attrValue,
    389                                                 uint16_t maxSize)
    390          {
   \                     zclReadAttributeValueSafe: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x9E04             LDR      R6,[SP, #+16]
    391            const ZclAttribute_t *zclAttr;
    392            uint16_t len;
    393          
    394            if (!attrType || !attrValue)
   \   00000004   0x2E00             CMP      R6,#+0
   \   00000006   0xD006             BEQ      ??zclReadAttributeValueSafe_0
   \   00000008   0x9D05             LDR      R5,[SP, #+20]
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD003             BEQ      ??zclReadAttributeValueSafe_0
    395              return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
    396          
    397            zclAttr = zclGetAttribute(endpointId, clusterId, clusterSide, attrId);
   \   0000000E   0x.... 0x....      BL       zclGetAttribute
   \   00000012   0x0004             MOVS     R4,R0
    398          
    399            if (!zclAttr)
   \   00000014   0xD101             BNE      ??zclReadAttributeValueSafe_1
    400              return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
   \                     ??zclReadAttributeValueSafe_0: (+1)
   \   00000016   0x2086             MOVS     R0,#+134
   \   00000018   0xBD70             POP      {R4-R6,PC}
    401          
    402            len = ZCL_GetAttributeLength(zclAttr->type, zclAttr->value);
   \                     ??zclReadAttributeValueSafe_1: (+1)
   \   0000001A   0x1D21             ADDS     R1,R4,#+4
   \   0000001C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001E   0x.... 0x....      BL       ZCL_GetAttributeLength
    403          
    404            if (len > maxSize)
   \   00000022   0x9906             LDR      R1,[SP, #+24]
   \   00000024   0x4281             CMP      R1,R0
   \   00000026   0xDA01             BGE      ??zclReadAttributeValueSafe_2
    405              return ZCL_INSUFFICIENT_SPACE_STATUS;
   \   00000028   0x2089             MOVS     R0,#+137
   \   0000002A   0xBD70             POP      {R4-R6,PC}
    406          
    407            *attrType = zclAttr->type;
   \                     ??zclReadAttributeValueSafe_2: (+1)
   \   0000002C   0x78A1             LDRB     R1,[R4, #+2]
   \   0000002E   0x7031             STRB     R1,[R6, #+0]
    408            memcpy(attrValue, zclAttr->value, len);
   \   00000030   0x0002             MOVS     R2,R0
   \   00000032   0x1D21             ADDS     R1,R4,#+4
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       __aeabi_memcpy
    409            return ZCL_SUCCESS_STATUS;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    410          }
    411          
    412          /*************************************************************************//**
    413            \brief Finds attribute in ZCL and rewrites its value by the new one
    414            (to be used with local write request).
    415          
    416            \param[in] endpointId - endpoint on which cluster is registered.
    417            \param[in] clusterId - cluster unique identifier.
    418            \param[in] clusterSide - determs the cluster's side (client or server).
    419            \param[in] attrId - attribute unique identifier.
    420            \param[in] attrType - type of the attribute to be set.
    421            \param[in] attrValue - pointer to attribute value to be set.
    422          
    423            \return status of operation.
    424          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    425          ZCL_Status_t ZCL_WriteAttributeValue(Endpoint_t endpointId,
    426                                               ClusterId_t clusterId,
    427                                               uint8_t clusterSide,
    428                                               ZCL_AttributeId_t attrId,
    429                                               uint8_t attrType,
    430                                               uint8_t *attrValue)
    431          {
   \                     ZCL_WriteAttributeValue: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    432            return zclWriteAttribute(endpointId, clusterId, clusterSide, attrId, attrType, attrValue, false, false);
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x....             B.N      ?Subroutine0
    433          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x9402             STR      R4,[SP, #+8]
   \   00000002   0x9C07             LDR      R4,[SP, #+28]
   \   00000004   0x9401             STR      R4,[SP, #+4]
   \   00000006   0x9C06             LDR      R4,[SP, #+24]
   \   00000008   0x9400             STR      R4,[SP, #+0]
   \   0000000A   0x.... 0x....      BL       zclWriteAttribute
   \   0000000E   0xB004             ADD      SP,SP,#+16
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    434          
    435          
    436          /*************************************************************************//**
    437           \brief Reports attribute if report on change is enabled and all
    438             conditions to report are met.
    439          
    440           \ingroup zcl_common
    441          
    442           \param[in] attr - pointer to attribute
    443          
    444           \return The status of the operation: \n
    445              ::ZCL_SUCCESS_STATUS (0x00) - new value has been written successfully \n
    446              ::ZCL_UNSUPPORTED_ATTRIBUTE_STATUS (0x86) - the specified attribute is not supported
    447          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    448          ZCL_Status_t ZCL_ReportOnChangeIfNeeded(void *attr)
    449          {
   \                     ZCL_ReportOnChangeIfNeeded: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    450            ZCL_DataTypeDescriptor_t desc;
    451          
    452            if (!attr)
   \   00000006   0xD101             BNE      ??ZCL_ReportOnChangeIfNeeded_0
    453              return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
   \   00000008   0x2086             MOVS     R0,#+134
   \   0000000A   0xBD16             POP      {R1,R2,R4,PC}
    454          
    455            ZCL_GetDataTypeDescriptor(((ZclAttribute_t *)attr)->type, ((ZclAttribute_t *)attr)->value, &desc);
   \                     ??ZCL_ReportOnChangeIfNeeded_0: (+1)
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x1D21             ADDS     R1,R4,#+4
   \   00000010   0x78A0             LDRB     R0,[R4, #+2]
   \   00000012   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
    456            zclReportOnChangeIfNeeded(attr, &desc);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       zclReportOnChangeIfNeeded
    457          
    458            return ZCL_SUCCESS_STATUS;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    459          }
    460          
    461          
    462          /*************************************************************************//**
    463            \brief Finds attribute in ZCL and rewrites its value by the new one
    464            (to be used with remote write request).
    465          
    466            \param[in] endpointId - endpoint on which cluster is registered.
    467            \param[in] clusterId - cluster unique identifier.
    468            \param[in] clusterSide - determs the cluster's side (client or server).
    469            \param[in] attrId - attribute unique identifier.
    470            \param[in] attrType - type of the attribute to be set.
    471            \param[in] attrValue - pointer to attribute value to be set.
    472            \param[in] onlyCheck - not to write, but only check attribute existance.
    473          
    474            \return status of operation.
    475          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    476          ZCL_Status_t zclRemoteWriteAttributeValue(Endpoint_t endpointId,
    477                                                    ClusterId_t clusterId,
    478                                                    uint8_t clusterSide,
    479                                                    ZCL_AttributeId_t attrId,
    480                                                    uint8_t attrType,
    481                                                    uint8_t *attrValue,
    482                                                    bool onlyCheck)
    483          {
   \                     zclRemoteWriteAttributeValue: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    484            return zclWriteAttribute(endpointId, clusterId, clusterSide, attrId, attrType, attrValue, true, onlyCheck);
   \   00000002   0x9C08             LDR      R4,[SP, #+32]
   \   00000004   0x9403             STR      R4,[SP, #+12]
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    485          }
    486          
    487          
    488          /*************************************************************************//**
    489            \brief Finds attribute in ZCL and rewrites its reportable change value by the new one.
    490          
    491            \param[in] endpointId - endpoint on which cluster is registered.
    492            \param[in] clusterId - cluster unique identifier.
    493            \param[in] clusterSide - determs the cluster's side (client or server).
    494            \param[in] attrId - attribute unique identifier.
    495            \param[in] attrType - type of the attribute to be set.
    496            \param[in] repChange - pointer to reportable change value to be set.
    497          
    498            \return status of operation.
    499          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    500          ZCL_Status_t ZCL_SetReportableChange(Endpoint_t endpointId,
    501                                               ClusterId_t clusterId,
    502                                               uint8_t clusterSide,
    503                                               ZCL_AttributeId_t attrId,
    504                                               uint8_t attrType,
    505                                               uint8_t *repChange)
    506          {
   \                     ZCL_SetReportableChange: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x9D05             LDR      R5,[SP, #+20]
    507            ZclAttribute_t *zclAttr;
    508          
    509            if (!repChange)
   \   00000004   0x2D00             CMP      R5,#+0
   \   00000006   0xD00E             BEQ      ??ZCL_SetReportableChange_0
    510              return ZCL_INVALID_PARAMETER_STATUS;
    511          
    512            zclAttr = zclGetAttribute(endpointId, clusterId, clusterSide, attrId);
   \   00000008   0x.... 0x....      BL       zclGetAttribute
   \   0000000C   0x0004             MOVS     R4,R0
    513          
    514            if (!zclAttr)
   \   0000000E   0xD101             BNE      ??ZCL_SetReportableChange_1
    515              return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
   \   00000010   0x2086             MOVS     R0,#+134
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
    516          
    517            if (zclAttr->type != attrType)
   \                     ??ZCL_SetReportableChange_1: (+1)
   \   00000014   0x78A0             LDRB     R0,[R4, #+2]
   \   00000016   0x9904             LDR      R1,[SP, #+16]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD001             BEQ      ??ZCL_SetReportableChange_2
    518              return ZCL_INVALID_DATA_TYPE_STATUS;
   \   0000001C   0x208D             MOVS     R0,#+141
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    519          
    520            if (!(zclAttr->properties & ZCL_REPORTABLE_ATTRIBUTE))
   \                     ??ZCL_SetReportableChange_2: (+1)
   \   00000020   0x78E1             LDRB     R1,[R4, #+3]
   \   00000022   0x07C9             LSLS     R1,R1,#+31
   \   00000024   0xD401             BMI      ??ZCL_SetReportableChange_3
    521              return ZCL_INVALID_PARAMETER_STATUS;
   \                     ??ZCL_SetReportableChange_0: (+1)
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    522          
    523            uint8_t attrLength = ZCL_GetAttributeLength(zclAttr->type, (uint8_t *)zclAttr->value);
   \                     ??ZCL_SetReportableChange_3: (+1)
   \   0000002A   0x1D21             ADDS     R1,R4,#+4
   \   0000002C   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000030   0xB2C0             UXTB     R0,R0
    524            uint8_t *reportableChange = ((uint8_t *)zclAttr) +
    525                                /* attribute id */ATTRIBUTE_ID_SIZE +
    526                                /* attribute type */ATTRIBUTE_TYPE_SIZE +
    527                                /* attribute properties bitmask */sizeof(uint8_t) +
    528                                /* attribute value */attrLength +
    529                                /* report counter */ sizeof(ZCL_ReportTime_t) +
    530                                /* min report interval */ sizeof(ZCL_ReportTime_t) +
    531                                /* max report interval */ sizeof(ZCL_ReportTime_t);
    532          
    533            memcpy(reportableChange, repChange, attrLength);
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x1820             ADDS     R0,R4,R0
   \   00000038   0x300A             ADDS     R0,R0,#+10
   \   0000003A   0x.... 0x....      BL       __aeabi_memcpy
    534          
    535            return ZCL_SUCCESS_STATUS;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    536          }
    537          
    538          /**************************************************************************//**
    539            \brief Get next registered ZCL endpoint descriptor by previous.
    540          
    541            \param[in] prev - previous ZCL endpoint descriptor pointer.It is must be non NULL
    542                              sequential access required if. And it is must be NULL the
    543                              first descriptor as registered endpoints queue head element
    544                              access required if.
    545          
    546            \return Valid ZCL endpoint descriptor pointer descriptor found if,
    547                     NULL - other case.
    548           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    549          ZCL_DeviceEndpoint_t* zclNextEndpoint(ZCL_DeviceEndpoint_t *prev)
    550          {
   \                     zclNextEndpoint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    551            APS_RegisterEndpointReq_t *iter = prev? &prev->service.apsEndpoint: NULL;
    552          
    553            while (NULL != (iter = APS_NextEndpoint(iter)))
   \                     ??zclNextEndpoint_0: (+1)
   \   00000002   0x.... 0x....      BL       APS_NextEndpoint
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ      ??zclNextEndpoint_1
    554            {
    555              if (iter->APS_DataInd == zclDataInd)
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0x....             LDR      R2,??DataTable4
   \   0000000E   0x4291             CMP      R1,R2
   \   00000010   0xD1F7             BNE      ??zclNextEndpoint_0
    556                return GET_PARENT_BY_FIELD(ZCL_DeviceEndpoint_t, service.apsEndpoint, iter);
    557            }
    558          
    559            return NULL;
   \                     ??zclNextEndpoint_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    560          }
    561          
    562          /*************************************************************************//**
    563            \brief Find endpoint descriptor by endpoint id.
    564          
    565            \param[in] endpointId - endpoint unique identifier.
    566            \return endpoint descriptor if found, NULL otherwise..
    567          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    568          ZCL_DeviceEndpoint_t* zclGetEndpoint(Endpoint_t endpointId)
    569          {
   \                     zclGetEndpoint: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    570            ZCL_DeviceEndpoint_t *iter = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
    571          
    572            while (NULL != (iter = zclNextEndpoint(iter)))
   \                     ??zclGetEndpoint_0: (+1)
   \   00000006   0x.... 0x....      BL       zclNextEndpoint
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ      ??zclGetEndpoint_1
    573            {
    574              if (iter->service.apsEndpoint.simpleDescriptor->endpoint == endpointId)
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0x7809             LDRB     R1,[R1, #+0]
   \   00000012   0x42A1             CMP      R1,R4
   \   00000014   0xD1F7             BNE      ??zclGetEndpoint_0
    575                return iter;
    576            }
    577          
    578            return NULL;
   \                     ??zclGetEndpoint_1: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    579          }
    580          
    581          /*************************************************************************//**
    582            \brief Find cluster descriptor by endpoint id, cluster id.
    583          
    584            \param[in] endpointId - endpoint unique identifier.
    585            \param[in] clusterId - cluster unique identifier.
    586            \param[in] clusterSide - cluster side (client or server).
    587            \return ZCL cluster descriptor if found, NULL otherwise..
    588          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    589          ZCL_Cluster_t *ZCL_GetCluster(Endpoint_t endpointId, ClusterId_t clusterId, uint8_t clusterSide)
    590          {
   \                     ZCL_GetCluster: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0017             MOVS     R7,R2
    591            ZCL_DeviceEndpoint_t *endpoint = NULL;
    592            ZCL_Cluster_t *cluster = NULL;
   \   00000006   0x2600             MOVS     R6,#+0
    593            uint8_t clusterCounter = 0;
    594          
    595            endpoint = zclGetEndpoint(endpointId);
   \   00000008   0x.... 0x....      BL       zclGetEndpoint
    596            if (!endpoint)
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD01A             BEQ      ??ZCL_GetCluster_0
    597              return NULL;
    598          
    599            if (ZCL_CLUSTER_SIDE_CLIENT == clusterSide)
   \   00000010   0x2F01             CMP      R7,#+1
   \   00000012   0xD101             BNE      ??ZCL_GetCluster_1
    600              clusterCounter = endpoint->simpleDescriptor.AppOutClustersCount;
   \   00000014   0x7FC5             LDRB     R5,[R0, #+31]
   \   00000016   0xE002             B        ??ZCL_GetCluster_2
    601            else if (ZCL_CLUSTER_SIDE_SERVER == clusterSide)
   \                     ??ZCL_GetCluster_1: (+1)
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD114             BNE      ??ZCL_GetCluster_0
    602              clusterCounter = endpoint->simpleDescriptor.AppInClustersCount;
   \   0000001C   0x7E85             LDRB     R5,[R0, #+26]
    603            else
    604            {
    605              SYS_E_ASSERT_WARN(false,  ZCLGETCLUSTER_0);
    606              return NULL;
    607            }
    608            if (clusterCounter)
   \                     ??ZCL_GetCluster_2: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ      ??ZCL_GetCluster_3
    609              cluster = ZCL_GetHeadCluster(endpoint, clusterSide);
   \   00000022   0x0039             MOVS     R1,R7
   \   00000024   0x.... 0x....      BL       ZCL_GetHeadCluster
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0xE003             B        ??ZCL_GetCluster_3
    610            while (clusterCounter--)
    611            {
    612              if (cluster->id == clusterId)
    613                return cluster;
    614              if (clusterCounter)
   \                     ??ZCL_GetCluster_4: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD000             BEQ      ??ZCL_GetCluster_3
    615                cluster = ZCL_GetNextCluster(cluster);
   \   00000032   0x3620             ADDS     R6,R6,#+32
   \                     ??ZCL_GetCluster_3: (+1)
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x1E45             SUBS     R5,R0,#+1
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD004             BEQ      ??ZCL_GetCluster_0
   \   0000003C   0x8830             LDRH     R0,[R6, #+0]
   \   0000003E   0x42A0             CMP      R0,R4
   \   00000040   0xD1F4             BNE      ??ZCL_GetCluster_4
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}
    616            }
    617            return NULL;
   \                     ??ZCL_GetCluster_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    618          }
    619          
    620          /*************************************************************************//**
    621            \brief get the first ZCL cluster descriptor by endpoint and cluster side.
    622          
    623            \param[in] endpoint - pointer to endpoint.
    624            \param[in] clusterSide - cluster side (client or server).
    625            \return pointer to the first ZCL cluster descriptor.
    626          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    627          ZCL_Cluster_t * ZCL_GetHeadCluster(ZCL_DeviceEndpoint_t *endpoint, uint8_t clusterSide)
    628          {
   \                     ZCL_GetHeadCluster: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    629            ZCL_Cluster_t *cluster = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
    630          #if APP_CLUSTERS_IN_FLASH == 1
    631            ZCL_ClusterPartFlash_t *partFlash = NULL;
    632            ZCL_ClusterPartRam_t *partRam = NULL;
    633          #endif // APP_CLUSTERS_IN_FLASH == 1
    634          
    635            if (ZCL_CLUSTER_SIDE_CLIENT == clusterSide)
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE      ??ZCL_GetHeadCluster_0
    636            {
    637              cluster = endpoint->clientCluster;
   \   00000008   0x6A90             LDR      R0,[R2, #+40]
   \   0000000A   0x4770             BX       LR
    638          #if APP_CLUSTERS_IN_FLASH == 1
    639              partFlash = endpoint->clientClusterPartFlash;
    640              partRam = endpoint->clientClusterPartRam;
    641          #endif // APP_CLUSTERS_IN_FLASH == 1
    642            }
    643            else if (ZCL_CLUSTER_SIDE_SERVER == clusterSide)
   \                     ??ZCL_GetHeadCluster_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD100             BNE      ??ZCL_GetHeadCluster_1
    644            {
    645              cluster = endpoint->serverCluster;
   \   00000010   0x6A50             LDR      R0,[R2, #+36]
    646          #if APP_CLUSTERS_IN_FLASH == 1
    647              partFlash = endpoint->serverClusterPartFlash;
    648              partRam = endpoint->serverClusterPartRam;
    649          #endif // APP_CLUSTERS_IN_FLASH == 1
    650            }
    651          #if APP_CLUSTERS_IN_FLASH == 1
    652            if (!cluster)
    653              cluster = zclUpdateClusterImage(partFlash, partRam);
    654          #endif // APP_CLUSTERS_IN_FLASH == 1
    655            return cluster;
   \                     ??ZCL_GetHeadCluster_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    656          }
    657          /*************************************************************************//**
    658            \brief Finds next cluster descriptor.
    659          
    660            \param[in] cluster - pointer to current cluster descriptor.
    661          
    662            \return poiter to next cluster descriptor.
    663          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    664          ZCL_Cluster_t * ZCL_GetNextCluster(ZCL_Cluster_t *cluster)
    665          {
    666            //  TODO: solve situation: if castumer difened two list of cluster, 3 clusters in ram memory and 2 clusters in separate memory , then on 4 iteration we go to trash.
    667          #if APP_CLUSTERS_IN_FLASH == 1
    668            if((ZCL_Cluster_t *)&clusterImage != cluster)
    669          #endif // APP_CLUSTERS_IN_FLASH == 1
    670              cluster++;
    671          #if APP_CLUSTERS_IN_FLASH == 1
    672            else
    673            {
    674              ZCL_ClusterPartFlash_t *flashPart = clusterImage.partFlashAddr + 1;
    675              ZCL_ClusterPartRam_t *ramPart = clusterImage.partRamAddr + 1;
    676              cluster = zclUpdateClusterImage(flashPart, ramPart);
    677            }
    678          #endif // APP_CLUSTERS_IN_FLASH == 1
    679            return cluster;
   \                     ZCL_GetNextCluster: (+1)
   \   00000000   0x3020             ADDS     R0,R0,#+32
   \   00000002   0x4770             BX       LR               ;; return
    680          }
    681          #if APP_CLUSTERS_IN_FLASH == 1
    682          /*************************************************************************//**
    683            \brief Update cluster descriptor image.
    684          
    685            \param[in] flashPart - pointer to immutable part of separate cluster.
    686            \param[in] ramPart - pointer to mutable part of separete cluster.
    687            \return pointer to recovered cluster descriptor.
    688          *****************************************************************************/
    689          static ZCL_Cluster_t * zclUpdateClusterImage(ZCL_ClusterPartFlash_t *flashPart, ZCL_ClusterPartRam_t *ramPart)
    690          {
    691            //Synchronizes the image of a cluster with a mutable part
    692            if (clusterImage.needSynchronize)
    693            {
    694              memcpy((void *)clusterImage.partRamAddr, &clusterImage.partRam, sizeof(ZCL_ClusterPartRam_t));
    695              clusterImage.needSynchronize = NULL;
    696            }
    697          
    698            // update immutable part image
    699            clusterImage.partFlashAddr = flashPart;
    700            if (clusterImage.partFlashAddr)
    701            {
    702              // copy all immutable fields without commands, because *uint8_t and __farflash *uint8_t can have different size.
    703              memcpy_P((void *)&clusterImage.partFlash, clusterImage.partFlashAddr, sizeof(ZCL_ClusterPartFlash_t) - sizeof(FLASH_PTR ZclCommand_t*));
    704              // copy commands address
    705              memcpy_P((void *)&clusterImage.commandsAddr, &(clusterImage.partFlashAddr->commands), sizeof(FLASH_PTR ZclCommand_t*));
    706            }
    707            else
    708              clusterImage.commandsAddr = NULL;
    709          
    710            // update commands image
    711            if (clusterImage.commandsAddr)
    712            {
    713              memcpy_P((void *)&clusterImage.commandImage, clusterImage.commandsAddr, sizeof(ZclCommand_t));
    714              clusterImage.partFlash.commands = (uint8_t *)&clusterImage.commandImage;
    715            }
    716            else
    717              clusterImage.partFlash.commands = NULL;
    718          
    719            // update mutable part image
    720            clusterImage.partRamAddr = ramPart;
    721            if (clusterImage.partRamAddr)
    722            {
    723              memcpy((void *)&clusterImage.partRam, clusterImage.partRamAddr, sizeof(ZCL_ClusterPartRam_t));
    724              clusterImage.needSynchronize = 1;
    725            }
    726          
    727            return (ZCL_Cluster_t *)&clusterImage;
    728          }
    729          #endif // APP_CLUSTERS_IN_FLASH == 1
    730          /*************************************************************************//**
    731            \brief Finds attribute descriptor by endpoint id, cluster id , cluster side
    732                   and attribute id.
    733          
    734            \param[in] endpointId - endpoint unique identifier.
    735            \param[in] clusterId - cluster unique identifier.
    736            \param[in] clusterSide - cluster side (client or server).
    737            \param[in] attributeId - attribute unique identifier.
    738            \return attribute descriptor if found, NULL otherwise.
    739          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    740          ZclAttribute_t * zclGetAttribute(Endpoint_t endpointId, ClusterId_t clusterId, uint8_t clusterSide, ZCL_AttributeId_t attributeId)
    741          {
   \                     zclGetAttribute: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x001C             MOVS     R4,R3
    742            ZCL_Cluster_t *cluster;
    743            ZclAttribute_t *attr;
    744          
    745            cluster = ZCL_GetCluster(endpointId, clusterId, clusterSide);
   \   00000004   0x.... 0x....      BL       ZCL_GetCluster
   \   00000008   0x0001             MOVS     R1,R0
    746            if (!cluster)
   \   0000000A   0xD012             BEQ      ??zclGetAttribute_0
    747              return NULL;
    748          
    749            attr = (ZclAttribute_t *)cluster->attributes;
   \   0000000C   0x6848             LDR      R0,[R1, #+4]
    750            if (!attr)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00F             BEQ      ??zclGetAttribute_0
    751              return NULL;
    752          
    753            // find requested attribute
    754            for (uint8_t i = cluster->attributesAmount; i; i--)
   \   00000012   0x78CD             LDRB     R5,[R1, #+3]
   \   00000014   0xE002             B        ??zclGetAttribute_1
    755            {
    756              if (attr->id == attributeId)
    757                return attr;
    758          
    759              attr = jumpToNextAttribute(attr);
   \                     ??zclGetAttribute_2: (+1)
   \   00000016   0x.... 0x....      BL       jumpToNextAttribute
   \   0000001A   0x1E6D             SUBS     R5,R5,#+1
   \                     ??zclGetAttribute_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ      ??zclGetAttribute_0
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   \   00000024   0x7842             LDRB     R2,[R0, #+1]
   \   00000026   0x0612             LSLS     R2,R2,#+24
   \   00000028   0x0C12             LSRS     R2,R2,#+16
   \   0000002A   0x4311             ORRS     R1,R1,R2
   \   0000002C   0x42A1             CMP      R1,R4
   \   0000002E   0xD1F2             BNE      ??zclGetAttribute_2
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    760            }
    761            return NULL;
   \                     ??zclGetAttribute_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    762          }
    763          
    764          /*************************************************************************//**
    765            \brief Finds next attribute descriptor.
    766          
    767            \param[in] endpoint - endpoint number.
    768            \param[in] clusterId - cluster unique identifier.
    769            \param[in] clusterSide - cluster side (client or server).
    770            \param[in] currentAttribute - current attribute descriptor.
    771            \return next attribute descriptor if found, NULL otherwise.
    772          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    773          ZclAttribute_t *zclGetNextAttribute(Endpoint_t endpoint,
    774                                              ClusterId_t clusterId,
    775                                              uint8_t clusterSide,
    776                                              ZclAttribute_t *currentAttribute)
    777          {
   \                     zclGetNextAttribute: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    778            static uint8_t attributeNumber = 0;
    779            static uint8_t attributesAmount = 0;
    780            static Endpoint_t endpointSaved = 0;
    781            static ClusterId_t clusterIdSaved = 0;
    782            static ZclAttribute_t *result = NULL;
    783          
    784            ZCL_Cluster_t *cluster;
    785          
    786            if (NULL == currentAttribute)
   \   00000002   0x....             LDR      R4,??DataTable5
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD110             BNE      ??zclGetNextAttribute_0
    787            {
    788              // Start of interation
    789              attributeNumber = 0;
   \   0000000A   0x7025             STRB     R5,[R4, #+0]
    790              attributesAmount = 0;
   \   0000000C   0x7065             STRB     R5,[R4, #+1]
    791              endpointSaved = endpoint;
   \   0000000E   0x70A0             STRB     R0,[R4, #+2]
    792              clusterIdSaved = clusterId;
   \   00000010   0x80A1             STRH     R1,[R4, #+4]
    793              result = NULL;
   \   00000012   0x60A5             STR      R5,[R4, #+8]
    794              cluster = ZCL_GetCluster(endpoint, clusterId, clusterSide);
   \   00000014   0x.... 0x....      BL       ZCL_GetCluster
    795              if (NULL != cluster)
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD01D             BEQ      ??zclGetNextAttribute_1
    796              {
    797                attributesAmount = cluster->attributesAmount;
   \   0000001C   0x78C1             LDRB     R1,[R0, #+3]
   \   0000001E   0x7061             STRB     R1,[R4, #+1]
    798                if (0 != attributesAmount)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD019             BEQ      ??zclGetNextAttribute_1
    799                {
    800                  result = (ZclAttribute_t *) cluster->attributes;
   \   00000024   0x6840             LDR      R0,[R0, #+4]
   \   00000026   0x60A0             STR      R0,[R4, #+8]
    801                  attributeNumber = 0;
   \   00000028   0x7025             STRB     R5,[R4, #+0]
   \   0000002A   0xE015             B        ??zclGetNextAttribute_1
    802                }
    803              }
    804            }
    805            else
    806            {
    807              if ((endpointSaved == endpoint) &&
    808                  (clusterIdSaved == clusterId) &&
    809                  (result == currentAttribute) &&
    810                  ((attributeNumber + 1) < attributesAmount))
   \                     ??zclGetNextAttribute_0: (+1)
   \   0000002C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000002E   0x4282             CMP      R2,R0
   \   00000030   0xD111             BNE      ??zclGetNextAttribute_2
   \   00000032   0x88A0             LDRH     R0,[R4, #+4]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD10E             BNE      ??zclGetNextAttribute_2
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0x4298             CMP      R0,R3
   \   0000003C   0xD10B             BNE      ??zclGetNextAttribute_2
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x1C41             ADDS     R1,R0,#+1
   \   00000042   0x7862             LDRB     R2,[R4, #+1]
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xDA06             BGE      ??zclGetNextAttribute_2
    811              {
    812                attributeNumber++;
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x7020             STRB     R0,[R4, #+0]
    813                result = jumpToNextAttribute(currentAttribute);
   \   0000004C   0x0018             MOVS     R0,R3
   \   0000004E   0x.... 0x....      BL       jumpToNextAttribute
   \   00000052   0x60A0             STR      R0,[R4, #+8]
   \   00000054   0xE000             B        ??zclGetNextAttribute_1
    814              }
    815              else
    816              {
    817                result = NULL;
   \                     ??zclGetNextAttribute_2: (+1)
   \   00000056   0x60A5             STR      R5,[R4, #+8]
    818              }
    819            }
    820            return result;
   \                     ??zclGetNextAttribute_1: (+1)
   \   00000058   0x68A0             LDR      R0,[R4, #+8]
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    821          }

   \                                 In section .bss, align 4
   \                     ??attributeNumber:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 4
    822          
    823          /**************************************************************************//**
    824          \brief Read indexed (structured) attribute from array
    825          
    826          \param[in,out] selector - pointer to pointer to index selector
    827          \param[in] endpointId - endpoint of attribute to be read
    828          \param[in] clusterId - cluster of attribute to be read
    829          \param[in] clusterSide - client or server side
    830          \param[in] attrId - attribute identifier
    831          \param[out] attrType - attribute type
    832          \param[out] attrValue - buffer to read attribute value
    833          \param[in] maxSize - maximum size of buffer
    834          \return status of operation
    835          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    836          ZCL_Status_t zclReadIndexedAttribute(const ZCL_Selector_t *selector,
    837                                               Endpoint_t endpointId,
    838                                               ClusterId_t clusterId,
    839                                               uint8_t clusterSide,
    840                                               ZCL_AttributeId_t attrId,
    841                                               uint8_t *attrType,
    842                                               uint8_t *attrValue,
    843                                               uint16_t maxSize)
    844          {
   \                     zclReadIndexedAttribute: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0x0008             MOVS     R0,R1
   \   00000004   0x0011             MOVS     R1,R2
   \   00000006   0x001A             MOVS     R2,R3
    845            ZclAttribute_t *attr;
    846            uint8_t type;
    847            const uint8_t *val;
    848            uint16_t len;
    849          
    850            // 2.4.15.1.3
    851            if (selector->indicator > 15)
   \   00000008   0x9B00             LDR      R3,[SP, #+0]
   \   0000000A   0x781B             LDRB     R3,[R3, #+0]
   \   0000000C   0x2B10             CMP      R3,#+16
   \   0000000E   0xDA56             BGE      ??zclReadIndexedAttribute_0
    852              return ZCL_INVALID_SELECTOR_STATUS;
    853          
    854            // Obtain mother attribute (root)
    855            attr = zclGetAttribute(endpointId, clusterId, clusterSide, attrId);
   \   00000010   0x9B06             LDR      R3,[SP, #+24]
   \   00000012   0x.... 0x....      BL       zclGetAttribute
    856            if (!attr)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE      ??zclReadIndexedAttribute_1
    857              return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
   \   0000001A   0x2086             MOVS     R0,#+134
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
    858          
    859            type = attr->type;
   \                     ??zclReadIndexedAttribute_1: (+1)
   \   0000001E   0x7885             LDRB     R5,[R0, #+2]
    860            val = attr->value;
   \   00000020   0x1D04             ADDS     R4,R0,#+4
   \   00000022   0x2600             MOVS     R6,#+0
   \   00000024   0xE002             B        ??zclReadIndexedAttribute_2
    861            // Dive deeper and deeper
    862            for (uint8_t depth = 0; depth < selector->indicator; depth++)
    863            {
    864              uint16_t idx = selector->index[depth];
    865              // Only ordered sequences (array/structure) may be index-readed
    866              if (type != ZCL_ARRAY_DATA_TYPE_ID && type != ZCL_STRUCTURE_DATA_TYPE_ID)
    867                  return ZCL_INVALID_SELECTOR_STATUS; // should we return ZCL_UNSUPPORTED_ATTRIBUTE_STATUS instead ?
    868          
    869              if (0 == idx)                             // Read of array/structure size
    870              {
    871                if (depth != selector->indicator - 1)   // Zero elementh may be only at the end of traverse
    872                  return ZCL_INVALID_SELECTOR_STATUS;
    873                // Counts are placed at different offsets for array and structure
    874                val += (ZCL_ARRAY_DATA_TYPE_ID == type) ? offsetof(ZclArraySetBag_t, cnt) : offsetof(ZclStructure_t, cnt);
    875                type = ZCL_U16BIT_DATA_TYPE_ID;
    876                break;
    877              }
    878          
    879              idx--;                                    // Structures/arrays are indexed from 1 in ZCL
    880          
    881              if (ZCL_ARRAY_DATA_TYPE_ID == type)
    882              {
    883                const ZclArraySetBag_t *p = (const ZclArraySetBag_t*)val;
    884                if (idx >= p->cnt)
    885                  return ZCL_INVALID_SELECTOR_STATUS; // Out of range
    886                type = p->type;
    887                val = p->elements + idx * ZCL_GetAttributeLength(p->type, p->elements);
    888              }
    889              else // ZCL_STRUCTURE_DATA_TYPE_ID == type
    890              {
    891                const ZclStructure_t *st = (const ZclStructure_t*)val;
    892                if (idx >= st->cnt)
    893                  return ZCL_INVALID_SELECTOR_STATUS; // Out of range
    894                ZclStructureElement_t *e = zclObtainStructureElement(st, idx);
    895                if (!e)
    896                  return ZCL_INVALID_SELECTOR_STATUS;     // Out of range
    897                type = e->type;
   \                     ??zclReadIndexedAttribute_3: (+1)
   \   00000026   0x7805             LDRB     R5,[R0, #+0]
    898                val = e->value;
   \   00000028   0x1C44             ADDS     R4,R0,#+1
   \                     ??zclReadIndexedAttribute_4: (+1)
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \                     ??zclReadIndexedAttribute_2: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xB2F6             UXTB     R6,R6
   \   00000032   0x4286             CMP      R6,R0
   \   00000034   0xD217             BCS      ??zclReadIndexedAttribute_5
   \   00000036   0x9A00             LDR      R2,[SP, #+0]
   \   00000038   0x0073             LSLS     R3,R6,#+1
   \   0000003A   0x18D3             ADDS     R3,R2,R3
   \   0000003C   0x785A             LDRB     R2,[R3, #+1]
   \   0000003E   0x789F             LDRB     R7,[R3, #+2]
   \   00000040   0x063F             LSLS     R7,R7,#+24
   \   00000042   0x0C3F             LSRS     R7,R7,#+16
   \   00000044   0x433A             ORRS     R2,R2,R7
   \   00000046   0x2D48             CMP      R5,#+72
   \   00000048   0xD001             BEQ      ??zclReadIndexedAttribute_6
   \   0000004A   0x2D4C             CMP      R5,#+76
   \   0000004C   0xD137             BNE      ??zclReadIndexedAttribute_0
   \                     ??zclReadIndexedAttribute_6: (+1)
   \   0000004E   0x2A00             CMP      R2,#+0
   \   00000050   0xD112             BNE      ??zclReadIndexedAttribute_7
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0x4286             CMP      R6,R0
   \   00000056   0xD132             BNE      ??zclReadIndexedAttribute_0
   \   00000058   0x2D48             CMP      R5,#+72
   \   0000005A   0xD101             BNE      ??zclReadIndexedAttribute_8
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE000             B        ??zclReadIndexedAttribute_9
   \                     ??zclReadIndexedAttribute_8: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??zclReadIndexedAttribute_9: (+1)
   \   00000062   0x1824             ADDS     R4,R4,R0
   \   00000064   0x2521             MOVS     R5,#+33
    899              }
    900            }
    901          
    902            len = ZCL_GetAttributeLength(type, val);  // Finally descended to required attribute
   \                     ??zclReadIndexedAttribute_5: (+1)
   \   00000066   0x0021             MOVS     R1,R4
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x.... 0x....      BL       ZCL_GetAttributeLength
    903          
    904            if (len > maxSize)
   \   0000006E   0x9909             LDR      R1,[SP, #+36]
   \   00000070   0x4281             CMP      R1,R0
   \   00000072   0xDA26             BGE      ??zclReadIndexedAttribute_10
    905              return ZCL_INSUFFICIENT_SPACE_STATUS;
   \   00000074   0x2089             MOVS     R0,#+137
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??zclReadIndexedAttribute_7: (+1)
   \   00000078   0x1E51             SUBS     R1,R2,#+1
   \   0000007A   0x2D48             CMP      R5,#+72
   \   0000007C   0xD112             BNE      ??zclReadIndexedAttribute_11
   \   0000007E   0x7860             LDRB     R0,[R4, #+1]
   \   00000080   0x78A2             LDRB     R2,[R4, #+2]
   \   00000082   0x0612             LSLS     R2,R2,#+24
   \   00000084   0x0C12             LSRS     R2,R2,#+16
   \   00000086   0x4310             ORRS     R0,R0,R2
   \   00000088   0xB289             UXTH     R1,R1
   \   0000008A   0x4281             CMP      R1,R0
   \   0000008C   0xD217             BCS      ??zclReadIndexedAttribute_0
   \   0000008E   0x7820             LDRB     R0,[R4, #+0]
   \   00000090   0x0005             MOVS     R5,R0
   \   00000092   0x000F             MOVS     R7,R1
   \   00000094   0x1CE1             ADDS     R1,R4,#+3
   \   00000096   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000009A   0x0039             MOVS     R1,R7
   \   0000009C   0x4341             MULS     R1,R0,R1
   \   0000009E   0x1864             ADDS     R4,R4,R1
   \   000000A0   0x1CE4             ADDS     R4,R4,#+3
   \   000000A2   0xE7C2             B        ??zclReadIndexedAttribute_4
   \                     ??zclReadIndexedAttribute_11: (+1)
   \   000000A4   0x7820             LDRB     R0,[R4, #+0]
   \   000000A6   0x7862             LDRB     R2,[R4, #+1]
   \   000000A8   0x0612             LSLS     R2,R2,#+24
   \   000000AA   0x0C12             LSRS     R2,R2,#+16
   \   000000AC   0x4310             ORRS     R0,R0,R2
   \   000000AE   0xB289             UXTH     R1,R1
   \   000000B0   0x4281             CMP      R1,R0
   \   000000B2   0xD204             BCS      ??zclReadIndexedAttribute_0
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       zclObtainStructureElement
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD1B3             BNE      ??zclReadIndexedAttribute_3
   \                     ??zclReadIndexedAttribute_0: (+1)
   \   000000BE   0x208E             MOVS     R0,#+142
   \   000000C0   0xBDF2             POP      {R1,R4-R7,PC}
    906          
    907            *attrType = type;
   \                     ??zclReadIndexedAttribute_10: (+1)
   \   000000C2   0x9907             LDR      R1,[SP, #+28]
   \   000000C4   0x700D             STRB     R5,[R1, #+0]
    908            memcpy(attrValue, val, len);
   \   000000C6   0x0002             MOVS     R2,R0
   \   000000C8   0x0021             MOVS     R1,R4
   \   000000CA   0x9808             LDR      R0,[SP, #+32]
   \   000000CC   0x.... 0x....      BL       __aeabi_memcpy
    909            return ZCL_SUCCESS_STATUS;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    910          }
    911          
    912          /*************************************************************************//**
    913            \brief Finds command descriptor by endpoint id, cluster id and command id.
    914          
    915            \param[in] endpointId - endpoint number.
    916            \param[in] clusterId - cluster unique identifier.
    917            \param[in] direction - command direction (client or server).
    918            \param[in] commandId - command unique identifier.
    919            \return command descriptor if found, NULL otherwise.
    920          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    921          ZclCommand_t * zclGetCommand(Endpoint_t endpointId, ClusterId_t clusterId, uint8_t direction, ZCL_CommandId_t commandId)
    922          {
   \                     zclGetCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0014             MOVS     R4,R2
   \   00000004   0x001D             MOVS     R5,R3
    923            ZCL_Cluster_t *cluster = NULL;
    924          
    925            cluster = ZCL_GetCluster(endpointId,
    926                                    clusterId,
    927                                    getOwnClusterSideByIncomingCommandDirection(direction));
   \   00000006   0x.... 0x....      BL       ZCL_GetCluster
    928          
    929            return zclGetCommandByCluster(cluster, direction, commandId);
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x.... 0x....      BL       zclGetCommandByCluster
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    930          }
    931          
    932          /*************************************************************************//**
    933            \brief Compares current attribute value with last reported value and if
    934                   difference exceeds reportableChange value returns true.
    935          
    936            \param[in] pAttr - pointer to attribute.
    937          
    938            \return true if reporting is needed, false otherwise.
    939          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    940          static bool isOnChangeReportingNeeded(const ZclAttribute_t *pAttr)
    941          {
   \                     isOnChangeReportingNeeded: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    942            ZCL_DataTypeDescriptor_t attrDesc;
    943            ZCL_GetDataTypeDescriptor(pAttr->type, (uint8_t *)&pAttr->value, &attrDesc);
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x1D21             ADDS     R1,R4,#+4
   \   0000000A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000C   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x8800             LDRH     R0,[R0, #+0]
   \   00000014   0x1821             ADDS     R1,R4,R0
   \   00000016   0x1D09             ADDS     R1,R1,#+4
    944          
    945            uint8_t *repAttrTail = ((uint8_t *)pAttr) + SLICE_SIZE(ZclAttribute_t, id, properties) + attrDesc.length;
    946            uint8_t *pLastRepValue = repAttrTail + sizeof(ZclReportableAttributeTail_t) + attrDesc.length + sizeof(ZCL_ReportTime_t);
   \   00000018   0x180D             ADDS     R5,R1,R0
   \   0000001A   0x3508             ADDS     R5,R5,#+8
    947            uint8_t *pReportableChange = repAttrTail + sizeof(ZclReportableAttributeTail_t);
   \   0000001C   0x1D89             ADDS     R1,R1,#+6
   \   0000001E   0x9101             STR      R1,[SP, #+4]
    948          
    949            if (memcmp(pAttr->value, pLastRepValue, attrDesc.length))
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x8802             LDRH     R2,[R0, #+0]
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x.... 0x....      BL       memcmp
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD063             BEQ      ??isOnChangeReportingNeeded_0
    950            {
    951              if (ZCL_DATA_TYPE_STRUCTURED_KIND == attrDesc.kind) // collection data types are not reportable
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x7880             LDRB     R0,[R0, #+2]
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD05F             BEQ      ??isOnChangeReportingNeeded_0
    952                return false;
    953          
    954              if (attrDesc.kind == ZCL_DATA_TYPE_DISCRETE_KIND) // discrete types should be always reported on change (?)
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD034             BEQ      ??isOnChangeReportingNeeded_1
    955                return true;
    956          
    957              if (zclIsAttributeTypeUnsigned(pAttr->type))
   \   0000003C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000003E   0x3828             SUBS     R0,R0,#+40
   \   00000040   0x2807             CMP      R0,#+7
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x8801             LDRH     R1,[R0, #+0]
   \   00000046   0xD830             BHI      ??isOnChangeReportingNeeded_2
    958              {
    959                uint64_t currentVal = readUnsignedLE(pAttr->value, attrDesc.length);
    960                uint64_t lastVal = readUnsignedLE(pLastRepValue, attrDesc.length);
    961                uint64_t repChange = readUnsignedLE(pReportableChange, attrDesc.length);
    962          
    963                if ( repChange &&
    964                    (lastVal + repChange <= currentVal ||
    965                     lastVal >= currentVal  + repChange))
    966                {
    967                  return true;
    968                }
    969              }
    970              else
    971              {
    972                int64_t currentVal = readSignedLE(pAttr->value, attrDesc.length);
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x1D20             ADDS     R0,R4,#+4
   \   0000004C   0x.... 0x....      BL       readSignedLE
   \   00000050   0x0006             MOVS     R6,R0
   \   00000052   0x000F             MOVS     R7,R1
    973                int64_t lastVal = readSignedLE(pLastRepValue, attrDesc.length);
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x8801             LDRH     R1,[R0, #+0]
   \   00000058   0xB2C9             UXTB     R1,R1
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       readSignedLE
   \   00000060   0x0004             MOVS     R4,R0
   \   00000062   0x000D             MOVS     R5,R1
    974                int64_t repChange = readSignedLE(pReportableChange, attrDesc.length);
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x8801             LDRH     R1,[R0, #+0]
   \   00000068   0xB2C9             UXTB     R1,R1
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x.... 0x....      BL       readSignedLE
    975          
    976                // Ignore the sign of reportable change value
    977                repChange = (repChange < 0) ? -repChange : repChange;
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xDA05             BGE      ??isOnChangeReportingNeeded_3
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0x1A12             SUBS     R2,R2,R0
   \   0000007A   0x418B             SBCS     R3,R3,R1
   \   0000007C   0x0010             MOVS     R0,R2
   \   0000007E   0x0019             MOVS     R1,R3
    978          
    979                if (repChange &&
    980                    (lastVal + repChange <= currentVal ||
    981                    lastVal >= currentVal  + repChange))
   \                     ??isOnChangeReportingNeeded_3: (+1)
   \   00000080   0x2900             CMP      R1,#+0
   \   00000082   0xD101             BNE      ??isOnChangeReportingNeeded_4
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD037             BEQ      ??isOnChangeReportingNeeded_0
   \                     ??isOnChangeReportingNeeded_4: (+1)
   \   00000088   0x000B             MOVS     R3,R1
   \   0000008A   0x1902             ADDS     R2,R0,R4
   \   0000008C   0x416B             ADCS     R3,R3,R5
   \   0000008E   0x429F             CMP      R7,R3
   \   00000090   0xDC09             BGT      ??isOnChangeReportingNeeded_1
   \   00000092   0xDB01             BLT      ??isOnChangeReportingNeeded_5
   \   00000094   0x4296             CMP      R6,R2
   \   00000096   0xD206             BCS      ??isOnChangeReportingNeeded_1
   \                     ??isOnChangeReportingNeeded_5: (+1)
   \   00000098   0x1980             ADDS     R0,R0,R6
   \   0000009A   0x4179             ADCS     R1,R1,R7
   \   0000009C   0x428D             CMP      R5,R1
   \   0000009E   0xDB2B             BLT      ??isOnChangeReportingNeeded_0
   \   000000A0   0xDC01             BGT      ??isOnChangeReportingNeeded_1
   \   000000A2   0x4284             CMP      R4,R0
   \   000000A4   0xD328             BCC      ??isOnChangeReportingNeeded_0
    982                {
    983                  return true;
   \                     ??isOnChangeReportingNeeded_1: (+1)
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xBDFE             POP      {R1-R7,PC}
    984                }
    985              }
   \                     ??isOnChangeReportingNeeded_2: (+1)
   \   000000AA   0xB2C9             UXTB     R1,R1
   \   000000AC   0x1D20             ADDS     R0,R4,#+4
   \   000000AE   0x.... 0x....      BL       readUnsignedLE
   \   000000B2   0x0006             MOVS     R6,R0
   \   000000B4   0x000F             MOVS     R7,R1
   \   000000B6   0x4668             MOV      R0,SP
   \   000000B8   0x8801             LDRH     R1,[R0, #+0]
   \   000000BA   0xB2C9             UXTB     R1,R1
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0x.... 0x....      BL       readUnsignedLE
   \   000000C2   0x0004             MOVS     R4,R0
   \   000000C4   0x000D             MOVS     R5,R1
   \   000000C6   0x4668             MOV      R0,SP
   \   000000C8   0x8801             LDRH     R1,[R0, #+0]
   \   000000CA   0xB2C9             UXTB     R1,R1
   \   000000CC   0x9801             LDR      R0,[SP, #+4]
   \   000000CE   0x.... 0x....      BL       readUnsignedLE
   \   000000D2   0x2900             CMP      R1,#+0
   \   000000D4   0xD101             BNE      ??isOnChangeReportingNeeded_6
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD00E             BEQ      ??isOnChangeReportingNeeded_0
   \                     ??isOnChangeReportingNeeded_6: (+1)
   \   000000DA   0x000B             MOVS     R3,R1
   \   000000DC   0x1902             ADDS     R2,R0,R4
   \   000000DE   0x416B             ADCS     R3,R3,R5
   \   000000E0   0x429F             CMP      R7,R3
   \   000000E2   0xD8E0             BHI      ??isOnChangeReportingNeeded_1
   \   000000E4   0xD301             BCC      ??isOnChangeReportingNeeded_7
   \   000000E6   0x4296             CMP      R6,R2
   \   000000E8   0xD2DD             BCS      ??isOnChangeReportingNeeded_1
   \                     ??isOnChangeReportingNeeded_7: (+1)
   \   000000EA   0x1980             ADDS     R0,R0,R6
   \   000000EC   0x4179             ADCS     R1,R1,R7
   \   000000EE   0x428D             CMP      R5,R1
   \   000000F0   0xD8D9             BHI      ??isOnChangeReportingNeeded_1
   \   000000F2   0xD301             BCC      ??isOnChangeReportingNeeded_0
   \   000000F4   0x4284             CMP      R4,R0
   \   000000F6   0xD2D6             BCS      ??isOnChangeReportingNeeded_1
    986            }
    987          
    988            return false;
   \                     ??isOnChangeReportingNeeded_0: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xBDFE             POP      {R1-R7,PC}       ;; return
    989          }
    990          
    991          /*************************************************************************//**
    992            \brief Checks whether attribute is configured for reporting.
    993          
    994            \param[in] pAttr - pointer to attribute.
    995          
    996            \return true if reporting is permitted, false otherwise.
    997          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    998          bool isReportingPermitted(const ZclAttribute_t *pAttr)
    999          {
   \                     isReportingPermitted: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1000            uint8_t attrLength = ZCL_GetAttributeLength(pAttr->type, pAttr->value);
   1001            uint8_t *maxReportTimePtr = (uint8_t *)pAttr + ATTRIBUTE_ID_SIZE + ATTRIBUTE_TYPE_SIZE +
   1002              + sizeof(uint8_t) + attrLength + sizeof(ZCL_ReportTime_t) + sizeof(ZCL_ReportTime_t); // properties + value + reportCounter + minReportInterval
   \   00000004   0x1D21             ADDS     R1,R4,#+4
   \   00000006   0x78A0             LDRB     R0,[R4, #+2]
   \   00000008   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x1820             ADDS     R0,R4,R0
   \   00000010   0x3008             ADDS     R0,R0,#+8
   1003            ZCL_ReportTime_t maxReportTime = (ZCL_ReportTime_t)*maxReportTimePtr | (*(maxReportTimePtr + 1) << 8);
   1004          
   1005            return (0xFFFF == maxReportTime ? false : (pAttr->properties & ZCL_REPORTING_CONFIGURED));
   \   00000012   0x7801             LDRB     R1,[R0, #+0]
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x0200             LSLS     R0,R0,#+8
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0x....             LDR      R1,??DataTable6  ;; 0xffff
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD006             BEQ      ??isReportingPermitted_0
   \   00000020   0x78E1             LDRB     R1,[R4, #+3]
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x4001             ANDS     R1,R1,R0
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xD002             BEQ      ??isReportingPermitted_1
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD10             POP      {R4,PC}
   \                     ??isReportingPermitted_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??isReportingPermitted_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1006          }
   1007          
   1008          /*************************************************************************//**
   1009            \brief Finds command descriptor by cluster, direction and command id.
   1010          
   1011            \param[in] cluster   - pointer to cluster.
   1012            \param[in] direction - command direction (client or server).
   1013            \param[in] commandId - command unique identifier.
   1014            \return command descriptor if found, NULL otherwise.
   1015          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1016          ZclCommand_t * zclGetCommandByCluster(ZCL_Cluster_t *cluster, uint8_t direction, ZCL_CommandId_t commandId)
   1017          {
   \                     zclGetCommandByCluster: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0003             MOVS     R3,R0
   1018            ZclCommand_t  *command;
   1019          
   1020            // Assert here ?
   1021            if (!cluster)
   \   00000004   0xD012             BEQ      ??zclGetCommandByCluster_0
   1022              return NULL;
   1023          
   1024            command = (ZclCommand_t  *) cluster->commands;
   \   00000006   0x68D8             LDR      R0,[R3, #+12]
   1025            if (!command)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00F             BEQ      ??zclGetCommandByCluster_0
   1026              return NULL;
   1027          
   1028            for (uint8_t i = cluster->commandsAmount; i; i--)
   \   0000000C   0x7A1B             LDRB     R3,[R3, #+8]
   \   0000000E   0xE001             B        ??zclGetCommandByCluster_1
   1029            {
   1030              if (command->id == commandId && command->options.direction == direction)
   1031                return command;
   1032              command = zclGetNextCommand(command);
   \                     ??zclGetCommandByCluster_2: (+1)
   \   00000010   0x3008             ADDS     R0,R0,#+8
   \   00000012   0x1E5B             SUBS     R3,R3,#+1
   \                     ??zclGetCommandByCluster_1: (+1)
   \   00000014   0xB2DB             UXTB     R3,R3
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD008             BEQ      ??zclGetCommandByCluster_0
   \   0000001A   0x7804             LDRB     R4,[R0, #+0]
   \   0000001C   0x4294             CMP      R4,R2
   \   0000001E   0xD1F7             BNE      ??zclGetCommandByCluster_2
   \   00000020   0x7844             LDRB     R4,[R0, #+1]
   \   00000022   0x07E5             LSLS     R5,R4,#+31
   \   00000024   0x0FED             LSRS     R5,R5,#+31
   \   00000026   0x428D             CMP      R5,R1
   \   00000028   0xD1F2             BNE      ??zclGetCommandByCluster_2
   \   0000002A   0xBD30             POP      {R4,R5,PC}
   1033            }
   1034            return NULL;
   \                     ??zclGetCommandByCluster_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
   1035          }
   1036          /*************************************************************************//**
   1037            \brief Give next command descriptor.
   1038          
   1039            \param[in] command - pointer to command.
   1040            \return none
   1041          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1042          ZclCommand_t * zclGetNextCommand(ZclCommand_t *command)
   1043          {
   1044          #if APP_CLUSTERS_IN_FLASH == 1
   1045            if ((ZclCommand_t *)&clusterImage.commandImage != command)
   1046          #endif // APP_CLUSTERS_IN_FLASH == 1
   1047              command++;
   1048          #if APP_CLUSTERS_IN_FLASH == 1
   1049            else
   1050              memcpy_P((void *)&clusterImage.commandImage, ++clusterImage.commandsAddr, sizeof(ZclCommand_t));
   1051          #endif // APP_CLUSTERS_IN_FLASH == 1
   1052            return command;
   \                     zclGetNextCommand: (+1)
   \   00000000   0x3008             ADDS     R0,R0,#+8
   \   00000002   0x4770             BX       LR               ;; return
   1053          }
   1054          
   1055          /*************************************************************************//**
   1056            \brief     Security Type get by Cluster Id function and by endpointId, on which
   1057                       was registered cluster.
   1058                       Returns Security Type should be used with ClusterId specified
   1059            \param[in] clusterId - cluster identifier
   1060            \param[in] endpointId - end point identifier
   1061            \return    ZCL_NETWORK_KEY_CLUSTER_SECURITY - NWK Key Security should be used
   1062                       ZCL_APPLICATION_LINK_KEY_CLUSTER_SECURITY - APS Link Key Security
   1063                       shoud be used.
   1064                       If cluster is unknown, security key will be determined by security mode,
   1065                       i.e. ZCL_NETWORK_KEY_CLUSTER_SECURITY for Standard Security,
   1066                            ZCL_APPLICATION_LINK_KEY_CLUSTER_SECURITY for High Security.
   1067          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1068          uint8_t zclGetSecurityTypeByClusterId(ClusterId_t clusterId, Endpoint_t endpointId)
   1069          {
   \                     zclGetSecurityTypeByClusterId: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1070          #if (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
   1071            ZCL_Cluster_t *cluster = NULL;
   1072          
   1073            cluster = ZCL_GetCluster(endpointId, clusterId, ZCL_CLUSTER_SIDE_CLIENT);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       ZCL_GetCluster
   1074            if (!cluster)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD104             BNE      ??zclGetSecurityTypeByClusterId_0
   1075              cluster = ZCL_GetCluster(endpointId, clusterId, ZCL_CLUSTER_SIDE_SERVER);
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       ZCL_GetCluster
   1076          
   1077            if (cluster)
   \                     ??zclGetSecurityTypeByClusterId_0: (+1)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ      ??zclGetSecurityTypeByClusterId_1
   1078              return cluster->options.security;
   \   00000022   0x7881             LDRB     R1,[R0, #+2]
   \   00000024   0x0788             LSLS     R0,R1,#+30
   \   00000026   0x0FC0             LSRS     R0,R0,#+31
   1079          
   1080          #else
   1081            (void)clusterId;
   1082            (void)endpointId;
   1083          #endif /* (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_) */
   1084            return ZCL_DEFAULT_CLUSTER_SECURITY;
   \                     ??zclGetSecurityTypeByClusterId_1: (+1)
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1085          }
   1086          
   1087          
   1088          /**************************************************************************//**
   1089          \brief Obtain pointer to given element in ZCL structure
   1090          
   1091          \param[in] st - structure
   1092          \param[in] idx - index of element
   1093          \return pointer to element
   1094          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1095          static ZclStructureElement_t *zclObtainStructureElement(const ZclStructure_t *st, uint16_t idx)
   1096          {
   \                     zclObtainStructureElement: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1097            const uint8_t *p = (const uint8_t *)st->elements;
   \   00000004   0x1C85             ADDS     R5,R0,#+2
   1098          
   1099            // Note: index to the last element + 1 is valid and handy for calculating
   1100            // structure size. Greater indexes are invalid.
   1101            if (idx > st->cnt)
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x7842             LDRB     R2,[R0, #+1]
   \   0000000A   0x0612             LSLS     R2,R2,#+24
   \   0000000C   0x0C12             LSRS     R2,R2,#+16
   \   0000000E   0x4311             ORRS     R1,R1,R2
   \   00000010   0x42A1             CMP      R1,R4
   \   00000012   0xD20D             BCS      ??zclObtainStructureElement_0
   1102            {
   1103              SYS_E_ASSERT_ERROR(false, ZCL_UNBOUNDED_READ);
   \   00000014   0x....             LDR      R0,??DataTable6_1  ;; 0xc207
   \   00000016   0x....             LDR      R1,??DataTable6_2
   \   00000018   0x8008             STRH     R0,[R1, #+0]
   \   0000001A   0x.... 0x....      BL       SYS_DefAssertCallbackError
   1104              return NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
   1105            }
   1106          
   1107            while (idx--)
   1108            {
   1109              const ZclStructureElement_t *e = (const ZclStructureElement_t *)p;
   1110              const uint16_t len = sizeof(e->type) + ZCL_GetAttributeLength(e->type, e->value);
   1111              p += len;
   \                     ??zclObtainStructureElement_1: (+1)
   \   00000022   0x1C69             ADDS     R1,R5,#+1
   \   00000024   0x7828             LDRB     R0,[R5, #+0]
   \   00000026   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0x182D             ADDS     R5,R5,R0
   1112            }
   \                     ??zclObtainStructureElement_0: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x1E44             SUBS     R4,R0,#+1
   \   00000034   0x0400             LSLS     R0,R0,#+16
   \   00000036   0xD1F4             BNE      ??zclObtainStructureElement_1
   1113            return (ZclStructureElement_t *)p;
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1114          }
   1115          
   1116          /*************************************************************************//**
   1117            \brief  ZCL Data Type Descriptor get by Type Id function.
   1118                    Fills the ZCL Data Type Descriptor dased on ZCL Data Type Id
   1119            \param  Id - ZCL Data Type Id (unsigned 8-bit integer)
   1120            \param  value - pointer to variable of typeId, NULL means maximum possible
   1121                    size.
   1122            \param  descriptor - ZCL Data Type Descriptor being filled.
   1123            \return None.
   1124            \sa     ZCL_DataTypeDescriptor_t
   1125            \sa     ZCL_GetAttributeLength()
   1126          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1127          void ZCL_GetDataTypeDescriptor(uint8_t typeId, const uint8_t *value, ZCL_DataTypeDescriptor_t *descriptor)
   1128          {
   \                     ZCL_GetDataTypeDescriptor: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   1129            uint8_t kind = ZCL_DATA_TYPE_DISCRETE_KIND;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1130            uint16_t length = 0;
   1131          
   1132            if (!descriptor)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD100             BNE      .+4
   \   0000000E   0xE0A1             B        ??ZCL_GetDataTypeDescriptor_0
   1133              return;
   1134          
   1135            switch (typeId)
   \   00000010   0x0033             MOVS     R3,R6
   \   00000012   0x3B08             SUBS     R3,R3,#+8
   \   00000014   0xD058             BEQ      ??ZCL_GetDataTypeDescriptor_1
   \   00000016   0x1E5B             SUBS     R3,R3,#+1
   \   00000018   0xD059             BEQ      ??ZCL_GetDataTypeDescriptor_2
   \   0000001A   0x1E5B             SUBS     R3,R3,#+1
   \   0000001C   0xD05A             BEQ      ??ZCL_GetDataTypeDescriptor_3
   \   0000001E   0x1E5B             SUBS     R3,R3,#+1
   \   00000020   0xD05B             BEQ      ??ZCL_GetDataTypeDescriptor_4
   \   00000022   0x1E5B             SUBS     R3,R3,#+1
   \   00000024   0xD05C             BEQ      ??ZCL_GetDataTypeDescriptor_5
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0xD05D             BEQ      ??ZCL_GetDataTypeDescriptor_6
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
   \   0000002C   0xD05E             BEQ      ??ZCL_GetDataTypeDescriptor_7
   \   0000002E   0x1E5B             SUBS     R3,R3,#+1
   \   00000030   0xD05F             BEQ      ??ZCL_GetDataTypeDescriptor_8
   \   00000032   0x1E5B             SUBS     R3,R3,#+1
   \   00000034   0xD048             BEQ      ??ZCL_GetDataTypeDescriptor_1
   \   00000036   0x3B08             SUBS     R3,R3,#+8
   \   00000038   0xD046             BEQ      ??ZCL_GetDataTypeDescriptor_1
   \   0000003A   0x1E5B             SUBS     R3,R3,#+1
   \   0000003C   0xD047             BEQ      ??ZCL_GetDataTypeDescriptor_2
   \   0000003E   0x1E5B             SUBS     R3,R3,#+1
   \   00000040   0xD048             BEQ      ??ZCL_GetDataTypeDescriptor_3
   \   00000042   0x1E5B             SUBS     R3,R3,#+1
   \   00000044   0xD049             BEQ      ??ZCL_GetDataTypeDescriptor_4
   \   00000046   0x1E5B             SUBS     R3,R3,#+1
   \   00000048   0xD04A             BEQ      ??ZCL_GetDataTypeDescriptor_5
   \   0000004A   0x1E5B             SUBS     R3,R3,#+1
   \   0000004C   0xD04B             BEQ      ??ZCL_GetDataTypeDescriptor_6
   \   0000004E   0x1E5B             SUBS     R3,R3,#+1
   \   00000050   0xD04C             BEQ      ??ZCL_GetDataTypeDescriptor_7
   \   00000052   0x1E5B             SUBS     R3,R3,#+1
   \   00000054   0xD04D             BEQ      ??ZCL_GetDataTypeDescriptor_8
   \   00000056   0x1E5B             SUBS     R3,R3,#+1
   \   00000058   0xD035             BEQ      ??ZCL_GetDataTypeDescriptor_9
   \   0000005A   0x1E5B             SUBS     R3,R3,#+1
   \   0000005C   0xD036             BEQ      ??ZCL_GetDataTypeDescriptor_10
   \   0000005E   0x1E5B             SUBS     R3,R3,#+1
   \   00000060   0xD037             BEQ      ??ZCL_GetDataTypeDescriptor_11
   \   00000062   0x1E5B             SUBS     R3,R3,#+1
   \   00000064   0xD038             BEQ      ??ZCL_GetDataTypeDescriptor_12
   \   00000066   0x1E5B             SUBS     R3,R3,#+1
   \   00000068   0xD039             BEQ      ??ZCL_GetDataTypeDescriptor_13
   \   0000006A   0x1E5B             SUBS     R3,R3,#+1
   \   0000006C   0xD03A             BEQ      ??ZCL_GetDataTypeDescriptor_14
   \   0000006E   0x1E5B             SUBS     R3,R3,#+1
   \   00000070   0xD03B             BEQ      ??ZCL_GetDataTypeDescriptor_15
   \   00000072   0x1E5B             SUBS     R3,R3,#+1
   \   00000074   0xD03C             BEQ      ??ZCL_GetDataTypeDescriptor_16
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
   \   00000078   0xD025             BEQ      ??ZCL_GetDataTypeDescriptor_9
   \   0000007A   0x1E5B             SUBS     R3,R3,#+1
   \   0000007C   0xD026             BEQ      ??ZCL_GetDataTypeDescriptor_10
   \   0000007E   0x1E5B             SUBS     R3,R3,#+1
   \   00000080   0xD027             BEQ      ??ZCL_GetDataTypeDescriptor_11
   \   00000082   0x1E5B             SUBS     R3,R3,#+1
   \   00000084   0xD028             BEQ      ??ZCL_GetDataTypeDescriptor_12
   \   00000086   0x1E5B             SUBS     R3,R3,#+1
   \   00000088   0xD029             BEQ      ??ZCL_GetDataTypeDescriptor_13
   \   0000008A   0x1E5B             SUBS     R3,R3,#+1
   \   0000008C   0xD02A             BEQ      ??ZCL_GetDataTypeDescriptor_14
   \   0000008E   0x1E5B             SUBS     R3,R3,#+1
   \   00000090   0xD02B             BEQ      ??ZCL_GetDataTypeDescriptor_15
   \   00000092   0x1E5B             SUBS     R3,R3,#+1
   \   00000094   0xD02C             BEQ      ??ZCL_GetDataTypeDescriptor_16
   \   00000096   0x1E5B             SUBS     R3,R3,#+1
   \   00000098   0xD016             BEQ      ??ZCL_GetDataTypeDescriptor_1
   \   0000009A   0x1E5B             SUBS     R3,R3,#+1
   \   0000009C   0xD017             BEQ      ??ZCL_GetDataTypeDescriptor_2
   \   0000009E   0x3B10             SUBS     R3,R3,#+16
   \   000000A0   0x2B01             CMP      R3,#+1
   \   000000A2   0xD92A             BLS      ??ZCL_GetDataTypeDescriptor_17
   \   000000A4   0x1FDB             SUBS     R3,R3,#+7
   \   000000A6   0xD02F             BEQ      ??ZCL_GetDataTypeDescriptor_18
   \   000000A8   0x1F1B             SUBS     R3,R3,#+4
   \   000000AA   0xD03C             BEQ      ??ZCL_GetDataTypeDescriptor_19
   \   000000AC   0x1F1B             SUBS     R3,R3,#+4
   \   000000AE   0x2B01             CMP      R3,#+1
   \   000000B0   0xD92A             BLS      ??ZCL_GetDataTypeDescriptor_18
   \   000000B2   0x3B92             SUBS     R3,R3,#+146
   \   000000B4   0xD010             BEQ      ??ZCL_GetDataTypeDescriptor_12
   \   000000B6   0x1F9B             SUBS     R3,R3,#+6
   \   000000B8   0x2B01             CMP      R3,#+1
   \   000000BA   0xD908             BLS      ??ZCL_GetDataTypeDescriptor_2
   \   000000BC   0x3B08             SUBS     R3,R3,#+8
   \   000000BE   0xD018             BEQ      ??ZCL_GetDataTypeDescriptor_8
   \   000000C0   0x1E5B             SUBS     R3,R3,#+1
   \   000000C2   0xD018             BEQ      ??ZCL_GetDataTypeDescriptor_20
   \   000000C4   0xE03D             B        ??ZCL_GetDataTypeDescriptor_21
   1136            {
   1137              case ZCL_NO_DATA_TYPE_ID:
   1138                break;
   1139          
   1140              //General data
   1141              case ZCL_S8BIT_DATA_TYPE_ID:
   1142              case ZCL_U8BIT_DATA_TYPE_ID:
   1143                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_9: (+1)
   \   000000C6   0x2501             MOVS     R5,#+1
   1144              case ZCL_8BIT_DATA_TYPE_ID:
   1145              case ZCL_BOOLEAN_DATA_TYPE_ID:
   1146              case ZCL_8BIT_BITMAP_DATA_TYPE_ID:
   1147              case ZCL_8BIT_ENUM_DATA_TYPE_ID:
   1148                length = 1;
   \                     ??ZCL_GetDataTypeDescriptor_1: (+1)
   \   000000C8   0x2101             MOVS     R1,#+1
   1149                break;
   \   000000CA   0xE03F             B        ??ZCL_GetDataTypeDescriptor_22
   1150          
   1151              case ZCL_U16BIT_DATA_TYPE_ID:
   1152              case ZCL_S16BIT_DATA_TYPE_ID:
   1153                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_10: (+1)
   \   000000CC   0x2501             MOVS     R5,#+1
   1154              case ZCL_16BIT_DATA_TYPE_ID:
   1155              case ZCL_16BIT_BITMAP_DATA_TYPE_ID:
   1156              case ZCL_16BIT_ENUM_DATA_TYPE_ID:
   1157              case ZCL_CLUSTER_ID_DATA_TYPE_ID:
   1158              case ZCL_ATTRIBUTE_ID_DATA_TYPE_ID:
   1159                length = 2;
   \                     ??ZCL_GetDataTypeDescriptor_2: (+1)
   \   000000CE   0x2102             MOVS     R1,#+2
   1160                break;
   \   000000D0   0xE03C             B        ??ZCL_GetDataTypeDescriptor_22
   1161          
   1162              case ZCL_U24BIT_DATA_TYPE_ID:
   1163              case ZCL_S24BIT_DATA_TYPE_ID:
   1164                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_11: (+1)
   \   000000D2   0x2501             MOVS     R5,#+1
   1165              case ZCL_24BIT_DATA_TYPE_ID:
   1166              case ZCL_24BIT_BITMAP_DATA_TYPE_ID:
   1167                length = 3;
   \                     ??ZCL_GetDataTypeDescriptor_3: (+1)
   \   000000D4   0x2103             MOVS     R1,#+3
   1168                break;
   \   000000D6   0xE039             B        ??ZCL_GetDataTypeDescriptor_22
   1169          
   1170              case ZCL_U32BIT_DATA_TYPE_ID:
   1171              case ZCL_S32BIT_DATA_TYPE_ID:
   1172              case ZCL_UTC_TIME_DATA_TYPE_ID:
   1173                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_12: (+1)
   \   000000D8   0x2501             MOVS     R5,#+1
   1174              case ZCL_32BIT_DATA_TYPE_ID:
   1175              case ZCL_32BIT_BITMAP_DATA_TYPE_ID:
   1176                length = 4;
   \                     ??ZCL_GetDataTypeDescriptor_4: (+1)
   \   000000DA   0x2104             MOVS     R1,#+4
   1177                break;
   \   000000DC   0xE036             B        ??ZCL_GetDataTypeDescriptor_22
   1178          
   1179              case ZCL_U40BIT_DATA_TYPE_ID:
   1180              case ZCL_S40BIT_DATA_TYPE_ID:
   1181                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_13: (+1)
   \   000000DE   0x2501             MOVS     R5,#+1
   1182              case ZCL_40BIT_DATA_TYPE_ID:
   1183              case ZCL_40BIT_BITMAP_DATA_TYPE_ID:
   1184                length = 5;
   \                     ??ZCL_GetDataTypeDescriptor_5: (+1)
   \   000000E0   0x2105             MOVS     R1,#+5
   1185                break;
   \   000000E2   0xE033             B        ??ZCL_GetDataTypeDescriptor_22
   1186          
   1187              case ZCL_U48BIT_DATA_TYPE_ID:
   1188              case ZCL_S48BIT_DATA_TYPE_ID:
   1189                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_14: (+1)
   \   000000E4   0x2501             MOVS     R5,#+1
   1190              case ZCL_48BIT_DATA_TYPE_ID:
   1191              case ZCL_48BIT_BITMAP_DATA_TYPE_ID:
   1192                length = 6;
   \                     ??ZCL_GetDataTypeDescriptor_6: (+1)
   \   000000E6   0x2106             MOVS     R1,#+6
   1193                break;
   \   000000E8   0xE030             B        ??ZCL_GetDataTypeDescriptor_22
   1194          
   1195              case ZCL_U56BIT_DATA_TYPE_ID:
   1196              case ZCL_S56BIT_DATA_TYPE_ID:
   1197                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_15: (+1)
   \   000000EA   0x2501             MOVS     R5,#+1
   1198              case ZCL_56BIT_DATA_TYPE_ID:
   1199              case ZCL_56BIT_BITMAP_DATA_TYPE_ID:
   1200                length = 7;
   \                     ??ZCL_GetDataTypeDescriptor_7: (+1)
   \   000000EC   0x2107             MOVS     R1,#+7
   1201                break;
   \   000000EE   0xE02D             B        ??ZCL_GetDataTypeDescriptor_22
   1202          
   1203              case ZCL_U64BIT_DATA_TYPE_ID:
   1204              case ZCL_S64BIT_DATA_TYPE_ID:
   1205                kind = ZCL_DATA_TYPE_ANALOG_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_16: (+1)
   \   000000F0   0x2501             MOVS     R5,#+1
   1206              case ZCL_64BIT_DATA_TYPE_ID:
   1207              case ZCL_64BIT_BITMAP_DATA_TYPE_ID:
   1208              case ZCL_IEEE_ADDRESS_DATA_TYPE_ID:
   1209                length = 8;
   \                     ??ZCL_GetDataTypeDescriptor_8: (+1)
   \   000000F2   0x2108             MOVS     R1,#+8
   1210                break;
   \   000000F4   0xE02A             B        ??ZCL_GetDataTypeDescriptor_22
   1211          
   1212              case ZCL_128BIT_SECURITY_KEY_DATA_TYPE_ID:
   1213                length = 16;
   \                     ??ZCL_GetDataTypeDescriptor_20: (+1)
   \   000000F6   0x2110             MOVS     R1,#+16
   1214                break;
   \   000000F8   0xE028             B        ??ZCL_GetDataTypeDescriptor_22
   1215              case ZCL_OCTET_STRING_DATA_TYPE_ID:
   1216              case ZCL_CHARACTER_STRING_DATA_TYPE_ID:
   1217                if (NULL == value)
   \                     ??ZCL_GetDataTypeDescriptor_17: (+1)
   \   000000FA   0x2C00             CMP      R4,#+0
   \   000000FC   0xD101             BNE      ??ZCL_GetDataTypeDescriptor_23
   1218                  length = OCTET_STRING_MAX_SIZE;
   \   000000FE   0x21FF             MOVS     R1,#+255
   \   00000100   0xE024             B        ??ZCL_GetDataTypeDescriptor_22
   1219                else
   1220                  length = *value + sizeof(uint8_t);
   \                     ??ZCL_GetDataTypeDescriptor_23: (+1)
   \   00000102   0x7821             LDRB     R1,[R4, #+0]
   \   00000104   0x1C49             ADDS     R1,R1,#+1
   \   00000106   0xE01C             B        ??ZCL_GetDataTypeDescriptor_21
   1221                break;
   1222          
   1223              case ZCL_ARRAY_DATA_TYPE_ID:
   1224              case ZCL_SET_DATA_TYPE_ID:
   1225              case ZCL_BAG_DATA_TYPE_ID:
   1226                kind = ZCL_DATA_TYPE_STRUCTURED_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_18: (+1)
   \   00000108   0x2502             MOVS     R5,#+2
   1227                if (value)
   \   0000010A   0x2C00             CMP      R4,#+0
   \   0000010C   0xD01C             BEQ      ??ZCL_GetDataTypeDescriptor_24
   1228                {
   1229                  const ZclArraySetBag_t *p = (const ZclArraySetBag_t *)value;
   1230                  length =  SLICE_SIZE(ZclArraySetBag_t, type, cnt)
   1231                                      + p->cnt * ZCL_GetAttributeLength(p->type, p->elements);
   \   0000010E   0x1CE1             ADDS     R1,R4,#+3
   \   00000110   0x7820             LDRB     R0,[R4, #+0]
   \   00000112   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000116   0x7861             LDRB     R1,[R4, #+1]
   \   00000118   0x78A2             LDRB     R2,[R4, #+2]
   \   0000011A   0x0612             LSLS     R2,R2,#+24
   \   0000011C   0x0C12             LSRS     R2,R2,#+16
   \   0000011E   0x4311             ORRS     R1,R1,R2
   \   00000120   0x4341             MULS     R1,R0,R1
   \   00000122   0x1CC9             ADDS     R1,R1,#+3
   \   00000124   0xE00D             B        ??ZCL_GetDataTypeDescriptor_21
   1232                }
   1233                break;
   1234          
   1235              case ZCL_STRUCTURE_DATA_TYPE_ID:
   1236                kind = ZCL_DATA_TYPE_STRUCTURED_KIND;
   \                     ??ZCL_GetDataTypeDescriptor_19: (+1)
   \   00000126   0x2502             MOVS     R5,#+2
   1237                if (value)
   \   00000128   0x2C00             CMP      R4,#+0
   \   0000012A   0xD013             BEQ      ??ZCL_GetDataTypeDescriptor_0
   1238                {
   1239                  // Calculate length via obtaining pointer to the last+1 element (structures are indexed from 1 in ZCL)
   1240                  const ZclStructure_t *st = (const ZclStructure_t *)value;
   1241                  ZclStructureElement_t *elem = zclObtainStructureElement(st, st->cnt);
   \   0000012C   0x7821             LDRB     R1,[R4, #+0]
   \   0000012E   0x7860             LDRB     R0,[R4, #+1]
   \   00000130   0x0600             LSLS     R0,R0,#+24
   \   00000132   0x0C00             LSRS     R0,R0,#+16
   \   00000134   0x4301             ORRS     R1,R1,R0
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0x.... 0x....      BL       zclObtainStructureElement
   1242          
   1243                  if(!elem)
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD009             BEQ      ??ZCL_GetDataTypeDescriptor_0
   1244                    length = 0;
   1245                  else
   1246                    length = (const uint8_t *)elem - value;
   \   00000140   0x1B01             SUBS     R1,R0,R4
   1247                }
   1248                break;
   1249          
   1250              default:
   1251                SYS_E_ASSERT_WARN(false, UNKNOWN_DAT_TYPE_DESCR);
   1252                break;
   1253            }
   1254          
   1255            if ((0 != length) || (ZCL_NO_DATA_TYPE_ID == typeId))
   \                     ??ZCL_GetDataTypeDescriptor_21: (+1)
   \   00000142   0xB289             UXTH     R1,R1
   \   00000144   0x2900             CMP      R1,#+0
   \   00000146   0xD101             BNE      ??ZCL_GetDataTypeDescriptor_22
   \                     ??ZCL_GetDataTypeDescriptor_24: (+1)
   \   00000148   0x2E00             CMP      R6,#+0
   \   0000014A   0xD103             BNE      ??ZCL_GetDataTypeDescriptor_0
   1256            {
   1257              descriptor->length = length;
   \                     ??ZCL_GetDataTypeDescriptor_22: (+1)
   \   0000014C   0x9800             LDR      R0,[SP, #+0]
   \   0000014E   0x8001             STRH     R1,[R0, #+0]
   1258              descriptor->kind = kind;
   \   00000150   0x9800             LDR      R0,[SP, #+0]
   \   00000152   0x7085             STRB     R5,[R0, #+2]
   1259            }
   1260          }
   \                     ??ZCL_GetDataTypeDescriptor_0: (+1)
   \   00000154   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1261          
   1262          /*************************************************************************//**
   1263            \brief  ZCL Attribute Data Type length get function.
   1264                    Returns the ZCL Attribute Data Type length in bytes according to ZCL Data Type Id
   1265            \param  Id - ZCL Attribute Data Type Id (unsigned 8-bit integer)
   1266            \param  Value - Pointer to the value, NULL - means that the length will be
   1267                    the maximum size.
   1268            \return ZCL Attribute Data Type length in bytes.
   1269            \sa     ZCL_DataTypeDescriptor_t
   1270            \sa     ZCL_GetAttributeLength()
   1271          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1272          uint16_t ZCL_GetAttributeLength(uint8_t typeId, const uint8_t *value)
   1273          {
   \                     ZCL_GetAttributeLength: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1274            ZCL_DataTypeDescriptor_t descriptor;
   1275          
   1276            ZCL_GetDataTypeDescriptor(typeId, value, &descriptor);
   \   00000002   0x466A             MOV      R2,SP
   \   00000004   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
   1277          
   1278            return descriptor.length;
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
   1279          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     zclDataInd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     ??attributeNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x0000C207         DC32     0xc207

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     gAssertDbgCode
   1280          #endif // ZCL_SUPPORT == 1
   1281          //eof zclAttributes.c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ZCL_GetAttributeLength
         8   -> ZCL_GetDataTypeDescriptor
      24   ZCL_GetCluster
        24   -> ZCL_GetHeadCluster
        24   -> zclGetEndpoint
      24   ZCL_GetDataTypeDescriptor
        24   -> ZCL_GetAttributeLength
        24   -> zclObtainStructureElement
       0   ZCL_GetHeadCluster
       0   ZCL_GetNextCluster
      16   ZCL_ReadAttributeValue
        16   -> ZCL_GetAttributeLength
        16   -> zclGetAttribute
      16   ZCL_ReportOnChangeIfNeeded
        16   -> ZCL_GetDataTypeDescriptor
        16   -> zclReportOnChangeIfNeeded
      16   ZCL_SetReportableChange
        16   -> ZCL_GetAttributeLength
        16   -> __aeabi_memcpy
        16   -> zclGetAttribute
      24   ZCL_WriteAttributeValue
        24   -> zclWriteAttribute
      32   isOnChangeReportingNeeded
        32   -> ZCL_GetDataTypeDescriptor
        32   -> memcmp
        32   -> readSignedLE
        32   -> readUnsignedLE
       8   isReportingPermitted
         8   -> ZCL_GetAttributeLength
       8   jumpToNextAttribute
         8   -> ZCL_GetAttributeLength
      16   readSignedLE
        16   -> __aeabi_memcpy
        16   -> __aeabi_memset
      16   readUnsignedLE
        16   -> __aeabi_memcpy
      16   zclGetAttribute
        16   -> ZCL_GetCluster
        16   -> jumpToNextAttribute
      16   zclGetCommand
        16   -> ZCL_GetCluster
        16   -> zclGetCommandByCluster
      12   zclGetCommandByCluster
       8   zclGetEndpoint
         8   -> zclNextEndpoint
      16   zclGetNextAttribute
        16   -> ZCL_GetCluster
        16   -> jumpToNextAttribute
       0   zclGetNextCommand
      16   zclGetSecurityTypeByClusterId
        16   -> ZCL_GetCluster
       8   zclNextEndpoint
         8   -> APS_NextEndpoint
      16   zclObtainStructureElement
        16   -> SYS_DefAssertCallbackError
        16   -> ZCL_GetAttributeLength
      16   zclReadAttributeValueSafe
        16   -> ZCL_GetAttributeLength
        16   -> __aeabi_memcpy
        16   -> zclGetAttribute
      24   zclReadIndexedAttribute
        24   -> ZCL_GetAttributeLength
        24   -> __aeabi_memcpy
        24   -> zclGetAttribute
        24   -> zclObtainStructureElement
      24   zclRemoteWriteAttributeValue
        24   -> zclWriteAttribute
       8   zclReportOnChangeIfNeeded
         8   -> isOnChangeReportingNeeded
         8   -> isReportingPermitted
         8   -> zclStartReportTimer
      72   zclWriteAttribute
        72   -> SYS_PostEvent
        72   -> ZCL_GetDataTypeDescriptor
        72   -> __aeabi_memcpy
        72   -> readSignedLE
        72   -> readUnsignedLE
        72   -> zclGetAttribute
        72   -> zclReportOnChangeIfNeeded


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
      18  ?Subroutine0
      12  ?_0
       8  ?_1
       8  ?_2
      14  ZCL_GetAttributeLength
      74  ZCL_GetCluster
     342  ZCL_GetDataTypeDescriptor
      20  ZCL_GetHeadCluster
       4  ZCL_GetNextCluster
      62  ZCL_ReadAttributeValue
      34  ZCL_ReportOnChangeIfNeeded
      66  ZCL_SetReportableChange
       8  ZCL_WriteAttributeValue
      12  attributeNumber
          attributesAmount
          endpointSaved
          clusterIdSaved
          result
     252  isOnChangeReportingNeeded
      50  isReportingPermitted
      48  jumpToNextAttribute
      60  readSignedLE
      38  readUnsignedLE
      54  zclGetAttribute
      20  zclGetCommand
      48  zclGetCommandByCluster
      24  zclGetEndpoint
      92  zclGetNextAttribute
       4  zclGetNextCommand
      42  zclGetSecurityTypeByClusterId
      20  zclNextEndpoint
      60  zclObtainStructureElement
      62  zclReadAttributeValueSafe
     212  zclReadIndexedAttribute
       8  zclRemoteWriteAttributeValue
      48  zclReportOnChangeIfNeeded
     456  zclWriteAttribute

 
    12 bytes in section .bss
 2 288 bytes in section .text
 
 2 288 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
