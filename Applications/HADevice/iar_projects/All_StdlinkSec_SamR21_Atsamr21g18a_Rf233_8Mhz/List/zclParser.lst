###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:41:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclParser.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclParser.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\zclParser.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\zclParser.o
#
###############################################################################


   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void *SYS_ByteMemcpy(void *, void const *, uint16_t)
   \                     SYS_ByteMemcpy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0xE003             B        ??SYS_ByteMemcpy_0
   \                     ??SYS_ByteMemcpy_1: (+1)
   \   00000006   0x780C             LDRB     R4,[R1, #+0]
   \   00000008   0x701C             STRB     R4,[R3, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??SYS_ByteMemcpy_0: (+1)
   \   0000000E   0x0014             MOVS     R4,R2
   \   00000010   0x1E62             SUBS     R2,R4,#+1
   \   00000012   0x0424             LSLS     R4,R4,#+16
   \   00000014   0xD1F7             BNE      ??SYS_ByteMemcpy_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zclParser.c
      1          /************************************************************************//**
      2            \file zclParser.c
      3          
      4            \brief
      5              The ZCL Parser implementation
      6          
      7              The file implements the ZCL Parser
      8          
      9            \author
     10              Atmel Corporation: http://www.atmel.com \n
     11              Support email: avr@atmel.com
     12          
     13            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     14            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     15          
     16            \internal
     17              History:
     18              02.12.08 A. Potashov - Created.
     19          ******************************************************************************/
     20          #if ZCL_SUPPORT == 1
     21          
     22          /******************************************************************************
     23                             Includes section
     24          ******************************************************************************/
     25          #include <zclDbg.h>
     26          #include <sysUtils.h>
     27          #include <sysQueue.h>
     28          #include <zclTaskManager.h>
     29          #include <zclParser.h>

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t getDstClusterSideByIncommingCommandDirection(uint8_t)
   \                     getDstClusterSideByIncommingCommandDirection: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x4180             SBCS     R0,R0,R0
   \   00000004   0x0FC0             LSRS     R0,R0,#+31
   \   00000006   0x4770             BX       LR               ;; return
     30          #include <zcl.h>
     31          #include <zclInt.h>
     32          #include <zclMemoryManager.h>
     33          #include <zclAttributes.h>
     34          #include <sysAssert.h>
     35          
     36          /******************************************************************************
     37                             Definitions section
     38          ******************************************************************************/
     39          #define ZCL_DEFAULT_RESPONSE_PAYLOAD_SIZE   2
     40          
     41          //! Cluster Security Descriptor
     42          //! Defined the security type related to ClusterId
     43          /******************************************************************************
     44                             Types section
     45          ******************************************************************************/
     46          typedef struct
     47          {
     48            uint8_t dataIndAmount;
     49            QueueDescriptor_t dataIndQueue;
     50          } ZclParserMem_t;
     51          
     52          /******************************************************************************
     53                             Static functions prototypes section
     54          ******************************************************************************/
     55          static bool parseDataInd(APS_DataInd_t *ind);
     56          static void processDataInd(void);
     57          static void zclParserDataConf(APS_DataConf_t *conf);
     58          static void sendDefaultResponse(ZclAuxParseData_t *auxData);
     59          static void sendRelevantResponse(ZclFrameDescriptor_t *dsc, ZclMmBuffer_t *buf, APS_DataInd_t *ind, uint8_t cmd);
     60          static bool zclReceivedDefaultResponseHandler(ZclAuxParseData_t *auxParseData);
     61          static uint16_t formReadAttributesResponse(uint8_t *buf,
     62                                                    uint16_t maxsize,
     63                                                    const APS_DataInd_t *ind,
     64                                                    const ZclFrameDescriptor_t *reqFrame);
     65          static uint16_t formReadAttributesStructuredResponse(uint8_t *buf,
     66                                                              uint16_t maxsize,
     67                                                              const APS_DataInd_t *ind,
     68                                                              const ZclFrameDescriptor_t *reqFrame);
     69          static uint8_t formWriteAttributeResponse(ZCL_WriteAttributeResp_t *respRec,
     70                                                    const APS_DataInd_t *ind,
     71                                                    const ZclFrameDescriptor_t *frameDescriptor,
     72                                                    bool undivided);
     73          static uint8_t formDiscoverAttributesResponse(ZCL_DiscoverAttributesResp_t *resp,
     74                                                        const APS_DataInd_t *ind,
     75                                                        const ZclFrameDescriptor_t *frameDescriptor);
     76          static uint8_t formDiscoverCommandsReceivedResponse(ZCL_DiscoverCommandsReceivedResp_t *resp,
     77                                                        const APS_DataInd_t *ind,
     78                                                        const ZclFrameDescriptor_t *frameDescriptor);
     79          static uint8_t formDiscoverCommandsGeneratedResponse(ZCL_DiscoverCommandsGeneratedResp_t *resp,
     80                                                        const APS_DataInd_t *ind,
     81                                                        const ZclFrameDescriptor_t *frameDescriptor);
     82          static uint8_t formDiscoverAttributeExtendedsResponse(ZCL_DiscoverAttributesExtendedResp_t *resp,
     83                                                       const APS_DataInd_t *ind,
     84                                                       const ZclFrameDescriptor_t *frameDescriptor);
     85          static void formServerDataReq(ZclMmBuffer_t *buffer, APS_DataInd_t *ind);
     86          
     87          static bool zclDefaultResponseIsValid(ZclAuxParseData_t *auxData);
     88          static inline bool isDefaultResponse(ZclFrameDescriptor_t *frameDescriptor);
     89          static ZCL_Status_t validateIncomingCommand(const APS_DataInd_t *ind, const ZclFrameDescriptor_t *frameDescriptor);
     90          static ZCL_Request_t * zclFindAppropriateRequest(ZclAuxParseData_t *auxParseData);
     91          #if APP_ENABLE_CERTIFICATION_EXTENSION == 1
     92          static bool isSupportedManufacturerSpecCode(uint16_t  manufacturerCode);
     93          #endif // APP_ENABLE_CERTIFICATION_EXTENSION == 1
     94          
     95          /******************************************************************************
     96                             Static variables section
     97          ******************************************************************************/

   \                                 In section .bss, align 4
     98          static ZclParserMem_t parserMem;
   \                     parserMem:
   \   00000000                      DS8 8
     99          
    100          /******************************************************************************
    101                             Implementation section
    102          ******************************************************************************/
    103          /*************************************************************************//**
    104            \brief Reset parser queue and clear memory.
    105          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void zclParserInit(void)
    107          {
    108            memset(&parserMem, 0, sizeof(parserMem));
   \                     zclParserInit: (+1)
   \   00000000   0x....             LDR      R0,??DataTable4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xC006             STM      R0!,{R1,R2}
   \   00000008   0x3808             SUBS     R0,R0,#+8
    109            resetQueue(&parserMem.dataIndQueue);
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    110          }
   \   0000000C   0x4770             BX       LR               ;; return
    111          
    112          /**************************************************************************//**
    113          \brief Check incoming ZCL frame header and fill frame descriptor
    114          
    115          \param[out] frameDescriptor - frame descriptor
    116          \param[in] ind - data indication
    117          \return header size or 0 if error
    118          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    119          static uint8_t parseZclHeader(ZclFrameDescriptor_t *frameDescriptor, const APS_DataInd_t *ind)
    120          {
   \                     parseZclHeader: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    121            ZclFrameHeader_t *header = (ZclFrameHeader_t *) ind->asdu;
   \   00000006   0x6C6E             LDR      R6,[R5, #+68]
    122            uint8_t result = sizeof(ZclFrameHeader_t);
   \   00000008   0x2705             MOVS     R7,#+5
    123          
    124            //frame descriptor init
    125            memset(frameDescriptor, 0, sizeof(ZclFrameDescriptor_t));
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
    126          
    127            // frame type must be 00 or 01
    128            // reserved must have zero value
    129            // 0001.1101
    130            if (0x01 < (header->frameControl.uint8 & 0xe3))
   \   00000010   0x7831             LDRB     R1,[R6, #+0]
   \   00000012   0x20E3             MOVS     R0,#+227
   \   00000014   0x4008             ANDS     R0,R0,R1
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xDB01             BLT      ??parseZclHeader_0
    131              return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
    132          
    133            //parsing
    134            frameDescriptor->frameType            = header->frameControl.frameType;
   \                     ??parseZclHeader_0: (+1)
   \   0000001E   0x2203             MOVS     R2,#+3
   \   00000020   0x400A             ANDS     R2,R2,R1
   \   00000022   0x70A2             STRB     R2,[R4, #+2]
    135            frameDescriptor->manufacturerSpecific = header->frameControl.manufacturerSpecific;
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x7832             LDRB     R2,[R6, #+0]
   \   00000028   0x0892             LSRS     R2,R2,#+2
   \   0000002A   0x2301             MOVS     R3,#+1
   \   0000002C   0x4013             ANDS     R3,R3,R2
   \   0000002E   0x7163             STRB     R3,[R4, #+5]
    136            frameDescriptor->direction            = header->frameControl.direction;
   \   00000030   0x7832             LDRB     R2,[R6, #+0]
   \   00000032   0x08D2             LSRS     R2,R2,#+3
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0x4013             ANDS     R3,R3,R2
   \   00000038   0x70E3             STRB     R3,[R4, #+3]
    137            frameDescriptor->defaultResponse      = header->frameControl.defaultResponse;
   \   0000003A   0x7832             LDRB     R2,[R6, #+0]
   \   0000003C   0x0912             LSRS     R2,R2,#+4
   \   0000003E   0x4011             ANDS     R1,R1,R2
   \   00000040   0x7121             STRB     R1,[R4, #+4]
    138          
    139            if (ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC == frameDescriptor->manufacturerSpecific)
   \   00000042   0x7961             LDRB     R1,[R4, #+5]
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD102             BNE      ??parseZclHeader_1
    140            {
    141              header = (ZclFrameHeader_t *) (ind->asdu - sizeof(uint16_t));
   \   00000048   0x6C6E             LDR      R6,[R5, #+68]
   \   0000004A   0x1EB6             SUBS     R6,R6,#+2
    142              result -= sizeof(uint16_t);
   \   0000004C   0x2703             MOVS     R7,#+3
    143            }
    144            frameDescriptor->manufacturerCode = header->manufacturerCode;
   \                     ??parseZclHeader_1: (+1)
   \   0000004E   0x7870             LDRB     R0,[R6, #+1]
   \   00000050   0x78B1             LDRB     R1,[R6, #+2]
   \   00000052   0x0609             LSLS     R1,R1,#+24
   \   00000054   0x0C09             LSRS     R1,R1,#+16
   \   00000056   0x4308             ORRS     R0,R0,R1
   \   00000058   0x80E0             STRH     R0,[R4, #+6]
    145            frameDescriptor->sequenceNumber = header->sequenceNumber;
   \   0000005A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000005C   0x7220             STRB     R0,[R4, #+8]
    146            frameDescriptor->commandId = header->commandId;
   \   0000005E   0x7930             LDRB     R0,[R6, #+4]
   \   00000060   0x7260             STRB     R0,[R4, #+9]
    147          
    148            frameDescriptor->header                     = ind->asdu;
   \   00000062   0x6C68             LDR      R0,[R5, #+68]
   \   00000064   0x60E0             STR      R0,[R4, #+12]
    149            frameDescriptor->payload                    = ind->asdu + result;
   \   00000066   0x6C68             LDR      R0,[R5, #+68]
   \   00000068   0x19C0             ADDS     R0,R0,R7
   \   0000006A   0x6120             STR      R0,[R4, #+16]
    150          
    151            frameDescriptor->headerLength               = result;
   \   0000006C   0x7027             STRB     R7,[R4, #+0]
    152            frameDescriptor->payloadLength              = ind->asduLength - result;
   \   0000006E   0x3540             ADDS     R5,R5,#+64
   \   00000070   0x8828             LDRH     R0,[R5, #+0]
   \   00000072   0x1BC0             SUBS     R0,R0,R7
   \   00000074   0x7060             STRB     R0,[R4, #+1]
    153            return result;
   \   00000076   0x0038             MOVS     R0,R7
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    154          }
    155          
    156          /**************************************************************************//**
    157          \brief Form header in supplied ZCL frame
    158          
    159          \param[in, out] frameDescriptor - frame descriptor
    160          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          static void formZclHeader(ZclFrameDescriptor_t *frameDescriptor)
    162          {
   \                     formZclHeader: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    163            ZclFrameHeader_t *header = (ZclFrameHeader_t *) frameDescriptor->header;
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
    164          
    165            header->frameControl.uint8                  = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x700A             STRB     R2,[R1, #+0]
    166            header->frameControl.frameType              = frameDescriptor->frameType;
   \   00000008   0x2203             MOVS     R2,#+3
   \   0000000A   0x7884             LDRB     R4,[R0, #+2]
   \   0000000C   0x2303             MOVS     R3,#+3
   \   0000000E   0x4023             ANDS     R3,R3,R4
   \   00000010   0x700B             STRB     R3,[R1, #+0]
    167            header->frameControl.manufacturerSpecific   = frameDescriptor->manufacturerSpecific;
   \   00000012   0x24FB             MOVS     R4,#+251
   \   00000014   0x401C             ANDS     R4,R4,R3
   \   00000016   0x7943             LDRB     R3,[R0, #+5]
   \   00000018   0x009B             LSLS     R3,R3,#+2
   \   0000001A   0x2504             MOVS     R5,#+4
   \   0000001C   0x402B             ANDS     R3,R3,R5
   \   0000001E   0x4323             ORRS     R3,R3,R4
   \   00000020   0x700B             STRB     R3,[R1, #+0]
    168            header->frameControl.direction              = frameDescriptor->direction;
   \   00000022   0x24F7             MOVS     R4,#+247
   \   00000024   0x401C             ANDS     R4,R4,R3
   \   00000026   0x78C3             LDRB     R3,[R0, #+3]
   \   00000028   0x00DB             LSLS     R3,R3,#+3
   \   0000002A   0x2508             MOVS     R5,#+8
   \   0000002C   0x402B             ANDS     R3,R3,R5
   \   0000002E   0x4323             ORRS     R3,R3,R4
   \   00000030   0x700B             STRB     R3,[R1, #+0]
    169            header->frameControl.defaultResponse        = frameDescriptor->defaultResponse;
    170            header->frameControl.reserved               = 0;
   \   00000032   0x24EF             MOVS     R4,#+239
   \   00000034   0x401C             ANDS     R4,R4,R3
   \   00000036   0x7903             LDRB     R3,[R0, #+4]
   \   00000038   0x011B             LSLS     R3,R3,#+4
   \   0000003A   0x4323             ORRS     R3,R3,R4
   \   0000003C   0x06DB             LSLS     R3,R3,#+27
   \   0000003E   0x0EDB             LSRS     R3,R3,#+27
   \   00000040   0x700B             STRB     R3,[R1, #+0]
    171          
    172            assert_static(ZCL_FRAME_HEADER_SIZE == sizeof(ZclFrameHeader_t));
    173            frameDescriptor->headerLength               = sizeof(ZclFrameHeader_t);
   \   00000042   0x2305             MOVS     R3,#+5
   \   00000044   0x7003             STRB     R3,[R0, #+0]
    174          
    175            if (ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC == frameDescriptor->manufacturerSpecific)
   \   00000046   0x7943             LDRB     R3,[R0, #+5]
   \   00000048   0x2B00             CMP      R3,#+0
   \   0000004A   0xD103             BNE      ??formZclHeader_0
    176            {
    177              header = (ZclFrameHeader_t *) (frameDescriptor->header - sizeof(uint16_t));
   \   0000004C   0x68C1             LDR      R1,[R0, #+12]
   \   0000004E   0x1E89             SUBS     R1,R1,#+2
    178              frameDescriptor->headerLength -= sizeof(uint16_t);
   \   00000050   0x7002             STRB     R2,[R0, #+0]
   \   00000052   0xE003             B        ??formZclHeader_1
    179            }
    180            else
    181              header->manufacturerCode                  = frameDescriptor->manufacturerCode;
   \                     ??formZclHeader_0: (+1)
   \   00000054   0x88C2             LDRH     R2,[R0, #+6]
   \   00000056   0x704A             STRB     R2,[R1, #+1]
   \   00000058   0x0A12             LSRS     R2,R2,#+8
   \   0000005A   0x708A             STRB     R2,[R1, #+2]
    182            header->commandId                           = frameDescriptor->commandId;
   \                     ??formZclHeader_1: (+1)
   \   0000005C   0x7A42             LDRB     R2,[R0, #+9]
   \   0000005E   0x710A             STRB     R2,[R1, #+4]
    183            header->sequenceNumber                      = frameDescriptor->sequenceNumber;
   \   00000060   0x7A00             LDRB     R0,[R0, #+8]
   \   00000062   0x70C8             STRB     R0,[R1, #+3]
    184          }
   \   00000064   0xBD30             POP      {R4,R5,PC}       ;; return
    185          
    186          
    187          /**************************************************************************//**
    188          \brief Form server data request
    189          
    190          \param[out] buffer - memory buffer to form request in
    191          \param[in] ind - APS data indication with aux data to form request
    192          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    193          static void formServerDataReq(ZclMmBuffer_t *buffer, APS_DataInd_t *ind)
    194          {
   \                     formServerDataReq: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0x000C             MOVS     R4,R1
    195            // initialize APS_DataReq primitive
    196            buffer->primitive.apsDataReq.dstAddrMode = ind->srcAddrMode;
   \   00000006   0x3420             ADDS     R4,R4,#+32
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0x3530             ADDS     R5,R5,#+48
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
    197            if (APS_SHORT_ADDRESS == ind->srcAddrMode)
   \   00000010   0x7860             LDRB     R0,[R4, #+1]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD101             BNE      ??formServerDataReq_0
    198              buffer->primitive.apsDataReq.dstAddress.shortAddress = ind->srcAddress.shortAddress;
   \   00000016   0x8920             LDRH     R0,[R4, #+8]
   \   00000018   0x8128             STRH     R0,[R5, #+8]
    199            if (APS_EXT_ADDRESS == ind->srcAddrMode)
   \                     ??formServerDataReq_0: (+1)
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD105             BNE      ??formServerDataReq_1
    200              buffer->primitive.apsDataReq.dstAddress.extAddress = ind->srcAddress.extAddress;
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x3010             ADDS     R0,R0,#+16
   \   00000024   0xC803             LDM      R0,{R0,R1}
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0x3210             ADDS     R2,R2,#+16
   \   0000002A   0xC203             STM      R2!,{R0,R1}
    201            buffer->primitive.apsDataReq.srcEndpoint = ind->dstEndpoint;
   \                     ??formServerDataReq_1: (+1)
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x77A8             STRB     R0,[R5, #+30]
    202            buffer->primitive.apsDataReq.dstEndpoint = ind->srcEndpoint;
   \   00000030   0x7EA0             LDRB     R0,[R4, #+26]
   \   00000032   0x7628             STRB     R0,[R5, #+24]
    203            buffer->primitive.apsDataReq.clusterId = ind->clusterId;
   \   00000034   0x8BE0             LDRH     R0,[R4, #+30]
   \   00000036   0x83A8             STRH     R0,[R5, #+28]
    204            buffer->primitive.apsDataReq.profileId = ind->profileId;
   \   00000038   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000003A   0x8368             STRH     R0,[R5, #+26]
    205            buffer->primitive.apsDataReq.APS_DataConf = zclParserDataConf;
   \   0000003C   0x3358             ADDS     R3,R3,#+88
   \   0000003E   0x....             LDR      R0,??DataTable4_1
   \   00000040   0x6058             STR      R0,[R3, #+4]
    206          
    207            buffer->primitive.apsDataReq.txOptions.acknowledgedTransmission    = 1;
    208            buffer->primitive.apsDataReq.txOptions.doNotDecrypt                = 1;
    209            buffer->primitive.apsDataReq.txOptions.noRouteDiscovery            = 0;
   \   00000042   0x7818             LDRB     R0,[R3, #+0]
   \   00000044   0x0640             LSLS     R0,R0,#+25
   \   00000046   0x0E40             LSRS     R0,R0,#+25
   \   00000048   0x2124             MOVS     R1,#+36
   \   0000004A   0x4301             ORRS     R1,R1,R0
   \   0000004C   0x7019             STRB     R1,[R3, #+0]
    210            buffer->primitive.apsDataReq.radius                                = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x7058             STRB     R0,[R3, #+1]
    211            buffer->primitive.apsDataReq.asdu = buffer->frame + getZclAsduOffset();
   \   00000052   0x6918             LDR      R0,[R3, #+16]
   \   00000054   0x303B             ADDS     R0,R0,#+59
   \   00000056   0x6268             STR      R0,[R5, #+36]
    212          }
   \   00000058   0xBD30             POP      {R4,R5,PC}       ;; return
    213          
    214          /**************************************************************************//**
    215          \brief Callback on execution of server data request
    216          
    217          \param[in] conf - confirmation data
    218          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    219          static void zclParserDataConf(APS_DataConf_t *conf)
    220          {
   \                     zclParserDataConf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    221            zclMmFreeMem((ZclMmBuffer_t *)GET_PARENT_BY_FIELD(APS_DataReq_t, confirm, conf));
   \   00000002   0x3860             SUBS     R0,R0,#+96
   \   00000004   0x.... 0x....      BL       zclMmFreeMem
    222          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    223          
    224          /*************************************************************************//**
    225            \brief APS Data indication to ZCL layer
    226          
    227            \param[in] ind - buffer of data indication.
    228          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          void zclDataInd(APS_DataInd_t *ind)
    230          {
   \                     zclDataInd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    231            ZclMmBuffer_t *indBuffer;
    232            uint8_t bufferAmount;
    233            uint8_t bufferSize;
    234          
    235            CS_ReadParameter(CS_ZCL_MEMORY_BUFFERS_AMOUNT_ID, (void *)&bufferAmount);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0x208D             MOVS     R0,#+141
   \   0000000C   0x0040             LSLS     R0,R0,#+1        ;; #+282
   \   0000000E   0x.... 0x....      BL       CS_ReadParameter
    236            CS_ReadParameter(CS_ZCL_BUFFER_SIZE_ID, (void *)&bufferSize);
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0x301C             ADDS     R0,R0,#+28       ;; #+283
   \   00000018   0x.... 0x....      BL       CS_ReadParameter
    237            if ((bufferAmount - 1) > parserMem.dataIndAmount)
   \   0000001C   0x....             LDR      R0,??DataTable4_2
   \   0000001E   0x....             LDR      R6,??DataTable4
   \   00000020   0x7831             LDRB     R1,[R6, #+0]
   \   00000022   0x466A             MOV      R2,SP
   \   00000024   0x7852             LDRB     R2,[R2, #+1]
   \   00000026   0x1E52             SUBS     R2,R2,#+1
   \   00000028   0x4291             CMP      R1,R2
   \   0000002A   0xDA25             BGE      ??zclDataInd_0
    238            {
    239              if (ind->asduLength > bufferSize)
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0x2240             MOVS     R2,#+64
   \   00000032   0x5AA2             LDRH     R2,[R4, R2]
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xD201             BCS      ??zclDataInd_1
    240              {
    241                SYS_E_ASSERT_ERROR(false, ZCL_BUFFER_SIZE_IS_TOO_LOW);
   \   00000038   0x....             LDR      R1,??DataTable5  ;; 0xc302
   \   0000003A   0xE01F             B        ??zclDataInd_2
    242                return;
    243              }
    244              indBuffer = zclMmGetMem(ZCL_INPUT_DATA_BUFFER);
   \                     ??zclDataInd_1: (+1)
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x.... 0x....      BL       zclMmGetMem
   \   00000042   0x0005             MOVS     R5,R0
    245          
    246              if (indBuffer)
   \   00000044   0xD01D             BEQ      ??zclDataInd_3
    247              {
    248                SYS_BYTE_MEMCPY(&indBuffer->primitive.apsDataInd, ind, sizeof(APS_DataInd_t));
   \   00000046   0x2258             MOVS     R2,#+88
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0x.... 0x....      BL       SYS_ByteMemcpy
    249                SYS_BYTE_MEMCPY(indBuffer->frame + getZclAsduOffset(), ind->asdu, ind->asduLength);
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x5A22             LDRH     R2,[R4, R0]
   \   00000052   0x6C61             LDR      R1,[R4, #+68]
   \   00000054   0x6EA8             LDR      R0,[R5, #+104]
   \   00000056   0x303B             ADDS     R0,R0,#+59
   \   00000058   0x.... 0x....      BL       SYS_ByteMemcpy
    250                indBuffer->primitive.apsDataInd.asdu = indBuffer->frame + getZclAsduOffset();
   \   0000005C   0x6EA8             LDR      R0,[R5, #+104]
   \   0000005E   0x303B             ADDS     R0,R0,#+59
   \   00000060   0x6468             STR      R0,[R5, #+68]
    251                putQueueElem(&parserMem.dataIndQueue, &indBuffer->primitive.apsDataInd);
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x1D30             ADDS     R0,R6,#+4
   \   00000066   0x.... 0x....      BL       putQueueElem
    252                zclPostTask(ZCL_PARSER_TASK_ID);
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x.... 0x....      BL       zclPostTask
    253                parserMem.dataIndAmount++;
   \   00000070   0x7830             LDRB     R0,[R6, #+0]
   \   00000072   0x1C40             ADDS     R0,R0,#+1
   \   00000074   0x7030             STRB     R0,[R6, #+0]
    254              }
    255            }
    256            else
    257            {
    258              SYS_E_ASSERT_ERROR(false, ZCL_DATAIND_0);
    259              return;
    260            }
    261          }
   \   00000076   0xBD73             POP      {R0,R1,R4-R6,PC}
   \                     ??zclDataInd_0: (+1)
   \   00000078   0x21C3             MOVS     R1,#+195
   \   0000007A   0x0209             LSLS     R1,R1,#+8        ;; #+49920
   \                     ??zclDataInd_2: (+1)
   \   0000007C   0x8001             STRH     R1,[R0, #+0]
   \   0000007E   0x.... 0x....      BL       SYS_DefAssertCallbackError
   \                     ??zclDataInd_3: (+1)
   \   00000082   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    262          
    263          /**************************************************************************//**
    264          \brief ZCL task handler
    265          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          void zclParserTaskHandler(void)
    267          {
   \                     zclParserTaskHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    268            if (parserMem.dataIndAmount)
   \   00000002   0x....             LDR      R4,??DataTable4
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD016             BEQ      ??zclParserTaskHandler_0
    269              processDataInd();
   \   0000000A   0x6865             LDR      R5,[R4, #+4]
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD010             BEQ      ??zclParserTaskHandler_1
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       parseDataInd
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD008             BEQ      ??zclParserTaskHandler_2
   \   0000001A   0x1D20             ADDS     R0,R4,#+4
   \   0000001C   0x.... 0x....      BL       deleteHeadQueueElem
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       zclMmFreeMem
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
    270            if (parserMem.dataIndAmount)
   \                     ??zclParserTaskHandler_2: (+1)
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ      ??zclParserTaskHandler_0
    271              zclPostTask(ZCL_PARSER_TASK_ID);
   \                     ??zclParserTaskHandler_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       zclPostTask
    272          }
   \                     ??zclParserTaskHandler_0: (+1)
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    273          
    274          /**************************************************************************//**
    275          \brief Get length of single payload element
    276          
    277          \param[in] element - pointer to element
    278          \param[in] formRequest - true if function is used to calculate request payload
    279            length, false if function is used to calculate response payload length
    280          \return length
    281          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    282          static uint8_t getElementLength(const ZCL_NextElement_t *element, bool formRequest)
    283          {
   \                     getElementLength: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    284            uint8_t result;
    285            const uint8_t *payload = (formRequest ? element->content : element->payload);
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD102             BNE      ??getElementLength_1
   \   00000008   0x6843             LDR      R3,[R0, #+4]
   \   0000000A   0x244C             MOVS     R4,#+76
   \   0000000C   0xE001             B        ??getElementLength_2
   \                     ??getElementLength_1: (+1)
   \   0000000E   0x6883             LDR      R3,[R0, #+8]
   \   00000010   0x243A             MOVS     R4,#+58
    286          
    287            result = (formRequest ? ZCL_MAX_TX_ZSDU_SIZE : ZCL_MAX_RX_ZSDU_SIZE);
    288            result -= ZCL_FRAME_STANDARD_HEADER_SIZE;
    289          
    290            switch (element->id)
   \                     ??getElementLength_2: (+1)
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2816             CMP      R0,#+22
   \   00000016   0xD852             BHI      ??getElementLength_3
   \   00000018   0xA201             ADR      R2,??getElementLength_0
   \   0000001A   0x5C12             LDRB     R2,[R2, R0]
   \   0000001C   0x4497             ADD      PC,PC,R2
   \   0000001E   0xBF00             Nop      
   \                     ??getElementLength_0:
   \   00000020   0x90 0x20          DC8      0x90,0x20,0x32,0x9E
   \              0x32 0x9E    
   \   00000024   0x98 0x9E          DC8      0x98,0x9E,0x3E,0x9C
   \              0x3E 0x9C    
   \   00000028   0x98 0x64          DC8      0x98,0x64,0x32,0x9E
   \              0x32 0x9E    
   \   0000002C   0x98 0x98          DC8      0x98,0x98,0x18,0x9E
   \              0x18 0x9E    
   \   00000030   0x9E 0x90          DC8      0x9E,0x90,0x94,0x90
   \              0x94 0x90    
   \   00000034   0x94 0x98          DC8      0x94,0x98,0x9C,0x0
   \              0x9C 0x00    
    291            {
    292              case ZCL_READ_ATTRIBUTES_COMMAND_ID:
    293                result = sizeof(ZCL_ReadAttributeReq_t);
    294                break;
    295          
    296              case ZCL_READ_ATTRIBUTES_STRUCTURED_COMMAND_ID:
    297                {
    298                  const ZCL_ReadAttributesStructuredReq_t *req = (const ZCL_ReadAttributesStructuredReq_t *)payload;
    299                  result = SLICE_SIZE(ZCL_ReadAttributesStructuredReq_t, id, selector.indicator) +
    300                          req->selector.indicator * sizeof(req->selector.index);
   \                     ??getElementLength_4: (+1)
   \   00000038   0x7898             LDRB     R0,[R3, #+2]
   \   0000003A   0x0044             LSLS     R4,R0,#+1
   \   0000003C   0x1CE4             ADDS     R4,R4,#+3
    301                }
    302                break;
   \   0000003E   0xE03E             B        ??getElementLength_3
    303          
    304              case ZCL_READ_ATTRIBUTES_RESPONSE_COMMAND_ID:
    305                {
    306                  const ZCL_ReadAttributeResp_t *resp = (const ZCL_ReadAttributeResp_t *) payload;
    307                  if (ZCL_SUCCESS_STATUS == resp->status)
   \                     ??getElementLength_5: (+1)
   \   00000040   0x7898             LDRB     R0,[R3, #+2]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD138             BNE      ??getElementLength_6
    308                    result = SLICE_SIZE(ZCL_ReadAttributeResp_t, id, type) + ZCL_GetAttributeLength(resp->type, resp->value);
   \   00000046   0x1D19             ADDS     R1,R3,#+4
   \   00000048   0x78D8             LDRB     R0,[R3, #+3]
   \   0000004A   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000004E   0x1D04             ADDS     R4,R0,#+4
   \   00000050   0xE035             B        ??getElementLength_3
    309                  else
    310                    result = SLICE_SIZE(ZCL_ReadAttributeResp_t, id, status);
    311                }
    312                break;
    313          
    314              case ZCL_WRITE_ATTRIBUTES_COMMAND_ID:
    315                {
    316                  const ZCL_WriteAttributeReq_t *req = (const ZCL_WriteAttributeReq_t *) payload;
    317                  result = SLICE_SIZE(ZCL_WriteAttributeReq_t, id, type) + ZCL_GetAttributeLength(req->type, req->value);
    318                }
    319                break;
    320          
    321              case ZCL_WRITE_ATTRIBUTES_RESPONSE_COMMAND_ID:
    322                result = sizeof(ZCL_WriteAttributeResp_t);
    323                break;
    324          
    325              case ZCL_REPORT_ATTRIBUTES_COMMAND_ID:
    326                {
    327                  const ZCL_Report_t *rep = (const ZCL_Report_t*) payload;
    328                  result = SLICE_SIZE(ZCL_Report_t, id, type) + ZCL_GetAttributeLength(rep->type, rep->value);
   \                     ??getElementLength_7: (+1)
   \   00000052   0x1CD9             ADDS     R1,R3,#+3
   \   00000054   0x7898             LDRB     R0,[R3, #+2]
   \   00000056   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000005A   0x1CC4             ADDS     R4,R0,#+3
    329                }
    330                break;
   \   0000005C   0xE02F             B        ??getElementLength_3
    331          
    332              case ZCL_CONFIGURE_REPORTING_COMMAND_ID:
    333                {
    334                  const ZCL_ConfigureReportingReq_t *req = (const ZCL_ConfigureReportingReq_t *) payload;
    335                  if (ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT == req->direction)
   \                     ??getElementLength_8: (+1)
   \   0000005E   0x7818             LDRB     R0,[R3, #+0]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD101             BNE      ??getElementLength_9
    336                  {
    337                    // The timeout period field is included in the payload, and the attribute data type field,
    338                    // the minimum reporting interval field, the maximum reporting imterval field,
    339                    // reportable change field are omitted.
    340                    result = SLICE_SIZE(ZCL_ConfigureReportingReq_t, direction, timeoutPeriod);
   \   00000064   0x2405             MOVS     R4,#+5
   \   00000066   0xE02A             B        ??getElementLength_3
    341                  }
    342                  else
    343                  {
    344                    ZCL_DataTypeDescriptor_t descriptor;
    345                    //Attribute data type field, the minimum reporting interval field, the maximum reporting imterval field
    346                    //and reportable change field are included in frame payload. Timeout period field is omitted.
    347                    result = SLICE_SIZE(ZCL_ConfigureReportingReq_t, direction,  maxReportingInterval);
   \                     ??getElementLength_9: (+1)
   \   00000068   0x2408             MOVS     R4,#+8
    348                    ZCL_GetDataTypeDescriptor(req->attributeType, req->reportableChange, &descriptor);
   \   0000006A   0x466A             MOV      R2,SP
   \   0000006C   0x0019             MOVS     R1,R3
   \   0000006E   0x3108             ADDS     R1,R1,#+8
   \   00000070   0x78D8             LDRB     R0,[R3, #+3]
   \   00000072   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
    349                    if (ZCL_DATA_TYPE_ANALOG_KIND == descriptor.kind)
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x7881             LDRB     R1,[R0, #+2]
   \   0000007A   0x2901             CMP      R1,#+1
   \   0000007C   0xD11F             BNE      ??getElementLength_3
    350                      result += descriptor.length;
   \   0000007E   0x8804             LDRH     R4,[R0, #+0]
   \   00000080   0x3408             ADDS     R4,R4,#+8
   \   00000082   0xE01C             B        ??getElementLength_3
    351                  }
    352                }
    353                break;
    354          
    355              case ZCL_READ_REPORTING_CONFIGURATION_RESPONSE_COMMAND_ID:
    356                {
    357                  const ZCL_ReadReportingConfigurationResp_t *resp = (const ZCL_ReadReportingConfigurationResp_t *) payload;
    358                  if (resp->status != ZCL_SUCCESS_STATUS)
   \                     ??getElementLength_10: (+1)
   \   00000084   0x7818             LDRB     R0,[R3, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD119             BNE      ??getElementLength_3
    359                    break;
    360          
    361                  if (ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT == resp->direction)
   \   0000008A   0x7858             LDRB     R0,[R3, #+1]
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD101             BNE      ??getElementLength_11
    362                  {
    363                    // The timeout period field is included in the payload, and the attribute data type field,
    364                    // the minimum reporting interval field, the maximum reporting imterval field,
    365                    // reportable change field are omitted.
    366                    result = SLICE_SIZE(ZCL_ReadReportingConfigurationResp_t, status, timeoutPeriod);
   \   00000090   0x2406             MOVS     R4,#+6
   \   00000092   0xE014             B        ??getElementLength_3
    367                  }
    368                  else
    369                  {
    370                    ZCL_DataTypeDescriptor_t descriptor;
    371                    //Attribute data type field, the minimum reporting interval field, the maximum reporting imterval field
    372                    //and reportable change field are included in frame payload. Timeout period field is omitted.
    373                    result = SLICE_SIZE(ZCL_ReadReportingConfigurationResp_t, status, maxReportingInterval);
   \                     ??getElementLength_11: (+1)
   \   00000094   0x2409             MOVS     R4,#+9
    374                    ZCL_GetDataTypeDescriptor(resp->attributeType, resp->reportableChange, &descriptor);
   \   00000096   0x466A             MOV      R2,SP
   \   00000098   0x0019             MOVS     R1,R3
   \   0000009A   0x3109             ADDS     R1,R1,#+9
   \   0000009C   0x7918             LDRB     R0,[R3, #+4]
   \   0000009E   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
    375                    if (ZCL_DATA_TYPE_ANALOG_KIND == descriptor.kind)
   \   000000A2   0x4668             MOV      R0,SP
   \   000000A4   0x7881             LDRB     R1,[R0, #+2]
   \   000000A6   0x2901             CMP      R1,#+1
   \   000000A8   0xD109             BNE      ??getElementLength_3
    376                      result += descriptor.length;
   \   000000AA   0x8804             LDRH     R4,[R0, #+0]
   \   000000AC   0x3409             ADDS     R4,R4,#+9
   \   000000AE   0xE006             B        ??getElementLength_3
    377                  }
    378                }
    379                break;
    380          
    381              case ZCL_CONFIGURE_REPORTING_RESPONSE_COMMAND_ID:
    382                result = sizeof(ZCL_ConfigureReportingResp_t);
    383                break;
    384          
    385              case ZCL_READ_REPORTING_CONFIGURATION_COMMAND_ID:
    386                result = sizeof(ZCL_ReadReportingConfigurationReq_t);
    387                break;
    388          
    389              case ZCL_DISCOVER_ATTRIBUTES_COMMAND_ID:
    390                result = sizeof(ZCL_DiscoverAttributesReq_t);
    391                break;
    392          
    393              case ZCL_DISCOVER_ATTRIBUTES_RESPONSE_COMMAND_ID:
    394                result = sizeof(ZCL_DiscoverAttributesRespRec_t);
    395                break;
    396          
    397              case ZCL_DISCOVER_COMMANDS_RECEIVED_COMMAND_ID:
    398                result = sizeof(ZCL_DiscoverCommandsReceivedReq_t);
    399                break;
    400          
    401              case ZCL_DISCOVER_COMMANDS_RECEIVED_RESPONSE_COMMAND_ID:
    402                result = sizeof(ZCL_CommandId_t);
    403                break; 
    404          
    405              case ZCL_DISCOVER_COMMANDS_GENERATED_COMMAND_ID:
    406                result = sizeof(ZCL_DiscoverCommandsGeneratedReq_t);
   \                     ??getElementLength_12: (+1)
   \   000000B0   0x2402             MOVS     R4,#+2
    407                break;
   \   000000B2   0xE004             B        ??getElementLength_3
    408          
    409              case ZCL_DISCOVER_COMMANDS_GENERATED_RESPONSE_COMMAND_ID:
    410                result = sizeof(ZCL_CommandId_t);
   \                     ??getElementLength_13: (+1)
   \   000000B4   0x2401             MOVS     R4,#+1
    411                break;
   \   000000B6   0xE002             B        ??getElementLength_3
    412          
    413              case ZCL_DISCOVER_ATTRIBUTES_EXTENDED_COMMAND_ID:
    414                result = sizeof(ZCL_DiscoverAttributesExtendedReq_t);
   \                     ??getElementLength_6: (+1)
   \   000000B8   0x2403             MOVS     R4,#+3
    415                break;
   \   000000BA   0xE000             B        ??getElementLength_3
    416          
    417              case ZCL_DISCOVER_ATTRIBUTES_EXTENDED_RESPONSE_COMMAND_ID:
    418                result = sizeof(ZCL_DiscoverAttributesExtendedRespRec_t);
   \                     ??getElementLength_14: (+1)
   \   000000BC   0x2404             MOVS     R4,#+4
    419                break;
    420          
    421              default:
    422                break;
    423            }
    424            return result;
   \                     ??getElementLength_3: (+1)
   \   000000BE   0xB2E0             UXTB     R0,R4
   \   000000C0   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    425          }
    426          
    427          /**************************************************************************//**
    428          \brief Put element to payload
    429          
    430          \param[in] element - pointer to element
    431          \return status of operation
    432          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    433          ZCL_Status_t ZCL_PutNextElement(ZCL_NextElement_t *element)
    434          {
   \                     ZCL_PutNextElement: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
    435            ZCL_Status_t result = ZCL_SUCCESS_STATUS;
   \   00000004   0x2400             MOVS     R4,#+0
    436            uint8_t elementLength;
    437            uint16_t maxSize = ZCL_MAX_TX_ZSDU_SIZE;
    438            maxSize -= ZCL_FRAME_STANDARD_HEADER_SIZE;
    439          
    440            if (NULL == element)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE      ??ZCL_PutNextElement_0
    441            {
    442              result = ZCL_INVALID_PARAMETER_STATUS;
   \   0000000A   0x24FF             MOVS     R4,#+255
   \   0000000C   0xE014             B        ??ZCL_PutNextElement_1
    443            }
    444            else
    445            {
    446              elementLength = getElementLength(element, true);
   \                     ??ZCL_PutNextElement_0: (+1)
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x.... 0x....      BL       getElementLength
   \   00000014   0x0006             MOVS     R6,R0
    447              if (maxSize >= element->payloadLength + elementLength)
   \   00000016   0x7868             LDRB     R0,[R5, #+1]
   \   00000018   0x1980             ADDS     R0,R0,R6
   \   0000001A   0x283B             CMP      R0,#+59
   \   0000001C   0xDA0B             BGE      ??ZCL_PutNextElement_2
    448              {
    449                SYS_BYTE_MEMCPY(element->payload, element->content, elementLength);
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x68A9             LDR      R1,[R5, #+8]
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x.... 0x....      BL       SYS_ByteMemcpy
    450                element->payloadLength += elementLength;
   \   00000028   0x7868             LDRB     R0,[R5, #+1]
   \   0000002A   0x1980             ADDS     R0,R0,R6
   \   0000002C   0x7068             STRB     R0,[R5, #+1]
    451                element->payload += elementLength;
   \   0000002E   0x6868             LDR      R0,[R5, #+4]
   \   00000030   0x1980             ADDS     R0,R0,R6
   \   00000032   0x6068             STR      R0,[R5, #+4]
   \   00000034   0xE000             B        ??ZCL_PutNextElement_1
    452              }
    453              else
    454              {
    455                result = ZCL_END_PAYLOAD_REACHED_STATUS;
   \                     ??ZCL_PutNextElement_2: (+1)
   \   00000036   0x24FD             MOVS     R4,#+253
    456              }
    457            }
    458            return result;
   \                     ??ZCL_PutNextElement_1: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    459          }
    460          
    461          /**************************************************************************//**
    462          \brief Get next element from payload
    463          
    464          \param[in] element - pointer to element
    465          \return status of operation
    466          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    467          ZCL_Status_t ZCL_GetNextElement(ZCL_NextElement_t *element)
    468          {
   \                     ZCL_GetNextElement: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
    469            ZCL_Status_t result = ZCL_SUCCESS_STATUS;
   \   00000004   0x2400             MOVS     R4,#+0
    470            uint8_t elementLength;
    471          
    472            if (NULL == element || NULL == element->payload || 0 == element->payloadLength)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD005             BEQ      ??ZCL_GetNextElement_0
   \   0000000A   0x6868             LDR      R0,[R5, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ      ??ZCL_GetNextElement_0
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE      ??ZCL_GetNextElement_1
    473            {
    474              result = ZCL_INVALID_PARAMETER_STATUS;
   \                     ??ZCL_GetNextElement_0: (+1)
   \   00000016   0x24FF             MOVS     R4,#+255
   \   00000018   0xE01B             B        ??ZCL_GetNextElement_2
    475            }
    476            else
    477            {
    478              elementLength = getElementLength(element, false);
   \                     ??ZCL_GetNextElement_1: (+1)
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       getElementLength
   \   00000022   0x0006             MOVS     R6,R0
    479              if (elementLength <= element->payloadLength)
   \   00000024   0x7868             LDRB     R0,[R5, #+1]
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xDB12             BLT      ??ZCL_GetNextElement_3
    480              {
    481                if (NULL == element->content)
   \   0000002A   0x6869             LDR      R1,[R5, #+4]
   \   0000002C   0x68A8             LDR      R0,[R5, #+8]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD101             BNE      ??ZCL_GetNextElement_4
    482                  element->content = element->payload;
   \   00000032   0x60A9             STR      R1,[R5, #+8]
   \   00000034   0xE002             B        ??ZCL_GetNextElement_5
    483                else
    484                  SYS_BYTE_MEMCPY(element->content, element->payload, elementLength);
   \                     ??ZCL_GetNextElement_4: (+1)
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0x.... 0x....      BL       SYS_ByteMemcpy
    485                element->payloadLength -= elementLength;
   \                     ??ZCL_GetNextElement_5: (+1)
   \   0000003C   0x7868             LDRB     R0,[R5, #+1]
   \   0000003E   0x1B80             SUBS     R0,R0,R6
   \   00000040   0x7068             STRB     R0,[R5, #+1]
    486                element->payload += elementLength;
   \   00000042   0x6869             LDR      R1,[R5, #+4]
   \   00000044   0x1989             ADDS     R1,R1,R6
   \   00000046   0x6069             STR      R1,[R5, #+4]
    487                if (0 == element->payloadLength)
   \   00000048   0x0600             LSLS     R0,R0,#+24
   \   0000004A   0xD102             BNE      ??ZCL_GetNextElement_2
    488                  result = ZCL_END_PAYLOAD_REACHED_STATUS;
   \   0000004C   0x24FD             MOVS     R4,#+253
   \   0000004E   0xE000             B        ??ZCL_GetNextElement_2
    489              }
    490              else
    491                result = ZCL_INVALID_VALUE_STATUS;
   \                     ??ZCL_GetNextElement_3: (+1)
   \   00000050   0x2487             MOVS     R4,#+135
    492            }
    493            return result;
   \                     ??ZCL_GetNextElement_2: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    494          }
    495          
    496          /**************************************************************************//**
    497          \brief Form zcl header.
    498          
    499          \param[in] - dataReq - pointer to data request;
    500          \param[in] - reqType - type of the request;
    501          \param[in] - direction - cluster\server side;
    502          \param[in] - commandId - zcl command identification;
    503          \param[in] - defaultResponse - presence or absence of the default responde;
    504          \param[in] - manufacSpecCode - manufacturer specific code;
    505          \param[in] - sequenceNumber - next sequence number;
    506          \return header length
    507          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    508          uint8_t zclFormRequest(APS_DataReq_t *dataReq,
    509                                 uint8_t reqType,
    510                                 uint8_t direction,
    511                                 uint8_t commandId,
    512                                 uint8_t defaultResponse,
    513                                 uint16_t manufacSpecCode,
    514                                 uint8_t sequenceNumber)
    515          {
   \                     zclFormRequest: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    516            ZclFrameDescriptor_t frameDescriptor;
    517          
    518            //ZCL Frame Header
    519            memset(&frameDescriptor, 0, sizeof(ZclFrameDescriptor_t));
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    520          
    521            frameDescriptor.commandId            = commandId;
   \   00000012   0x466C             MOV      R4,SP
   \   00000014   0x7267             STRB     R7,[R4, #+9]
    522            frameDescriptor.frameType            = reqType;
   \   00000016   0x70A5             STRB     R5,[R4, #+2]
    523            frameDescriptor.direction            = direction;
   \   00000018   0x70E6             STRB     R6,[R4, #+3]
    524            frameDescriptor.defaultResponse      = defaultResponse;
   \   0000001A   0x980C             LDR      R0,[SP, #+48]
   \   0000001C   0x7120             STRB     R0,[R4, #+4]
   \   0000001E   0x980D             LDR      R0,[SP, #+52]
    525            frameDescriptor.manufacturerCode     = manufacSpecCode;
   \   00000020   0x80E0             STRH     R0,[R4, #+6]
    526            if (!manufacSpecCode)
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD000             BEQ      ??zclFormRequest_0
   \   00000026   0x2101             MOVS     R1,#+1
   \                     ??zclFormRequest_0: (+1)
   \   00000028   0x7161             STRB     R1,[R4, #+5]
    527              frameDescriptor.manufacturerSpecific = ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC;
    528            else
    529              frameDescriptor.manufacturerSpecific = ZCL_FRAME_CONTROL_MANUFACTURER_SPECIFIC;
    530          
    531          #if APP_ENABLE_CERTIFICATION_EXTENSION == 1
    532            if (0xFFFF == manufacSpecCode)
    533            {
    534              frameDescriptor.manufacturerCode     = 0x0000;
    535              frameDescriptor.manufacturerSpecific = ZCL_FRAME_CONTROL_MANUFACTURER_SPECIFIC;
    536            }
    537          #endif
    538          
    539            frameDescriptor.sequenceNumber       = sequenceNumber;
   \   0000002A   0x980E             LDR      R0,[SP, #+56]
   \   0000002C   0x7220             STRB     R0,[R4, #+8]
    540            frameDescriptor.header               = dataReq->asdu;
   \   0000002E   0x9806             LDR      R0,[SP, #+24]
   \   00000030   0x6D40             LDR      R0,[R0, #+84]
   \   00000032   0x9003             STR      R0,[SP, #+12]
    541            formZclHeader(&frameDescriptor);
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x.... 0x....      BL       formZclHeader
    542          
    543            return frameDescriptor.headerLength;
   \   0000003A   0x7820             LDRB     R0,[R4, #+0]
   \   0000003C   0xB007             ADD      SP,SP,#+28
   \   0000003E   0xBDF0             POP      {R4-R7,PC}       ;; return
    544          }
    545          
    546          /**************************************************************************//**
    547          \brief Forms response for write attribute command.
    548          
    549          \param[out] - respRec - pointer to formed write attribute response;
    550          \param[in]  - ind - pointer to received packet from APS layer;
    551          \param[in]  - frameDescriptor - descriptor of ZCL frame;
    552          \param[in]  - undivided - should write be atomic
    553          
    554          \return response length
    555          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    556          static uint8_t formWriteAttributeResponse(ZCL_WriteAttributeResp_t *respRec,
    557                                                    const APS_DataInd_t *ind,
    558                                                    const ZclFrameDescriptor_t *frameDescriptor,
    559                                                    bool undivided)
    560          {
   \                     formWriteAttributeResponse: (+1)
   \   00000000   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0007             MOVS     R7,R0
    561            uint8_t responseLength = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    562            Endpoint_t endpoint = ind->dstEndpoint;
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x3020             ADDS     R0,R0,#+32
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x7348             STRB     R0,[R1, #+13]
    563            ClusterId_t clusterId = ind->clusterId;
   \   00000012   0x9807             LDR      R0,[SP, #+28]
   \   00000014   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000016   0x81C8             STRH     R0,[R1, #+14]
    564            ZCL_WriteAttributeReq_t *writeAttributeReq = (ZCL_WriteAttributeReq_t *)frameDescriptor->payload;
   \   00000018   0x9808             LDR      R0,[SP, #+32]
   \   0000001A   0x6904             LDR      R4,[R0, #+16]
    565            uint8_t payloadLength = frameDescriptor->payloadLength;
   \   0000001C   0x7840             LDRB     R0,[R0, #+1]
   \   0000001E   0x9005             STR      R0,[SP, #+20]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ      ??formWriteAttributeResponse_0
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE000             B        ??formWriteAttributeResponse_1
   \                     ??formWriteAttributeResponse_0: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \                     ??formWriteAttributeResponse_1: (+1)
   \   0000002A   0x9004             STR      R0,[SP, #+16]
    566          
    567            // If "undivided" request received - write attributes only after successful checking.
    568            // 2-phase commit should be performed in this case.
    569            uint8_t phase = undivided ? 2 : 1;
    570            while (phase)
    571            {
    572              phase--;
   \                     ??formWriteAttributeResponse_2: (+1)
   \   0000002C   0x9804             LDR      R0,[SP, #+16]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0xB2C0             UXTB     R0,R0
   \   00000032   0x9004             STR      R0,[SP, #+16]
   \   00000034   0xE011             B        ??formWriteAttributeResponse_3
    573              while (payloadLength)
    574              {
    575                uint8_t recLen = ZCL_GetAttributeLength(writeAttributeReq->type, writeAttributeReq->value);
    576                recLen += sizeof(uint16_t) + sizeof(uint8_t);
    577          
    578                if (recLen > payloadLength)
    579                {
    580                  SYS_E_ASSERT_ERROR(false, ZCLPARSER_FORMWRITEATTRIBUTERESPONSE0);
    581                  return 0;
    582                }
    583          
    584                respRec->status = zclRemoteWriteAttributeValue(endpoint,
    585                                                               clusterId,
    586                                                               getOwnClusterSideByIncomingCommandDirection(frameDescriptor->direction),
    587                                                               writeAttributeReq->id,
    588                                                               writeAttributeReq->type,
    589                                                               writeAttributeReq->value,
    590                                                               phase);
    591          
    592                if (respRec->status)
    593                {
    594                  respRec->id = writeAttributeReq->id;
    595                  responseLength += sizeof(ZCL_WriteAttributeResp_t);
    596                  respRec++;
    597                  // Send response immediately, if error occured during checking phase
    598                  if (phase)
    599                    return responseLength;
    600                }
    601                // Indicate successfull writing
    602                else if (!phase)
   \                     ??formWriteAttributeResponse_4: (+1)
   \   00000036   0x9804             LDR      R0,[SP, #+16]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD109             BNE      ??formWriteAttributeResponse_5
    603                  zclAttributeEventInd(ind, frameDescriptor, ZCL_WRITE_ATTRIBUTE_EVENT, writeAttributeReq->id);
   \   0000003C   0x7823             LDRB     R3,[R4, #+0]
   \   0000003E   0x7860             LDRB     R0,[R4, #+1]
   \   00000040   0x0600             LSLS     R0,R0,#+24
   \   00000042   0x0C00             LSRS     R0,R0,#+16
   \   00000044   0x4303             ORRS     R3,R3,R0
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x9908             LDR      R1,[SP, #+32]
   \   0000004A   0x9807             LDR      R0,[SP, #+28]
   \   0000004C   0x.... 0x....      BL       zclAttributeEventInd
    604          
    605                writeAttributeReq = (ZCL_WriteAttributeReq_t *) (((uint8_t *) writeAttributeReq) + recLen);
   \                     ??formWriteAttributeResponse_5: (+1)
   \   00000050   0x1964             ADDS     R4,R4,R5
    606                payloadLength -= recLen;
   \   00000052   0x9805             LDR      R0,[SP, #+20]
   \   00000054   0x1B40             SUBS     R0,R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0x9005             STR      R0,[SP, #+20]
   \                     ??formWriteAttributeResponse_3: (+1)
   \   0000005A   0x9805             LDR      R0,[SP, #+20]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD03B             BEQ      ??formWriteAttributeResponse_6
   \   00000060   0x1CE1             ADDS     R1,R4,#+3
   \   00000062   0x78A0             LDRB     R0,[R4, #+2]
   \   00000064   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000068   0x1CC5             ADDS     R5,R0,#+3
   \   0000006A   0xB2ED             UXTB     R5,R5
   \   0000006C   0x9805             LDR      R0,[SP, #+20]
   \   0000006E   0x42A8             CMP      R0,R5
   \   00000070   0xDA07             BGE      ??formWriteAttributeResponse_7
   \   00000072   0x20C7             MOVS     R0,#+199
   \   00000074   0x0200             LSLS     R0,R0,#+8        ;; #+50944
   \   00000076   0x....             LDR      R1,??DataTable6
   \   00000078   0x8008             STRH     R0,[R1, #+0]
   \   0000007A   0x.... 0x....      BL       SYS_DefAssertCallbackError
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE037             B        ??formWriteAttributeResponse_8
   \                     ??formWriteAttributeResponse_7: (+1)
   \   00000082   0x9804             LDR      R0,[SP, #+16]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD000             BEQ      ??formWriteAttributeResponse_9
   \   00000088   0x2001             MOVS     R0,#+1
   \                     ??formWriteAttributeResponse_9: (+1)
   \   0000008A   0x9908             LDR      R1,[SP, #+32]
   \   0000008C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000008E   0x466A             MOV      R2,SP
   \   00000090   0x7311             STRB     R1,[R2, #+12]
   \   00000092   0x7823             LDRB     R3,[R4, #+0]
   \   00000094   0x7861             LDRB     R1,[R4, #+1]
   \   00000096   0x0609             LSLS     R1,R1,#+24
   \   00000098   0x0C09             LSRS     R1,R1,#+16
   \   0000009A   0x430B             ORRS     R3,R3,R1
   \   0000009C   0xB2C0             UXTB     R0,R0
   \   0000009E   0x9002             STR      R0,[SP, #+8]
   \   000000A0   0x1CE0             ADDS     R0,R4,#+3
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x78A0             LDRB     R0,[R4, #+2]
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x4668             MOV      R0,SP
   \   000000AA   0x7B02             LDRB     R2,[R0, #+12]
   \   000000AC   0x89C1             LDRH     R1,[R0, #+14]
   \   000000AE   0x7B40             LDRB     R0,[R0, #+13]
   \   000000B0   0x.... 0x....      BL       zclRemoteWriteAttributeValue
   \   000000B4   0x7038             STRB     R0,[R7, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD0BD             BEQ      ??formWriteAttributeResponse_4
   \   000000BA   0x7820             LDRB     R0,[R4, #+0]
   \   000000BC   0x7861             LDRB     R1,[R4, #+1]
   \   000000BE   0x0609             LSLS     R1,R1,#+24
   \   000000C0   0x0C09             LSRS     R1,R1,#+16
   \   000000C2   0x4308             ORRS     R0,R0,R1
   \   000000C4   0x7078             STRB     R0,[R7, #+1]
   \   000000C6   0x0A00             LSRS     R0,R0,#+8
   \   000000C8   0x70B8             STRB     R0,[R7, #+2]
   \   000000CA   0x1CF6             ADDS     R6,R6,#+3
   \   000000CC   0x1CFF             ADDS     R7,R7,#+3
   \   000000CE   0x9804             LDR      R0,[SP, #+16]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD0BD             BEQ      ??formWriteAttributeResponse_5
   \   000000D4   0xB2F0             UXTB     R0,R6
   \   000000D6   0xE00C             B        ??formWriteAttributeResponse_8
    607              }
    608              // Checking complete - start write phase
    609              writeAttributeReq = (ZCL_WriteAttributeReq_t *)frameDescriptor->payload;
   \                     ??formWriteAttributeResponse_6: (+1)
   \   000000D8   0x9808             LDR      R0,[SP, #+32]
   \   000000DA   0x6904             LDR      R4,[R0, #+16]
    610              payloadLength = frameDescriptor->payloadLength;
   \   000000DC   0x7840             LDRB     R0,[R0, #+1]
   \   000000DE   0x9005             STR      R0,[SP, #+20]
    611            }
   \   000000E0   0x9804             LDR      R0,[SP, #+16]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD1A2             BNE      ??formWriteAttributeResponse_2
    612            return (responseLength ? responseLength : 1);
   \   000000E6   0x0630             LSLS     R0,R6,#+24
   \   000000E8   0xD001             BEQ      ??formWriteAttributeResponse_10
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0xE000             B        ??formWriteAttributeResponse_11
   \                     ??formWriteAttributeResponse_10: (+1)
   \   000000EE   0x2001             MOVS     R0,#+1
   \                     ??formWriteAttributeResponse_11: (+1)
   \   000000F0   0xB2C0             UXTB     R0,R0
   \                     ??formWriteAttributeResponse_8: (+1)
   \   000000F2   0xB009             ADD      SP,SP,#+36
   \   000000F4   0xBDF0             POP      {R4-R7,PC}       ;; return
    613          }
    614          
    615          /**************************************************************************//**
    616          \brief Form response for read attribute command
    617          
    618          \param[out] buf - buffer to store response
    619          \param[in] maxsize - maximum buffer size
    620          \param[in] ind - pointer to packet from APS layer
    621          \param[in] reqFrame - descriptor of incoming ZCL frame
    622          \return response length
    623          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          static uint16_t formReadAttributesResponse(uint8_t *buf,
    625                                                    uint16_t maxsize,
    626                                                    const APS_DataInd_t *ind,
    627                                                    const ZclFrameDescriptor_t *reqFrame)
    628          {
   \                     formReadAttributesResponse: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x2600             MOVS     R6,#+0
    629            uint16_t respLen = 0;
    630          
    631            const ZCL_ReadAttributeReq_t *req = (ZCL_ReadAttributeReq_t *)reqFrame->payload;
   \   00000008   0x6918             LDR      R0,[R3, #+16]
   \   0000000A   0x9004             STR      R0,[SP, #+16]
    632          
    633            for (uint8_t reqLen = reqFrame->payloadLength; reqLen; reqLen -= sizeof(ZCL_ReadAttributeReq_t), req++)
   \   0000000C   0x9808             LDR      R0,[SP, #+32]
   \   0000000E   0x7847             LDRB     R7,[R0, #+1]
   \   00000010   0xE01C             B        ??formReadAttributesResponse_0
    634            {
    635              ZCL_ReadAttributeResp_t *outRec = (ZCL_ReadAttributeResp_t *)buf;
    636              uint8_t type = ZCL_NO_DATA_TYPE_ID;
    637              uint16_t recLen = 0;
    638          
    639              // At least id and status fields must fit to response
    640              if (respLen + SLICE_SIZE(ZCL_ReadAttributeResp_t, id, status) >= maxsize)
    641                break;
    642          
    643              // Ignore truncated request records
    644              if (reqLen < sizeof(ZCL_ReadAttributeReq_t))
    645              {
    646                SYS_E_ASSERT_ERROR(0, ZCLPARSER_FORMREADATTRIBUTERESPONSE0);
    647                return respLen;
    648              }
    649          
    650              outRec->id = req->id;
    651              // Ok, try to read attribute in a safe manner
    652              outRec->status = zclReadAttributeValueSafe(ind->dstEndpoint,
    653                                                         ind->clusterId,
    654                                                         getOwnClusterSideByIncomingCommandDirection(reqFrame->direction),
    655                                                         req->id,
    656                                                         &type,
    657                                                         outRec->value,
    658                                                         maxsize - respLen - sizeof(outRec->type)); // This much space is available for response
    659          
    660              // Ignore request if there is no space for response. Another attribute may fit though.
    661              // Use same slot in response.
    662              if (outRec->status == ZCL_INSUFFICIENT_SPACE_STATUS)
    663                continue;
    664          
    665              if (outRec->status == ZCL_UNSUPPORTED_ATTRIBUTE_STATUS)
    666              {
    667                // No such attribute. Omit type and value fields
    668                recLen = SLICE_SIZE(ZCL_ReadAttributeResp_t, id, status);
    669              }
    670              else
    671              {
    672                // Got attribute and copied it just fine
    673                outRec->type = type;
   \                     ??formReadAttributesResponse_1: (+1)
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x7B00             LDRB     R0,[R0, #+12]
   \   00000016   0x70E8             STRB     R0,[R5, #+3]
    674                recLen = SLICE_SIZE(ZCL_ReadAttributeResp_t, id, type) + ZCL_GetAttributeLength(type, outRec->value);
   \   00000018   0x1D29             ADDS     R1,R5,#+4
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000001E   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000022   0x1D04             ADDS     R4,R0,#+4
    675                zclAttributeEventInd(ind, reqFrame, ZCL_READ_ATTRIBUTE_EVENT, req->id);
   \   00000024   0x9804             LDR      R0,[SP, #+16]
   \   00000026   0x7803             LDRB     R3,[R0, #+0]
   \   00000028   0x7841             LDRB     R1,[R0, #+1]
   \   0000002A   0x0609             LSLS     R1,R1,#+24
   \   0000002C   0x0C09             LSRS     R1,R1,#+16
   \   0000002E   0x430B             ORRS     R3,R3,R1
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x9908             LDR      R1,[SP, #+32]
   \   00000034   0x9807             LDR      R0,[SP, #+28]
   \   00000036   0x.... 0x....      BL       zclAttributeEventInd
    676              }
    677          
    678              respLen += recLen;
   \                     ??formReadAttributesResponse_2: (+1)
   \   0000003A   0x1936             ADDS     R6,R6,R4
   \   0000003C   0xB2B6             UXTH     R6,R6
    679              buf += recLen;
   \   0000003E   0xB2A4             UXTH     R4,R4
   \   00000040   0x192D             ADDS     R5,R5,R4
   \                     ??formReadAttributesResponse_3: (+1)
   \   00000042   0x1EBF             SUBS     R7,R7,#+2
   \   00000044   0xB2FF             UXTB     R7,R7
   \   00000046   0x9804             LDR      R0,[SP, #+16]
   \   00000048   0x1C80             ADDS     R0,R0,#+2
   \   0000004A   0x9004             STR      R0,[SP, #+16]
   \                     ??formReadAttributesResponse_0: (+1)
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD036             BEQ      ??formReadAttributesResponse_4
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x7308             STRB     R0,[R1, #+12]
   \   00000056   0x1CF0             ADDS     R0,R6,#+3
   \   00000058   0x8B09             LDRH     R1,[R1, #+24]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD22F             BCS      ??formReadAttributesResponse_4
   \   0000005E   0x2F02             CMP      R7,#+2
   \   00000060   0xD205             BCS      ??formReadAttributesResponse_5
   \   00000062   0x....             LDR      R0,??DataTable6_1  ;; 0xc701
   \   00000064   0x....             LDR      R1,??DataTable6
   \   00000066   0x8008             STRH     R0,[R1, #+0]
   \   00000068   0x.... 0x....      BL       SYS_DefAssertCallbackError
   \   0000006C   0xE027             B        ??formReadAttributesResponse_4
   \                     ??formReadAttributesResponse_5: (+1)
   \   0000006E   0x9904             LDR      R1,[SP, #+16]
   \   00000070   0x7808             LDRB     R0,[R1, #+0]
   \   00000072   0x784A             LDRB     R2,[R1, #+1]
   \   00000074   0x0612             LSLS     R2,R2,#+24
   \   00000076   0x0C12             LSRS     R2,R2,#+16
   \   00000078   0x4310             ORRS     R0,R0,R2
   \   0000007A   0x7028             STRB     R0,[R5, #+0]
   \   0000007C   0x0A00             LSRS     R0,R0,#+8
   \   0000007E   0x7068             STRB     R0,[R5, #+1]
   \   00000080   0x9808             LDR      R0,[SP, #+32]
   \   00000082   0x78C2             LDRB     R2,[R0, #+3]
   \   00000084   0x9804             LDR      R0,[SP, #+16]
   \   00000086   0x7803             LDRB     R3,[R0, #+0]
   \   00000088   0x7841             LDRB     R1,[R0, #+1]
   \   0000008A   0x0609             LSLS     R1,R1,#+24
   \   0000008C   0x0C09             LSRS     R1,R1,#+16
   \   0000008E   0x430B             ORRS     R3,R3,R1
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x8B00             LDRH     R0,[R0, #+24]
   \   00000094   0x1B80             SUBS     R0,R0,R6
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0xB280             UXTH     R0,R0
   \   0000009A   0x9002             STR      R0,[SP, #+8]
   \   0000009C   0x1D28             ADDS     R0,R5,#+4
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0xA803             ADD      R0,SP,#+12
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x9807             LDR      R0,[SP, #+28]
   \   000000A6   0x8FC1             LDRH     R1,[R0, #+62]
   \   000000A8   0x3020             ADDS     R0,R0,#+32
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x.... 0x....      BL       zclReadAttributeValueSafe
   \   000000B0   0x70A8             STRB     R0,[R5, #+2]
   \   000000B2   0x2889             CMP      R0,#+137
   \   000000B4   0xD0C5             BEQ      ??formReadAttributesResponse_3
   \   000000B6   0x2886             CMP      R0,#+134
   \   000000B8   0xD1AB             BNE      ??formReadAttributesResponse_1
   \   000000BA   0x2403             MOVS     R4,#+3
   \   000000BC   0xE7BD             B        ??formReadAttributesResponse_2
    680            }
    681            return respLen;
   \                     ??formReadAttributesResponse_4: (+1)
   \   000000BE   0x0030             MOVS     R0,R6
   \   000000C0   0xB009             ADD      SP,SP,#+36
   \   000000C2   0xBDF0             POP      {R4-R7,PC}       ;; return
    682          }
    683          
    684          /**************************************************************************//**
    685          \brief Form response for read attribute structured command
    686          
    687          \param[out] buf - buffer to store response
    688          \param[in] maxsize - maximum buffer size
    689          \param[in] ind - pointer to packet from APS layer
    690          \param[in] reqFrame - descriptor of incoming ZCL frame
    691          \return response length
    692          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    693          static uint16_t formReadAttributesStructuredResponse(uint8_t *buf,
    694                                                              uint16_t maxsize,
    695                                                              const APS_DataInd_t *ind,
    696                                                              const ZclFrameDescriptor_t *reqFrame)
    697          {
   \                     formReadAttributesStructuredResponse: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x2600             MOVS     R6,#+0
    698            uint16_t respLen = 0;
    699            const uint8_t *reqPayload = reqFrame->payload;
   \   00000008   0x691F             LDR      R7,[R3, #+16]
    700            int16_t reqLen = reqFrame->payloadLength;
   \   0000000A   0x7858             LDRB     R0,[R3, #+1]
   \   0000000C   0xE01E             B        ??formReadAttributesStructuredResponse_0
    701          
    702            while (reqLen > 0)
    703            {
    704              const ZCL_ReadAttributesStructuredReq_t *req = (const ZCL_ReadAttributesStructuredReq_t *)reqPayload;
    705              ZCL_ReadAttributeResp_t *outRec = (ZCL_ReadAttributeResp_t *)buf;
    706              uint8_t type = ZCL_NO_DATA_TYPE_ID;
    707              uint16_t reqItemLen;
    708          
    709              // At least id and status fields must fit to response
    710              if (respLen + SLICE_SIZE(ZCL_ReadAttributeResp_t, id, status) >= maxsize)
    711                break;
    712          
    713              outRec->id = req->id;
    714              outRec->status = zclReadIndexedAttribute(&req->selector,
    715                                                       ind->dstEndpoint,
    716                                                       ind->clusterId,
    717                                                       getOwnClusterSideByIncomingCommandDirection(reqFrame->direction),
    718                                                       req->id,
    719                                                       &type,
    720                                                       outRec->value,
    721                                                       maxsize - respLen - sizeof(outRec->type)); // This much space is available for response
    722          
    723              if (outRec->status != ZCL_INSUFFICIENT_SPACE_STATUS)
    724              {
    725                uint16_t recLen;
    726                if (outRec->status != ZCL_SUCCESS_STATUS)
    727                {
    728                  // Fail. Omit type and value fields
    729                  recLen = SLICE_SIZE(ZCL_ReadAttributeResp_t, id, status);
    730                }
    731                else
    732                {
    733                  // Got attribute and copied it just fine
    734                  outRec->type = type;
   \                     ??formReadAttributesStructuredResponse_1: (+1)
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x7C00             LDRB     R0,[R0, #+16]
   \   00000012   0x70E8             STRB     R0,[R5, #+3]
    735                  recLen = SLICE_SIZE(ZCL_ReadAttributeResp_t, id, type) + ZCL_GetAttributeLength(type, outRec->value);
   \   00000014   0x1D29             ADDS     R1,R5,#+4
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x7C00             LDRB     R0,[R0, #+16]
   \   0000001A   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   0000001E   0x1D04             ADDS     R4,R0,#+4
    736                  zclAttributeEventInd(ind, reqFrame, ZCL_READ_ATTRIBUTE_EVENT, req->id);
   \   00000020   0x783B             LDRB     R3,[R7, #+0]
   \   00000022   0x7878             LDRB     R0,[R7, #+1]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0x0C00             LSRS     R0,R0,#+16
   \   00000028   0x4303             ORRS     R3,R3,R0
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x9908             LDR      R1,[SP, #+32]
   \   0000002E   0x9807             LDR      R0,[SP, #+28]
   \   00000030   0x.... 0x....      BL       zclAttributeEventInd
    737                }
    738                respLen += recLen;
   \                     ??formReadAttributesStructuredResponse_2: (+1)
   \   00000034   0x1936             ADDS     R6,R6,R4
   \   00000036   0xB2B6             UXTH     R6,R6
    739                buf += recLen;
   \   00000038   0xB2A4             UXTH     R4,R4
   \   0000003A   0x192D             ADDS     R5,R5,R4
    740              }
    741              // Advance to the next attribute item in request
    742              reqItemLen = SLICE_SIZE(ZCL_ReadAttributesStructuredReq_t, id, selector.indicator) +
    743                        req->selector.indicator * sizeof(req->selector.index);
   \                     ??formReadAttributesStructuredResponse_3: (+1)
   \   0000003C   0x78B8             LDRB     R0,[R7, #+2]
   \   0000003E   0x0040             LSLS     R0,R0,#+1
   \   00000040   0x1CC0             ADDS     R0,R0,#+3
   \   00000042   0xB280             UXTH     R0,R0
    744              reqPayload += reqItemLen;
   \   00000044   0x183F             ADDS     R7,R7,R0
    745              reqLen -= reqItemLen;
   \   00000046   0x9905             LDR      R1,[SP, #+20]
   \   00000048   0x1A08             SUBS     R0,R1,R0
   \   0000004A   0xB200             SXTH     R0,R0
   \                     ??formReadAttributesStructuredResponse_0: (+1)
   \   0000004C   0x9005             STR      R0,[SP, #+20]
   \   0000004E   0x9805             LDR      R0,[SP, #+20]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xDB2E             BLT      ??formReadAttributesStructuredResponse_4
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x7408             STRB     R0,[R1, #+16]
   \   0000005A   0x1CF0             ADDS     R0,R6,#+3
   \   0000005C   0x8B09             LDRH     R1,[R1, #+24]
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD227             BCS      ??formReadAttributesStructuredResponse_4
   \   00000062   0x7838             LDRB     R0,[R7, #+0]
   \   00000064   0x7879             LDRB     R1,[R7, #+1]
   \   00000066   0x0609             LSLS     R1,R1,#+24
   \   00000068   0x0C09             LSRS     R1,R1,#+16
   \   0000006A   0x4308             ORRS     R0,R0,R1
   \   0000006C   0x7028             STRB     R0,[R5, #+0]
   \   0000006E   0x0A00             LSRS     R0,R0,#+8
   \   00000070   0x7068             STRB     R0,[R5, #+1]
   \   00000072   0x9808             LDR      R0,[SP, #+32]
   \   00000074   0x78C3             LDRB     R3,[R0, #+3]
   \   00000076   0x7839             LDRB     R1,[R7, #+0]
   \   00000078   0x7878             LDRB     R0,[R7, #+1]
   \   0000007A   0x0600             LSLS     R0,R0,#+24
   \   0000007C   0x0C00             LSRS     R0,R0,#+16
   \   0000007E   0x4301             ORRS     R1,R1,R0
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x8B00             LDRH     R0,[R0, #+24]
   \   00000084   0x1B80             SUBS     R0,R0,R6
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0xB280             UXTH     R0,R0
   \   0000008A   0x9003             STR      R0,[SP, #+12]
   \   0000008C   0x1D28             ADDS     R0,R5,#+4
   \   0000008E   0x9002             STR      R0,[SP, #+8]
   \   00000090   0xA804             ADD      R0,SP,#+16
   \   00000092   0x9001             STR      R0,[SP, #+4]
   \   00000094   0x9100             STR      R1,[SP, #+0]
   \   00000096   0x9807             LDR      R0,[SP, #+28]
   \   00000098   0x8FC2             LDRH     R2,[R0, #+62]
   \   0000009A   0x3020             ADDS     R0,R0,#+32
   \   0000009C   0x7801             LDRB     R1,[R0, #+0]
   \   0000009E   0x1CB8             ADDS     R0,R7,#+2
   \   000000A0   0x.... 0x....      BL       zclReadIndexedAttribute
   \   000000A4   0x70A8             STRB     R0,[R5, #+2]
   \   000000A6   0x2889             CMP      R0,#+137
   \   000000A8   0xD0C8             BEQ      ??formReadAttributesStructuredResponse_3
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD0AF             BEQ      ??formReadAttributesStructuredResponse_1
   \   000000AE   0x2403             MOVS     R4,#+3
   \   000000B0   0xE7C0             B        ??formReadAttributesStructuredResponse_2
    746            }
    747            return respLen;
   \                     ??formReadAttributesStructuredResponse_4: (+1)
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0xB009             ADD      SP,SP,#+36
   \   000000B6   0xBDF0             POP      {R4-R7,PC}       ;; return
    748          }
    749          
    750          /**************************************************************************//**
    751          \brief Form response for discover attributes command
    752          
    753          \param[out] resp - pointer to buffer for creating response
    754          \param[in] ind - pointer to packet from APS layer
    755          \param[in] frameDescriptor - descriptor of the incoming frame
    756          
    757          \return response length
    758          ******************************************************************************/
    759          static uint8_t formDiscoverAttributesResponse(ZCL_DiscoverAttributesResp_t *resp,
    760                                                       const APS_DataInd_t *ind,
    761                                                       const ZclFrameDescriptor_t *frameDescriptor)
    762          {
    763            uint8_t result = 0;
    764            const Endpoint_t endpoint = ind->dstEndpoint;
    765            const ClusterId_t clusterId = ind->clusterId;
    766            ZclAttribute_t *attributeDescriptor = NULL;
    767            ZCL_DiscoverAttributesRespRec_t *rec = resp->attributeInfo;
    768            uint8_t counter = 0;
    769            ZCL_DiscoverAttributesReq_t *req = (ZCL_DiscoverAttributesReq_t *)frameDescriptor->payload;
    770          
    771            if (sizeof(ZCL_DiscoverAttributesReq_t) == frameDescriptor->payloadLength)
    772            {
    773              result = sizeof(uint8_t) /*discoveryComplete*/;
    774              resp->discoveryComplete = 0;
    775          
    776              do
    777              {
    778                attributeDescriptor = zclGetNextAttribute(endpoint,
    779                                                          clusterId,
    780                                                          getOwnClusterSideByIncomingCommandDirection(frameDescriptor->direction),
    781                                                          attributeDescriptor);
    782                if (NULL == attributeDescriptor)
    783                {
    784                  resp->discoveryComplete = 1;
    785                }
    786                else
    787                {
    788                  if ((attributeDescriptor->id >= req->startAttributeId) &&
    789                      (counter < req->maxAttributeIds))
    790                  {
    791                    rec->attributeId = attributeDescriptor->id;
    792                    rec->typeId = attributeDescriptor->type;
    793                    result += sizeof(ZCL_DiscoverAttributesRespRec_t);
    794                    rec++;
    795                    counter++;
    796                  }
    797                }
    798              }
    799              while (NULL != attributeDescriptor);
    800            }
    801          
    802            return result;
    803          }
    804          
    805          /**************************************************************************//**
    806          \brief Form response for discover commands received command
    807          
    808          \param[out] resp - pointer to buffer for creating response
    809          \param[in] ind - pointer to packet from APS layer
    810          \param[in] frameDescriptor - descriptor of the incoming frame
    811          
    812          \return response length
    813          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    814          static uint8_t formDiscoverCommandsReceivedResponse(ZCL_DiscoverCommandsReceivedResp_t *resp,
    815                                                       const APS_DataInd_t *ind,
    816                                                       const ZclFrameDescriptor_t *frameDescriptor)
    817          {
   \                     formDiscoverCommandsReceivedResponse: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0015             MOVS     R5,R2
    818            uint8_t result = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    819            const Endpoint_t endpoint = ind->dstEndpoint;
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x5C08             LDRB     R0,[R1, R0]
    820            const ClusterId_t clusterId = ind->clusterId;
   \   0000000E   0x8FC9             LDRH     R1,[R1, #+62]
    821            ZCL_Cluster_t *cluster;
    822            ZclCommand_t  *command;
    823            uint8_t clusterCount = 0;
    824            uint8_t counter = 0;
   \   00000010   0x2400             MOVS     R4,#+0
    825            uint8_t clusterSide = getOwnClusterSideByIncomingCommandDirection(frameDescriptor->direction);
   \   00000012   0x78EA             LDRB     R2,[R5, #+3]
   \   00000014   0x9201             STR      R2,[SP, #+4]
    826          
    827            ZCL_DiscoverCommandsReceivedReq_t *req = (ZCL_DiscoverCommandsReceivedReq_t *)frameDescriptor->payload;
   \   00000016   0x692A             LDR      R2,[R5, #+16]
   \   00000018   0x9200             STR      R2,[SP, #+0]
    828          
    829            cluster = ZCL_GetCluster(endpoint,
    830                                     clusterId,
    831                                     clusterSide);
   \   0000001A   0x9A01             LDR      R2,[SP, #+4]
   \   0000001C   0xB2D2             UXTB     R2,R2
   \   0000001E   0x.... 0x....      BL       ZCL_GetCluster
    832          
    833            if (sizeof(ZCL_DiscoverCommandsReceivedReq_t) == frameDescriptor->payloadLength)
   \   00000022   0x7869             LDRB     R1,[R5, #+1]
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD12C             BNE      ??formDiscoverCommandsReceivedResponse_0
    834            {
    835              result = sizeof(uint8_t) /*discoveryComplete*/;
   \   00000028   0x2501             MOVS     R5,#+1
   \   0000002A   0x2701             MOVS     R7,#+1
    836              resp->discoveryComplete = 0;
   \   0000002C   0x9902             LDR      R1,[SP, #+8]
   \   0000002E   0x700E             STRB     R6,[R1, #+0]
    837          
    838              if (NULL == cluster)
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD024             BEQ      ??formDiscoverCommandsReceivedResponse_1
    839              {
    840                resp->discoveryComplete = 1;
    841              }
    842              else
    843              {
    844                clusterCount =  cluster->commandsAmount;
   \   00000034   0x7A06             LDRB     R6,[R0, #+8]
    845                command = (ZclCommand_t*)cluster->commands;
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
    846                do
    847                {
    848                   if ((command->id >= req->startCommandId) &&
    849                        (counter < req->maxCommandIds) && clusterSide == command->options.direction)
   \                     ??formDiscoverCommandsReceivedResponse_2: (+1)
   \   00000038   0x7801             LDRB     R1,[R0, #+0]
   \   0000003A   0x9A00             LDR      R2,[SP, #+0]
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xD310             BCC      ??formDiscoverCommandsReceivedResponse_3
   \   00000042   0x9A00             LDR      R2,[SP, #+0]
   \   00000044   0x7852             LDRB     R2,[R2, #+1]
   \   00000046   0x4294             CMP      R4,R2
   \   00000048   0xDA0C             BGE      ??formDiscoverCommandsReceivedResponse_3
   \   0000004A   0x9B01             LDR      R3,[SP, #+4]
   \   0000004C   0x469C             MOV      R12,R3
   \   0000004E   0x7843             LDRB     R3,[R0, #+1]
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x401A             ANDS     R2,R2,R3
   \   00000054   0x4594             CMP      R12,R2
   \   00000056   0xD105             BNE      ??formDiscoverCommandsReceivedResponse_3
    850                    {
    851                      resp->commandIds[counter] = ((ZclCommand_t*)command)->id ;
   \   00000058   0x9A02             LDR      R2,[SP, #+8]
   \   0000005A   0x1912             ADDS     R2,R2,R4
   \   0000005C   0x7051             STRB     R1,[R2, #+1]
    852                      result += sizeof(uint8_t);/*size of each command Id included*/
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
    853                      counter++;
   \   00000060   0x1C64             ADDS     R4,R4,#+1
   \   00000062   0xB2E4             UXTB     R4,R4
    854                    }
    855          
    856                  command = zclGetNextCommand(command);
   \                     ??formDiscoverCommandsReceivedResponse_3: (+1)
   \   00000064   0x.... 0x....      BL       zclGetNextCommand
    857                  clusterCount--;
   \   00000068   0x1E76             SUBS     R6,R6,#+1
    858          
    859                  if (counter == req->maxCommandIds)
   \   0000006A   0x9900             LDR      R1,[SP, #+0]
   \   0000006C   0x7849             LDRB     R1,[R1, #+1]
   \   0000006E   0x428C             CMP      R4,R1
   \   00000070   0xD003             BEQ      ??formDiscoverCommandsReceivedResponse_4
    860                    break;
    861          
    862                } while (clusterCount);
   \   00000072   0xB2F6             UXTB     R6,R6
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD1DF             BNE      ??formDiscoverCommandsReceivedResponse_2
   \   00000078   0xE001             B        ??formDiscoverCommandsReceivedResponse_1
    863                
    864                if (!clusterCount)
   \                     ??formDiscoverCommandsReceivedResponse_4: (+1)
   \   0000007A   0x0636             LSLS     R6,R6,#+24
   \   0000007C   0xD101             BNE      ??formDiscoverCommandsReceivedResponse_0
    865                  resp->discoveryComplete = 1;
   \                     ??formDiscoverCommandsReceivedResponse_1: (+1)
   \   0000007E   0x9802             LDR      R0,[SP, #+8]
   \   00000080   0x7005             STRB     R5,[R0, #+0]
    866              }
    867            }
    868            return result;
   \                     ??formDiscoverCommandsReceivedResponse_0: (+1)
   \   00000082   0xB2F8             UXTB     R0,R7
   \   00000084   0xBDFE             POP      {R1-R7,PC}       ;; return
    869          }
    870          /**************************************************************************//**
    871          \brief Form response for discover commands generated command
    872          
    873          \param[out] resp - pointer to buffer for creating response
    874          \param[in] ind - pointer to packet from APS layer
    875          \param[in] frameDescriptor - descriptor of the incoming frame
    876          
    877          \return response length
    878          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    879          static uint8_t formDiscoverCommandsGeneratedResponse(ZCL_DiscoverCommandsGeneratedResp_t *resp,
    880                                                        const APS_DataInd_t *ind,
    881                                                        const ZclFrameDescriptor_t *frameDescriptor)
    882          {
   \                     formDiscoverCommandsGeneratedResponse: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0015             MOVS     R5,R2
    883            uint8_t result = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    884            const Endpoint_t endpoint = ind->dstEndpoint;
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x5C08             LDRB     R0,[R1, R0]
    885            const ClusterId_t clusterId = ind->clusterId;
   \   0000000E   0x8FC9             LDRH     R1,[R1, #+62]
    886            ZCL_Cluster_t *cluster;
    887            ZclCommand_t  *command;
    888            uint8_t clusterCount = 0;
    889            uint8_t counter = 0;
   \   00000010   0x2400             MOVS     R4,#+0
    890            ZCL_DiscoverCommandsGeneratedReq_t *req = (ZCL_DiscoverCommandsGeneratedReq_t *)frameDescriptor->payload;
   \   00000012   0x692A             LDR      R2,[R5, #+16]
   \   00000014   0x9200             STR      R2,[SP, #+0]
    891            uint8_t clusterSide = getOwnClusterSideByIncomingCommandDirection(frameDescriptor->direction);
   \   00000016   0x78EA             LDRB     R2,[R5, #+3]
   \   00000018   0x9201             STR      R2,[SP, #+4]
    892          
    893            cluster = ZCL_GetCluster(endpoint,
    894                                     clusterId,
    895                                     clusterSide);
   \   0000001A   0x.... 0x....      BL       ZCL_GetCluster
    896          
    897            if (sizeof(ZCL_DiscoverCommandsGeneratedReq_t) == frameDescriptor->payloadLength)
   \   0000001E   0x7869             LDRB     R1,[R5, #+1]
   \   00000020   0x2902             CMP      R1,#+2
   \   00000022   0xD12F             BNE      ??formDiscoverCommandsGeneratedResponse_0
    898            {
    899              result = sizeof(uint8_t) /*discoveryComplete*/;
   \   00000024   0x2501             MOVS     R5,#+1
   \   00000026   0x2701             MOVS     R7,#+1
    900              resp->discoveryComplete = 0;
   \   00000028   0x9902             LDR      R1,[SP, #+8]
   \   0000002A   0x700E             STRB     R6,[R1, #+0]
    901          
    902              if (NULL == cluster)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD027             BEQ      ??formDiscoverCommandsGeneratedResponse_1
    903              {
    904                resp->discoveryComplete = 1;
    905              }
    906              else
    907              {
    908                clusterCount =  cluster->commandsAmount;
   \   00000030   0x7A06             LDRB     R6,[R0, #+8]
    909                command = (ZclCommand_t*)cluster->commands;
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
    910                do
    911                {
    912                   if ((command->id >= req->startCommandId) &&
    913                        (counter < req->maxCommandIds) && (!clusterSide == command->options.direction))
   \                     ??formDiscoverCommandsGeneratedResponse_2: (+1)
   \   00000034   0x7801             LDRB     R1,[R0, #+0]
   \   00000036   0x9A00             LDR      R2,[SP, #+0]
   \   00000038   0x7812             LDRB     R2,[R2, #+0]
   \   0000003A   0x4291             CMP      R1,R2
   \   0000003C   0xD313             BCC      ??formDiscoverCommandsGeneratedResponse_3
   \   0000003E   0x9A00             LDR      R2,[SP, #+0]
   \   00000040   0x7852             LDRB     R2,[R2, #+1]
   \   00000042   0x4294             CMP      R4,R2
   \   00000044   0xDA0F             BGE      ??formDiscoverCommandsGeneratedResponse_3
   \   00000046   0x9A01             LDR      R2,[SP, #+4]
   \   00000048   0x1E52             SUBS     R2,R2,#+1
   \   0000004A   0x4192             SBCS     R2,R2,R2
   \   0000004C   0x0FD2             LSRS     R2,R2,#+31
   \   0000004E   0x4694             MOV      R12,R2
   \   00000050   0x7842             LDRB     R2,[R0, #+1]
   \   00000052   0x07D3             LSLS     R3,R2,#+31
   \   00000054   0x0FDB             LSRS     R3,R3,#+31
   \   00000056   0x459C             CMP      R12,R3
   \   00000058   0xD105             BNE      ??formDiscoverCommandsGeneratedResponse_3
    914                    {
    915                      resp->commandIds[counter] = ((ZclCommand_t*)command)->id ;
   \   0000005A   0x9A02             LDR      R2,[SP, #+8]
   \   0000005C   0x1912             ADDS     R2,R2,R4
   \   0000005E   0x7051             STRB     R1,[R2, #+1]
    916                      result += sizeof(uint8_t);/*size of each command Id included*/
   \   00000060   0x1C7F             ADDS     R7,R7,#+1
    917                      counter++;
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xB2E4             UXTB     R4,R4
    918                    }
    919          
    920                  command = zclGetNextCommand(command);
   \                     ??formDiscoverCommandsGeneratedResponse_3: (+1)
   \   00000066   0x.... 0x....      BL       zclGetNextCommand
    921                  clusterCount--;
   \   0000006A   0x1E76             SUBS     R6,R6,#+1
    922          
    923                  if (counter == req->maxCommandIds)
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0x7849             LDRB     R1,[R1, #+1]
   \   00000070   0x428C             CMP      R4,R1
   \   00000072   0xD003             BEQ      ??formDiscoverCommandsGeneratedResponse_4
    924                    break;
    925          
    926                } while (clusterCount);
   \   00000074   0xB2F6             UXTB     R6,R6
   \   00000076   0x2E00             CMP      R6,#+0
   \   00000078   0xD1DC             BNE      ??formDiscoverCommandsGeneratedResponse_2
   \   0000007A   0xE001             B        ??formDiscoverCommandsGeneratedResponse_1
    927          
    928                if (!clusterCount)
   \                     ??formDiscoverCommandsGeneratedResponse_4: (+1)
   \   0000007C   0x0636             LSLS     R6,R6,#+24
   \   0000007E   0xD101             BNE      ??formDiscoverCommandsGeneratedResponse_0
    929                  resp->discoveryComplete = 1;
   \                     ??formDiscoverCommandsGeneratedResponse_1: (+1)
   \   00000080   0x9802             LDR      R0,[SP, #+8]
   \   00000082   0x7005             STRB     R5,[R0, #+0]
    930              }
    931            }
    932            return result;
   \                     ??formDiscoverCommandsGeneratedResponse_0: (+1)
   \   00000084   0xB2F8             UXTB     R0,R7
   \   00000086   0xBDFE             POP      {R1-R7,PC}       ;; return
    933          }
    934          
    935          /**************************************************************************//**
    936          \brief Form response for discover attributes extended command
    937          
    938          \param[out] resp - pointer to buffer for creating response
    939          \param[in] ind - pointer to packet from APS layer
    940          \param[in] frameDescriptor - descriptor of the incoming frame
    941          
    942          \return response length
    943          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    944          static uint8_t formDiscoverAttributeExtendedsResponse(ZCL_DiscoverAttributesExtendedResp_t *resp,
    945                                                       const APS_DataInd_t *ind,
    946                                                       const ZclFrameDescriptor_t *frameDescriptor)
    947          {
   \                     formDiscoverAttributeExtendedsResponse: (+1)
   \   00000000   0xB5F5             PUSH     {R0,R2,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    948            uint8_t result = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2700             MOVS     R7,#+0
    949            const Endpoint_t endpoint = ind->dstEndpoint;
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2320             MOVS     R3,#+32
   \   0000000C   0x5CCB             LDRB     R3,[R1, R3]
   \   0000000E   0x7183             STRB     R3,[R0, #+6]
    950            const ClusterId_t clusterId = ind->clusterId;
   \   00000010   0x8FC9             LDRH     R1,[R1, #+62]
   \   00000012   0x8081             STRH     R1,[R0, #+4]
    951            ZclAttribute_t *attributeDescriptor = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
    952            ZCL_DiscoverAttributesExtendedRespRec_t *rec = resp->attributeInfo;
   \   00000016   0x9C03             LDR      R4,[SP, #+12]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
    953            uint8_t counter = 0;
   \   0000001A   0x2500             MOVS     R5,#+0
    954            ZCL_DiscoverAttributesExtendedReq_t *req = (ZCL_DiscoverAttributesExtendedReq_t *)frameDescriptor->payload;
   \   0000001C   0x9904             LDR      R1,[SP, #+16]
   \   0000001E   0x6909             LDR      R1,[R1, #+16]
   \   00000020   0x9102             STR      R1,[SP, #+8]
    955          
    956            if (sizeof(ZCL_DiscoverAttributesExtendedReq_t) == frameDescriptor->payloadLength)
   \   00000022   0x9904             LDR      R1,[SP, #+16]
   \   00000024   0x7849             LDRB     R1,[R1, #+1]
   \   00000026   0x2903             CMP      R1,#+3
   \   00000028   0xD152             BNE      ??formDiscoverAttributeExtendedsResponse_0
    957            {
    958              result = sizeof(uint8_t) /*discoveryComplete*/;
   \   0000002A   0x2601             MOVS     R6,#+1
   \   0000002C   0x2701             MOVS     R7,#+1
    959              resp->discoveryComplete = 0;
   \   0000002E   0x9903             LDR      R1,[SP, #+12]
   \   00000030   0x700A             STRB     R2,[R1, #+0]
   \   00000032   0xE022             B        ??formDiscoverAttributeExtendedsResponse_1
    960          
    961              do
    962              {
    963                attributeDescriptor = zclGetNextAttribute(endpoint,
    964                                                          clusterId,
    965                                                          getOwnClusterSideByIncomingCommandDirection(frameDescriptor->direction),
    966                                                          attributeDescriptor);
    967                if (NULL == attributeDescriptor)
    968                {
    969                  resp->discoveryComplete = 1;
    970                }
    971                else
    972                {
    973                  if ((attributeDescriptor->id >= req->startAttributeId) &&
    974                      (counter < req->maxAttributeIds))
    975                  {
    976                    rec->attributeId = attributeDescriptor->id;
   \                     ??formDiscoverAttributeExtendedsResponse_2: (+1)
   \   00000034   0x7801             LDRB     R1,[R0, #+0]
   \   00000036   0x7842             LDRB     R2,[R0, #+1]
   \   00000038   0x0612             LSLS     R2,R2,#+24
   \   0000003A   0x0C12             LSRS     R2,R2,#+16
   \   0000003C   0x4311             ORRS     R1,R1,R2
   \   0000003E   0x7021             STRB     R1,[R4, #+0]
   \   00000040   0x0A09             LSRS     R1,R1,#+8
   \   00000042   0x7061             STRB     R1,[R4, #+1]
    977                    rec->typeId = attributeDescriptor->type;
   \   00000044   0x7881             LDRB     R1,[R0, #+2]
   \   00000046   0x70A1             STRB     R1,[R4, #+2]
    978                    rec->accessCtrrl.readable = 1;
   \   00000048   0x78E1             LDRB     R1,[R4, #+3]
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x430A             ORRS     R2,R2,R1
   \   0000004E   0x70E2             STRB     R2,[R4, #+3]
    979                    rec->accessCtrrl.writeable = (uint8_t)(attributeDescriptor->properties & ZCL_READONLY_ATTRIBUTE)? 0U : 1U;
   \   00000050   0x21FD             MOVS     R1,#+253
   \   00000052   0x4011             ANDS     R1,R1,R2
   \   00000054   0x78C3             LDRB     R3,[R0, #+3]
   \   00000056   0x079A             LSLS     R2,R3,#+30
   \   00000058   0x0FD2             LSRS     R2,R2,#+31
   \   0000005A   0x2301             MOVS     R3,#+1
   \   0000005C   0x4053             EORS     R3,R3,R2
   \   0000005E   0x005A             LSLS     R2,R3,#+1
   \   00000060   0x430A             ORRS     R2,R2,R1
   \   00000062   0x70E2             STRB     R2,[R4, #+3]
    980                    rec->accessCtrrl.reportable = (uint8_t)(attributeDescriptor->properties & ZCL_REPORTABLE_ATTRIBUTE)? 1U: 0U;
   \   00000064   0x21FB             MOVS     R1,#+251
   \   00000066   0x4011             ANDS     R1,R1,R2
   \   00000068   0x78C2             LDRB     R2,[R0, #+3]
   \   0000006A   0x2301             MOVS     R3,#+1
   \   0000006C   0x4013             ANDS     R3,R3,R2
   \   0000006E   0x009A             LSLS     R2,R3,#+2
   \   00000070   0x430A             ORRS     R2,R2,R1
   \   00000072   0x70E2             STRB     R2,[R4, #+3]
    981                    result += sizeof(ZCL_DiscoverAttributesExtendedRespRec_t);
   \   00000074   0x1D3F             ADDS     R7,R7,#+4
    982                    rec++;
   \   00000076   0x1D24             ADDS     R4,R4,#+4
    983                    counter++;
   \   00000078   0x1C6D             ADDS     R5,R5,#+1
    984                  }
   \                     ??formDiscoverAttributeExtendedsResponse_1: (+1)
   \   0000007A   0x0003             MOVS     R3,R0
   \   0000007C   0x9804             LDR      R0,[SP, #+16]
   \   0000007E   0x78C2             LDRB     R2,[R0, #+3]
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x8881             LDRH     R1,[R0, #+4]
   \   00000084   0x7980             LDRB     R0,[R0, #+6]
   \   00000086   0x.... 0x....      BL       zclGetNextAttribute
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD102             BNE      ??formDiscoverAttributeExtendedsResponse_3
   \   0000008E   0x9803             LDR      R0,[SP, #+12]
   \   00000090   0x7006             STRB     R6,[R0, #+0]
   \   00000092   0xE01D             B        ??formDiscoverAttributeExtendedsResponse_0
   \                     ??formDiscoverAttributeExtendedsResponse_3: (+1)
   \   00000094   0x4669             MOV      R1,SP
   \   00000096   0x7803             LDRB     R3,[R0, #+0]
   \   00000098   0x7842             LDRB     R2,[R0, #+1]
   \   0000009A   0x0612             LSLS     R2,R2,#+24
   \   0000009C   0x0C12             LSRS     R2,R2,#+16
   \   0000009E   0x4313             ORRS     R3,R3,R2
   \   000000A0   0x804B             STRH     R3,[R1, #+2]
   \   000000A2   0x468C             MOV      R12,R1
   \   000000A4   0x9902             LDR      R1,[SP, #+8]
   \   000000A6   0x780B             LDRB     R3,[R1, #+0]
   \   000000A8   0x784A             LDRB     R2,[R1, #+1]
   \   000000AA   0x0612             LSLS     R2,R2,#+24
   \   000000AC   0x0C12             LSRS     R2,R2,#+16
   \   000000AE   0x4313             ORRS     R3,R3,R2
   \   000000B0   0x4661             MOV      R1,R12
   \   000000B2   0x800B             STRH     R3,[R1, #+0]
   \   000000B4   0x9902             LDR      R1,[SP, #+8]
   \   000000B6   0x7889             LDRB     R1,[R1, #+2]
   \   000000B8   0x466A             MOV      R2,SP
   \   000000BA   0x8852             LDRH     R2,[R2, #+2]
   \   000000BC   0x466B             MOV      R3,SP
   \   000000BE   0x881B             LDRH     R3,[R3, #+0]
   \   000000C0   0x429A             CMP      R2,R3
   \   000000C2   0xD302             BCC      ??formDiscoverAttributeExtendedsResponse_4
   \   000000C4   0xB2ED             UXTB     R5,R5
   \   000000C6   0x428D             CMP      R5,R1
   \   000000C8   0xD3B4             BCC      ??formDiscoverAttributeExtendedsResponse_2
    985                  else if(counter == req->maxAttributeIds)
   \                     ??formDiscoverAttributeExtendedsResponse_4: (+1)
   \   000000CA   0xB2ED             UXTB     R5,R5
   \   000000CC   0x428D             CMP      R5,R1
   \   000000CE   0xD1D4             BNE      ??formDiscoverAttributeExtendedsResponse_1
    986                    break;
    987                }
    988              }
    989              while (NULL != attributeDescriptor);
    990            }
    991            return result;
   \                     ??formDiscoverAttributeExtendedsResponse_0: (+1)
   \   000000D0   0xB2F8             UXTB     R0,R7
   \   000000D2   0xB005             ADD      SP,SP,#+20
   \   000000D4   0xBDF0             POP      {R4-R7,PC}       ;; return
    992          }
    993          
    994          /***************************************************************************//**
    995          \brief Creates and sends default response if it is needed
    996          
    997          \param[in] auxData - pointer to auxilliary structure with data for frame formation
    998          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    999          static void sendDefaultResponse(ZclAuxParseData_t *auxData)
   1000          {
   \                     sendDefaultResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   1001            ZclFrameDescriptor_t *incomingFrameDesc = auxData->frameDescriptor;
   \   00000006   0x6822             LDR      R2,[R4, #+0]
   \   00000008   0x0017             MOVS     R7,R2
   1002            ZclFrameDescriptor_t outcomingFrameDesc;
   1003            ZclMmBuffer_t *buf;
   1004            uint8_t *payloadOut;
   1005          
   1006            if (!zclDefaultResponseIsValid(auxData))
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x7A21             LDRB     R1,[R4, #+8]
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0x29AA             CMP      R1,#+170
   \   00000012   0xD101             BNE      ??sendDefaultResponse_0
   \   00000014   0x7226             STRB     R6,[R4, #+8]
   \   00000016   0xE016             B        ??sendDefaultResponse_1
   \                     ??sendDefaultResponse_0: (+1)
   \   00000018   0x7893             LDRB     R3,[R2, #+2]
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD102             BNE      ??sendDefaultResponse_2
   \   0000001E   0x7A53             LDRB     R3,[R2, #+9]
   \   00000020   0x2B0B             CMP      R3,#+11
   \   00000022   0xD048             BEQ      ??sendDefaultResponse_3
   \                     ??sendDefaultResponse_2: (+1)
   \   00000024   0x7B03             LDRB     R3,[R0, #+12]
   \   00000026   0x2B03             CMP      R3,#+3
   \   00000028   0xD045             BEQ      ??sendDefaultResponse_3
   \   0000002A   0x2B01             CMP      R3,#+1
   \   0000002C   0xD043             BEQ      ??sendDefaultResponse_3
   \   0000002E   0x8A00             LDRH     R0,[R0, #+16]
   \   00000030   0x....             LDR      R3,??DataTable7  ;; 0xfff8
   \   00000032   0x4298             CMP      R0,R3
   \   00000034   0xD23F             BCS      ??sendDefaultResponse_3
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD105             BNE      ??sendDefaultResponse_1
   \   0000003A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD13A             BNE      ??sendDefaultResponse_3
   \   00000040   0x7910             LDRB     R0,[R2, #+4]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD137             BNE      ??sendDefaultResponse_3
   1007              return;
   1008          
   1009            //get buffer for response
   1010            buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \                     ??sendDefaultResponse_1: (+1)
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0x.... 0x....      BL       zclMmGetMem
   \   0000004C   0x0005             MOVS     R5,R0
   1011            if (!buf)
   \   0000004E   0xD032             BEQ      ??sendDefaultResponse_3
   1012              return;
   1013          
   1014            outcomingFrameDesc.headerLength = incomingFrameDesc->headerLength;
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x7839             LDRB     R1,[R7, #+0]
   \   00000054   0x7001             STRB     R1,[R0, #+0]
   1015            payloadOut = buf->frame + getZclAsduOffset() + outcomingFrameDesc.headerLength;
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x3150             ADDS     R1,R1,#+80
   \   0000005A   0x698A             LDR      R2,[R1, #+24]
   \   0000005C   0x7803             LDRB     R3,[R0, #+0]
   \   0000005E   0x18D2             ADDS     R2,R2,R3
   \   00000060   0x323B             ADDS     R2,R2,#+59
   1016            ((ZCL_DefaultResp_t*)payloadOut)->commandId = incomingFrameDesc->commandId;
   \   00000062   0x7A7B             LDRB     R3,[R7, #+9]
   \   00000064   0x7013             STRB     R3,[R2, #+0]
   1017            ((ZCL_DefaultResp_t*)payloadOut)->statusCode = auxData->commandStatus;
   \   00000066   0x7A23             LDRB     R3,[R4, #+8]
   \   00000068   0x7053             STRB     R3,[R2, #+1]
   1018            // size of status code and command id and header length
   1019            buf->primitive.apsDataReq.asduLength = sizeof(ZCL_DefaultResp_t) + outcomingFrameDesc.headerLength;
   \   0000006A   0x7802             LDRB     R2,[R0, #+0]
   \   0000006C   0x1C92             ADDS     R2,R2,#+2
   \   0000006E   0x800A             STRH     R2,[R1, #+0]
   1020            outcomingFrameDesc.commandId = ZCL_DEFAULT_RESPONSE_COMMAND_ID;
   \   00000070   0x220B             MOVS     R2,#+11
   \   00000072   0x7242             STRB     R2,[R0, #+9]
   1021            if (ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT == incomingFrameDesc->direction)
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x78FB             LDRB     R3,[R7, #+3]
   \   00000078   0x2B01             CMP      R3,#+1
   \   0000007A   0xD101             BNE      ??sendDefaultResponse_4
   1022              outcomingFrameDesc.direction = ZCL_FRAME_CONTROL_DIRECTION_CLIENT_TO_SERVER;
   \   0000007C   0x70C6             STRB     R6,[R0, #+3]
   \   0000007E   0xE000             B        ??sendDefaultResponse_5
   1023            else
   1024              outcomingFrameDesc.direction = ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT;
   \                     ??sendDefaultResponse_4: (+1)
   \   00000080   0x70C2             STRB     R2,[R0, #+3]
   1025            outcomingFrameDesc.frameType = ZCL_FRAME_CONTROL_FRAME_TYPE_UNIVERSAL_COMMAND;
   \                     ??sendDefaultResponse_5: (+1)
   \   00000082   0x7086             STRB     R6,[R0, #+2]
   1026            outcomingFrameDesc.header = buf->frame + getZclAsduOffset();
   \   00000084   0x698B             LDR      R3,[R1, #+24]
   \   00000086   0x333B             ADDS     R3,R3,#+59
   \   00000088   0x9303             STR      R3,[SP, #+12]
   1027            outcomingFrameDesc.payload = buf->frame + getZclAsduOffset() + outcomingFrameDesc.headerLength;
   \   0000008A   0x6989             LDR      R1,[R1, #+24]
   \   0000008C   0x7803             LDRB     R3,[R0, #+0]
   \   0000008E   0x18C9             ADDS     R1,R1,R3
   \   00000090   0x313B             ADDS     R1,R1,#+59
   \   00000092   0x9104             STR      R1,[SP, #+16]
   1028            outcomingFrameDesc.manufacturerSpecific = incomingFrameDesc->manufacturerSpecific;
   \   00000094   0x7979             LDRB     R1,[R7, #+5]
   \   00000096   0x7141             STRB     R1,[R0, #+5]
   1029            outcomingFrameDesc.manufacturerCode = incomingFrameDesc->manufacturerCode;
   \   00000098   0x88F9             LDRH     R1,[R7, #+6]
   \   0000009A   0x80C1             STRH     R1,[R0, #+6]
   1030            outcomingFrameDesc.sequenceNumber = incomingFrameDesc->sequenceNumber;
   \   0000009C   0x7A39             LDRB     R1,[R7, #+8]
   \   0000009E   0x7201             STRB     R1,[R0, #+8]
   1031            outcomingFrameDesc.defaultResponse = ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RESPONSE;
   \   000000A0   0x7102             STRB     R2,[R0, #+4]
   1032          
   1033            formZclHeader(&outcomingFrameDesc);
   \   000000A2   0x.... 0x....      BL       formZclHeader
   1034            formServerDataReq(buf, auxData->ind);
   \   000000A6   0x6861             LDR      R1,[R4, #+4]
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x.... 0x....      BL       formServerDataReq
   1035            zclApsDataReq(&buf->primitive.apsDataReq, auxData->apsSecurity);
   \   000000AE   0x7A61             LDRB     R1,[R4, #+9]
   \   000000B0   0x0028             MOVS     R0,R5
   \   000000B2   0x.... 0x....      BL       zclApsDataReq
   1036          }
   \                     ??sendDefaultResponse_3: (+1)
   \   000000B6   0xB005             ADD      SP,SP,#+20
   \   000000B8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1037          
   1038          /**************************************************************************//**
   1039          \brief Process incoming data indication
   1040          ******************************************************************************/
   1041          static void processDataInd(void)
   1042          {
   1043            APS_DataInd_t *apsDataInd = getQueueElem(&parserMem.dataIndQueue);
   1044          
   1045            if (!apsDataInd)
   1046              return;
   1047          
   1048            if (parseDataInd(apsDataInd))
   1049            {
   1050              deleteHeadQueueElem(&parserMem.dataIndQueue);
   1051              zclMmFreeMem((ZclMmBuffer_t *)apsDataInd);
   1052              parserMem.dataIndAmount--;
   1053            }
   1054          }
   1055          
   1056          /*************************************************************************************//**
   1057            \brief Incoming commands validation routine.
   1058          
   1059            \param[in] ind - pointer to APS data indication parameters.
   1060            \param[in] frameDescriptor - parsed frame data.
   1061          
   1062            \return Command validation status.
   1063          ******************************************************************************************/
   1064          static ZCL_Status_t validateIncomingCommand(const APS_DataInd_t *ind, const ZclFrameDescriptor_t *frameDescriptor)
   1065          {
   1066            uint8_t securityType = zclGetSecurityTypeByClusterId(ind->clusterId, ind->dstEndpoint);
   1067            (void)frameDescriptor;
   1068          #ifdef _APS_MULTICAST_
   1069            if (APS_GROUP_ADDRESS == ind->dstAddrMode)
   1070              securityType = ZCL_NETWORK_KEY_CLUSTER_SECURITY;
   1071          #endif
   1072          
   1073            if (ZCL_NETWORK_KEY_CLUSTER_SECURITY == securityType)
   1074            {
   1075              if (APS_UNSECURED_STATUS == ind->securityStatus)
   1076              {
   1077                // Accept commands which are compliant with the security policy
   1078                return ZCL_SUCCESS_STATUS;
   1079              }
   1080              else if (APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus))
   1081              {
   1082          #if CERTICOM_SUPPORT == 1
   1083                if (!APS_AreKeysAuthorized(&ind->srcAddress.extAddress))
   1084                  /* The command was encrypted on the APS layer with a non authorized link key */
   1085                  return ZCL_NOT_AUTHORIZED_STATUS;
   1086                else
   1087          #endif
   1088                  return ZCL_SUCCESS_STATUS;
   1089              }
   1090            }
   1091            else if (ZCL_APPLICATION_LINK_KEY_CLUSTER_SECURITY == securityType &&
   1092                     APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus))
   1093            {
   1094          #if CERTICOM_SUPPORT == 1
   1095              if (!APS_AreKeysAuthorized(&ind->srcAddress.extAddress))
   1096                /* The command was encrypted on the APS layer with a non authorized link key */
   1097                return ZCL_NOT_AUTHORIZED_STATUS;
   1098              else
   1099          #endif
   1100                // Accept commands which are compliant with the security policy
   1101                return ZCL_SUCCESS_STATUS;
   1102            }
   1103          
   1104            /*
   1105              AMI Profile Spec, r15, Paragraph 5.4.6, page 23.
   1106              If incorrect key usage is found the application shall generate a ZCL
   1107              Default Response, employing the Network Key, with a FAILURE (0x01) status code.
   1108            */
   1109            return ZCL_FAILURE_STATUS;
   1110          }
   1111          
   1112          /**************************************************************************//**
   1113          \brief Send relevant (non-default) response to request
   1114          
   1115          \param[in] dsc - frame descriptor
   1116          \param[in] buf - zcl memory buffer
   1117          \param[in] cmd - command to send
   1118          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1119          static void sendRelevantResponse(ZclFrameDescriptor_t *dsc, ZclMmBuffer_t *buf, APS_DataInd_t *ind, uint8_t cmd)
   1120          {
   \                     sendRelevantResponse: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   1121            buf->primitive.apsDataReq.asduLength += dsc->headerLength;
   \   00000008   0x0035             MOVS     R5,R6
   \   0000000A   0x3550             ADDS     R5,R5,#+80
   \   0000000C   0x8828             LDRH     R0,[R5, #+0]
   \   0000000E   0x7821             LDRB     R1,[R4, #+0]
   \   00000010   0x1840             ADDS     R0,R0,R1
   \   00000012   0x8028             STRH     R0,[R5, #+0]
   1122          
   1123            dsc->commandId = cmd;
   \   00000014   0x7263             STRB     R3,[R4, #+9]
   1124            dsc->direction = getDstClusterSideByIncommingCommandDirection(dsc->direction);
   \   00000016   0x78E0             LDRB     R0,[R4, #+3]
   \   00000018   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   0000001C   0x70E0             STRB     R0,[R4, #+3]
   1125            dsc->header = buf->frame + getZclAsduOffset();
   \   0000001E   0x69A8             LDR      R0,[R5, #+24]
   \   00000020   0x303B             ADDS     R0,R0,#+59
   \   00000022   0x60E0             STR      R0,[R4, #+12]
   1126            dsc->payload = buf->frame + getZclAsduOffset() + dsc->headerLength;
   \   00000024   0x69A8             LDR      R0,[R5, #+24]
   \   00000026   0x7821             LDRB     R1,[R4, #+0]
   \   00000028   0x1840             ADDS     R0,R0,R1
   \   0000002A   0x303B             ADDS     R0,R0,#+59
   \   0000002C   0x6120             STR      R0,[R4, #+16]
   1127            //Disable Default Response
   1128            dsc->defaultResponse = ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RESPONSE;
   \   0000002E   0x2501             MOVS     R5,#+1
   \   00000030   0x7125             STRB     R5,[R4, #+4]
   1129            formZclHeader(dsc);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       formZclHeader
   1130            formServerDataReq(buf, ind);
   \   00000038   0x0039             MOVS     R1,R7
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       formServerDataReq
   1131            zclApsDataReq(&buf->primitive.apsDataReq, APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus));
   \   00000040   0x3749             ADDS     R7,R7,#+73
   \   00000042   0x7838             LDRB     R0,[R7, #+0]
   \   00000044   0x28AB             CMP      R0,#+171
   \   00000046   0xD003             BEQ      ??sendRelevantResponse_0
   \   00000048   0x28B1             CMP      R0,#+177
   \   0000004A   0xD001             BEQ      ??sendRelevantResponse_0
   \   0000004C   0x28B2             CMP      R0,#+178
   \   0000004E   0xD101             BNE      ??sendRelevantResponse_1
   \                     ??sendRelevantResponse_0: (+1)
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0xE000             B        ??sendRelevantResponse_2
   \                     ??sendRelevantResponse_1: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \                     ??sendRelevantResponse_2: (+1)
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       zclApsDataReq
   1132          }
   \   0000005C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1133          
   1134          /**************************************************************************//**
   1135          \brief Checks if specified manufacturer code is supported
   1136          
   1137          \param[in] manufacturerCode - code
   1138          ******************************************************************************/
   1139          static bool isSupportedManufacturerSpecCode(uint16_t  manufacturerCode)
   1140          {
   1141            uint16_t mfg_code;
   1142            CS_ReadParameter(CS_MANUFACTURER_CODE_ID, &mfg_code);
   1143            if (mfg_code == manufacturerCode)
   1144              return true;
   1145          
   1146            return false;
   1147          }
   1148          
   1149          /*************************************************************************************//**
   1150            \brief The main incoming packets parse function. Performs the ZCL header checking and
   1151            parses the ZCL command payload according to commandId.
   1152          
   1153            \param[in] ind - pointer to APS data indication parameters.
   1154            \return true in case if data indication shall be deleted from queue, false otherwise.
   1155          ******************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1156          static bool parseDataInd(APS_DataInd_t *ind)
   1157          {
   \                     parseDataInd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x0006             MOVS     R6,R0
   1158            ZclMmBuffer_t *buf;
   1159            uint8_t commandId;
   1160            uint8_t *payloadOut;
   1161            ZclFrameDescriptor_t frameDescriptor;
   1162            ZclAuxParseData_t auxParseData = {.relevantResponse = false, .ind = ind, .frameDescriptor = &frameDescriptor};
   \   00000006   0xA807             ADD      R0,SP,#+28
   \   00000008   0x210C             MOVS     R1,#+12
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x9007             STR      R0,[SP, #+28]
   \   00000012   0x9608             STR      R6,[SP, #+32]
   1163          
   1164            // Check frame and ignore invalid ones
   1165            if (0 == parseZclHeader(&frameDescriptor, ind))
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x.... 0x....      BL       parseZclHeader
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD100             BNE      .+4
   \   0000001E   0xE18A             B        ??parseDataInd_1
   1166              return true;
   1167          
   1168            // Check security type and Cluster Usage of Security Keys.
   1169            auxParseData.commandStatus = validateIncomingCommand(ind, &frameDescriptor);
   \   00000020   0x2020             MOVS     R0,#+32
   \   00000022   0x5C31             LDRB     R1,[R6, R0]
   \   00000024   0x8FF0             LDRH     R0,[R6, #+62]
   \   00000026   0x.... 0x....      BL       zclGetSecurityTypeByClusterId
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x2701             MOVS     R7,#+1
   \   0000002E   0x7B31             LDRB     R1,[R6, #+12]
   \   00000030   0x2901             CMP      R1,#+1
   \   00000032   0xD001             BEQ      ??parseDataInd_2
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD104             BNE      ??parseDataInd_3
   \                     ??parseDataInd_2: (+1)
   \   00000038   0x2049             MOVS     R0,#+73
   \   0000003A   0x5C30             LDRB     R0,[R6, R0]
   \   0000003C   0x28AF             CMP      R0,#+175
   \   0000003E   0xD102             BNE      ??parseDataInd_4
   \   00000040   0xE009             B        ??parseDataInd_5
   \                     ??parseDataInd_3: (+1)
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD109             BNE      ??parseDataInd_6
   \                     ??parseDataInd_4: (+1)
   \   00000046   0x2049             MOVS     R0,#+73
   \   00000048   0x5C30             LDRB     R0,[R6, R0]
   \   0000004A   0x28AB             CMP      R0,#+171
   \   0000004C   0xD003             BEQ      ??parseDataInd_5
   \   0000004E   0x28B1             CMP      R0,#+177
   \   00000050   0xD001             BEQ      ??parseDataInd_5
   \   00000052   0x28B2             CMP      R0,#+178
   \   00000054   0xD101             BNE      ??parseDataInd_6
   \                     ??parseDataInd_5: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE000             B        ??parseDataInd_7
   \                     ??parseDataInd_6: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??parseDataInd_7: (+1)
   \   0000005C   0xAC07             ADD      R4,SP,#+28
   \   0000005E   0x7220             STRB     R0,[R4, #+8]
   1170          
   1171            if (ZCL_SUCCESS_STATUS != auxParseData.commandStatus)
   \   00000060   0x7A20             LDRB     R0,[R4, #+8]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD000             BEQ      .+4
   \   00000066   0xE162             B        ??parseDataInd_8
   \   00000068   0xA802             ADD      R0,SP,#+8
   \   0000006A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD11A             BNE      ??parseDataInd_9
   \   00000070   0xA802             ADD      R0,SP,#+8
   \   00000072   0x7940             LDRB     R0,[R0, #+5]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD116             BNE      ??parseDataInd_9
   \   00000078   0xA802             ADD      R0,SP,#+8
   \   0000007A   0x88C0             LDRH     R0,[R0, #+6]
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0x8688             STRH     R0,[R1, #+52]
   \   00000080   0x1C89             ADDS     R1,R1,#+2
   \   00000082   0x2087             MOVS     R0,#+135
   \   00000084   0x0040             LSLS     R0,R0,#+1        ;; #+270
   \   00000086   0x.... 0x....      BL       CS_ReadParameter
   \   0000008A   0x4668             MOV      R0,SP
   \   0000008C   0x8840             LDRH     R0,[R0, #+2]
   \   0000008E   0x4669             MOV      R1,SP
   \   00000090   0x8E89             LDRH     R1,[R1, #+52]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD007             BEQ      ??parseDataInd_9
   1172            {
   1173              // Command is invalid or isn't supported - send a default response
   1174              auxParseData.apsSecurity = false;
   1175          #if CERTICOM_SUPPORT == 1
   1176              if (ZCL_NOT_AUTHORIZED_STATUS != auxParseData.commandStatus)
   1177          #endif
   1178                sendDefaultResponse(&auxParseData);
   1179              return true;
   1180            }
   1181          
   1182            if (ZCL_FRAME_CONTROL_DIRECTION_CLIENT_TO_SERVER == frameDescriptor.direction &&
   1183                ZCL_FRAME_CONTROL_MANUFACTURER_SPECIFIC == frameDescriptor.manufacturerSpecific &&
   1184                !isSupportedManufacturerSpecCode(frameDescriptor.manufacturerCode))
   1185            {
   1186              auxParseData.commandStatus = (frameDescriptor.frameType != ZCL_FRAME_CONTROL_FRAME_TYPE_UNIVERSAL_COMMAND) ?
   1187                                           ZCL_UNSUP_MANUF_CLUSTER_COMMAND :
   1188                                           ZCL_UNSUP_MANUF_GENERAL_COMMAND_STATUS;
   \   00000096   0xA802             ADD      R0,SP,#+8
   \   00000098   0x7880             LDRB     R0,[R0, #+2]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD001             BEQ      ??parseDataInd_10
   \   0000009E   0x2083             MOVS     R0,#+131
   \   000000A0   0xE13B             B        ??parseDataInd_11
   \                     ??parseDataInd_10: (+1)
   \   000000A2   0x2084             MOVS     R0,#+132
   \   000000A4   0xE139             B        ??parseDataInd_11
   1189              auxParseData.apsSecurity = APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus);
   1190              sendDefaultResponse(&auxParseData);
   1191              return true;
   1192            }
   \                     ??parseDataInd_9: (+1)
   \   000000A6   0xA802             ADD      R0,SP,#+8
   \   000000A8   0x7880             LDRB     R0,[R0, #+2]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xA802             ADD      R0,SP,#+8
   \   000000AE   0xD010             BEQ      ??parseDataInd_12
   1193          
   1194            if (frameDescriptor.frameType != ZCL_FRAME_CONTROL_FRAME_TYPE_UNIVERSAL_COMMAND)
   1195            {
   1196              if (ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT == frameDescriptor.direction)
   \   000000B0   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD109             BNE      ??parseDataInd_13
   1197              { // additional checking for responses if confirm has been received already or not.
   1198                ZCL_Request_t *zclReq = zclFindAppropriateRequest(&auxParseData);
   \   000000B6   0xA807             ADD      R0,SP,#+28
   \   000000B8   0x.... 0x....      BL       zclFindAppropriateRequest
   1199          
   1200                if (zclReq && (ZCL_REQ_FLAG_CONF_RCVD != (zclReq->service.statusflags & ZCL_REQ_RESP_CONF_MASK)))
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD004             BEQ      ??parseDataInd_13
   \   000000C0   0x7940             LDRB     R0,[R0, #+5]
   \   000000C2   0x0780             LSLS     R0,R0,#+30
   \   000000C4   0x0F80             LSRS     R0,R0,#+30
   \   000000C6   0x2802             CMP      R0,#+2
   \   000000C8   0xD14E             BNE      ??parseDataInd_14
   1201                  return false;
   1202              }
   1203          
   1204              // Command is cluster specific, send default response if required
   1205              zclCommandInd(&auxParseData);
   \                     ??parseDataInd_13: (+1)
   \   000000CA   0xA807             ADD      R0,SP,#+28
   \   000000CC   0x.... 0x....      BL       zclCommandInd
   1206              auxParseData.apsSecurity = APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus);
   \   000000D0   0xE124             B        ??parseDataInd_15
   1207              sendDefaultResponse(&auxParseData);
   1208              return true;
   1209            }
   1210          
   1211            // Command is universal
   1212            commandId = frameDescriptor.commandId;
   \                     ??parseDataInd_12: (+1)
   \   000000D2   0x7A40             LDRB     R0,[R0, #+9]
   \   000000D4   0x9001             STR      R0,[SP, #+4]
   1213          
   1214            switch (commandId)
   \   000000D6   0x2816             CMP      R0,#+22
   \   000000D8   0xD900             BLS      .+4
   \   000000DA   0xE11D             B        ??parseDataInd_16
   \   000000DC   0xA101             ADR      R1,??parseDataInd_0
   \   000000DE   0x0040             LSLS     R0,R0,#+1
   \   000000E0   0x5A09             LDRH     R1,[R1, R0]
   \   000000E2   0x448F             ADD      PC,PC,R1
   \                     ??parseDataInd_0:
   \   000000E4   0x002C 0x006E      DC16     0x2C,0x6E,0x8E,0x8E
   \              0x008E 0x008E
   \   000000EC   0x006E 0x008E      DC16     0x6E,0x8E,0x1A0,0x6E
   \              0x01A0 0x006E
   \   000000F4   0x0196 0x006E      DC16     0x196,0x6E,0x18C,0x22A
   \              0x018C 0x022A
   \   000000FC   0x00D0 0x006E      DC16     0xD0,0x6E,0x2C,0x232
   \              0x002C 0x0232
   \   00000104   0x0232 0x01AA      DC16     0x232,0x1AA,0x6E,0x1D0
   \              0x006E 0x01D0
   \   0000010C   0x006E 0x01F6      DC16     0x6E,0x1F6,0x6E
   \              0x006E       
   1215            {
   1216              case ZCL_READ_ATTRIBUTES_COMMAND_ID:
   1217              case ZCL_READ_ATTRIBUTES_STRUCTURED_COMMAND_ID:
   1218                {
   1219                  uint8_t maxSize;
   1220          
   1221                  CS_ReadParameter(CS_ZCL_BUFFER_SIZE_ID, (void *)&maxSize);
   \                     ??parseDataInd_17: (+1)
   \   00000112   0x4669             MOV      R1,SP
   \   00000114   0x20FF             MOVS     R0,#+255
   \   00000116   0x301C             ADDS     R0,R0,#+28       ;; #+283
   \   00000118   0x.... 0x....      BL       CS_ReadParameter
   1222          
   1223                  buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);  // get buffer for response
   \   0000011C   0x2003             MOVS     R0,#+3
   \   0000011E   0x.... 0x....      BL       zclMmGetMem
   \   00000122   0x0004             MOVS     R4,R0
   1224                  if (!buf)
   \   00000124   0xD02A             BEQ      ??parseDataInd_18
   1225                    return false;
   1226                  payloadOut = buf->frame + getZclAsduOffset() + frameDescriptor.headerLength;
   \   00000126   0x0027             MOVS     R7,R4
   \   00000128   0x3750             ADDS     R7,R7,#+80
   \   0000012A   0x69B8             LDR      R0,[R7, #+24]
   \   0000012C   0x4669             MOV      R1,SP
   \   0000012E   0x7A09             LDRB     R1,[R1, #+8]
   \   00000130   0x1840             ADDS     R0,R0,R1
   \   00000132   0x303B             ADDS     R0,R0,#+59
   1227                  // form response
   1228                  buf->primitive.apsDataReq.asduLength = (ZCL_READ_ATTRIBUTES_COMMAND_ID == commandId ?
   1229                                                          formReadAttributesResponse :
   1230                                                          formReadAttributesStructuredResponse)
   1231                                                          (payloadOut,
   1232                                                           maxSize - sizeof(frameDescriptor.headerLength),
   1233                                                           ind,
   1234                                                           &frameDescriptor);
   \   00000134   0x9901             LDR      R1,[SP, #+4]
   \   00000136   0x2900             CMP      R1,#+0
   \   00000138   0xD101             BNE      ??parseDataInd_19
   \   0000013A   0x....             LDR      R5,??DataTable8
   \   0000013C   0xE000             B        ??parseDataInd_20
   \                     ??parseDataInd_19: (+1)
   \   0000013E   0x....             LDR      R5,??DataTable8_1
   \                     ??parseDataInd_20: (+1)
   \   00000140   0xAB02             ADD      R3,SP,#+8
   \   00000142   0x0032             MOVS     R2,R6
   \   00000144   0x4669             MOV      R1,SP
   \   00000146   0x7809             LDRB     R1,[R1, #+0]
   \   00000148   0x1E49             SUBS     R1,R1,#+1
   \   0000014A   0xB289             UXTH     R1,R1
   \   0000014C   0x47A8             BLX      R5
   \   0000014E   0x8038             STRH     R0,[R7, #+0]
   1235                  sendRelevantResponse(&frameDescriptor, buf, ind, ZCL_READ_ATTRIBUTES_RESPONSE_COMMAND_ID);
   \   00000150   0x2301             MOVS     R3,#+1
   \   00000152   0xE0D7             B.N      ??parseDataInd_21
   1236                }
   1237                break;
   1238          
   1239              case ZCL_READ_ATTRIBUTES_RESPONSE_COMMAND_ID:
   1240              case ZCL_WRITE_ATTRIBUTES_RESPONSE_COMMAND_ID:
   1241              case ZCL_CONFIGURE_REPORTING_RESPONSE_COMMAND_ID:
   1242              case ZCL_READ_REPORTING_CONFIGURATION_RESPONSE_COMMAND_ID:
   1243              case ZCL_DISCOVER_ATTRIBUTES_RESPONSE_COMMAND_ID:
   1244              case ZCL_DISCOVER_COMMANDS_RECEIVED_RESPONSE_COMMAND_ID:
   1245              case ZCL_DISCOVER_COMMANDS_GENERATED_RESPONSE_COMMAND_ID:
   1246              case ZCL_DISCOVER_ATTRIBUTES_EXTENDED_RESPONSE_COMMAND_ID:
   1247                {
   1248                  ZCL_Request_t *zclReq = zclFindAppropriateRequest(&auxParseData);
   \                     ??parseDataInd_22: (+1)
   \   00000154   0xA807             ADD      R0,SP,#+28
   \   00000156   0x.... 0x....      BL       zclFindAppropriateRequest
   \   0000015A   0x0001             MOVS     R1,R0
   1249          
   1250                  if (zclReq && (ZCL_REQ_FLAG_CONF_RCVD != (zclReq->service.statusflags & ZCL_REQ_RESP_CONF_MASK)))
   \   0000015C   0xD100             BNE      .+4
   \   0000015E   0xE0EA             B        ??parseDataInd_1
   \   00000160   0x7948             LDRB     R0,[R1, #+5]
   \   00000162   0x0780             LSLS     R0,R0,#+30
   \   00000164   0x0F80             LSRS     R0,R0,#+30
   \   00000166   0x2802             CMP      R0,#+2
   \                     ??parseDataInd_14: (+1)
   \   00000168   0xD000             BEQ      .+4
   \   0000016A   0xE0BC             B        ??parseDataInd_23
   1251                    return false;
   1252                  if (!zclReq)
   1253                    return true;
   1254          
   1255                  zclResponseInd(&auxParseData, zclReq);
   \   0000016C   0xA807             ADD      R0,SP,#+28
   \   0000016E   0x.... 0x....      BL       zclResponseInd
   1256                  auxParseData.apsSecurity = APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus);
   \   00000172   0xE0D3             B        ??parseDataInd_15
   1257                  sendDefaultResponse(&auxParseData);
   1258                }
   1259                break;
   1260          
   1261              case ZCL_WRITE_ATTRIBUTES_NO_RESPONSE_COMMAND_ID:
   1262              case ZCL_WRITE_ATTRIBUTES_COMMAND_ID:
   1263              case ZCL_WRITE_ATTRIBUTES_UNDIVIDED_COMMAND_ID:
   1264                {
   1265                  buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \                     ??parseDataInd_24: (+1)
   \   00000174   0x2003             MOVS     R0,#+3
   \   00000176   0x.... 0x....      BL       zclMmGetMem
   \   0000017A   0x0004             MOVS     R4,R0
   1266                  if (!buf)
   \                     ??parseDataInd_18: (+1)
   \   0000017C   0xD100             BNE      .+4
   \   0000017E   0xE0B2             B        ??parseDataInd_23
   \   00000180   0x3050             ADDS     R0,R0,#+80
   \   00000182   0x6980             LDR      R0,[R0, #+24]
   \   00000184   0x4669             MOV      R1,SP
   \   00000186   0x7A09             LDRB     R1,[R1, #+8]
   \   00000188   0x1840             ADDS     R0,R0,R1
   \   0000018A   0x303B             ADDS     R0,R0,#+59
   1267                    return false;
   1268          
   1269                  payloadOut = buf->frame + getZclAsduOffset() + frameDescriptor.headerLength;
   1270                  // form response
   1271                  buf->primitive.apsDataReq.asduLength = formWriteAttributeResponse((ZCL_WriteAttributeResp_t *)payloadOut,
   1272                                                                                     ind,
   1273                                                                                     &frameDescriptor,
   1274                                                                                     ZCL_WRITE_ATTRIBUTES_UNDIVIDED_COMMAND_ID == commandId);
   \   0000018C   0x9901             LDR      R1,[SP, #+4]
   \   0000018E   0x2903             CMP      R1,#+3
   \   00000190   0xD101             BNE      ??parseDataInd_25
   \   00000192   0x2301             MOVS     R3,#+1
   \   00000194   0xE000             B        ??parseDataInd_26
   \                     ??parseDataInd_25: (+1)
   \   00000196   0x2300             MOVS     R3,#+0
   \                     ??parseDataInd_26: (+1)
   \   00000198   0xAA02             ADD      R2,SP,#+8
   \   0000019A   0x0031             MOVS     R1,R6
   \   0000019C   0x.... 0x....      BL       formWriteAttributeResponse
   \   000001A0   0x2150             MOVS     R1,#+80
   \   000001A2   0x5260             STRH     R0,[R4, R1]
   1275                  // Free allocated memory if no response required
   1276                  if (ZCL_WRITE_ATTRIBUTES_NO_RESPONSE_COMMAND_ID == commandId)
   \   000001A4   0x9801             LDR      R0,[SP, #+4]
   \   000001A6   0x2805             CMP      R0,#+5
   \   000001A8   0xD103             BNE      ??parseDataInd_27
   1277                  {
   1278                    zclMmFreeMem(buf);
   \   000001AA   0x0020             MOVS     R0,R4
   \   000001AC   0x.... 0x....      BL       zclMmFreeMem
   1279                    sendDefaultResponse(&auxParseData);
   \   000001B0   0xE0BE             B        ??parseDataInd_28
   1280                  }
   1281                  else
   1282                    sendRelevantResponse(&frameDescriptor, buf, ind, ZCL_WRITE_ATTRIBUTES_RESPONSE_COMMAND_ID);
   \                     ??parseDataInd_27: (+1)
   \   000001B2   0x2304             MOVS     R3,#+4
   \   000001B4   0xE0A6             B.N      ??parseDataInd_21
   1283                }
   1284                break;
   1285          
   1286              case ZCL_DISCOVER_ATTRIBUTES_COMMAND_ID:
   1287                {
   1288                  buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \                     ??parseDataInd_29: (+1)
   \   000001B6   0x2003             MOVS     R0,#+3
   \   000001B8   0x.... 0x....      BL       zclMmGetMem
   \   000001BC   0x0004             MOVS     R4,R0
   1289                  if (!buf)
   \   000001BE   0xD06B             BEQ      ??parseDataInd_30
   \   000001C0   0x3050             ADDS     R0,R0,#+80
   \   000001C2   0x6980             LDR      R0,[R0, #+24]
   \   000001C4   0x4669             MOV      R1,SP
   \   000001C6   0x7A09             LDRB     R1,[R1, #+8]
   \   000001C8   0x1840             ADDS     R0,R0,R1
   \   000001CA   0x303B             ADDS     R0,R0,#+59
   \   000001CC   0x900B             STR      R0,[SP, #+44]
   1290                    return false;
   1291                  payloadOut = buf->frame + getZclAsduOffset() + frameDescriptor.headerLength;
   1292                  //form response
   1293                  buf->primitive.apsDataReq.asduLength = formDiscoverAttributesResponse((ZCL_DiscoverAttributesResp_t *) payloadOut,
   1294                                                                                        ind,
   1295                                                                                        &frameDescriptor);
   \   000001CE   0x2100             MOVS     R1,#+0
   \   000001D0   0x2020             MOVS     R0,#+32
   \   000001D2   0x5C30             LDRB     R0,[R6, R0]
   \   000001D4   0x466A             MOV      R2,SP
   \   000001D6   0x7010             STRB     R0,[R2, #+0]
   \   000001D8   0x8FF0             LDRH     R0,[R6, #+62]
   \   000001DA   0x8050             STRH     R0,[R2, #+2]
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0x9A0B             LDR      R2,[SP, #+44]
   \   000001E0   0x1C52             ADDS     R2,R2,#+1
   \   000001E2   0x9201             STR      R2,[SP, #+4]
   \   000001E4   0x466B             MOV      R3,SP
   \   000001E6   0x705D             STRB     R5,[R3, #+1]
   \   000001E8   0x9A06             LDR      R2,[SP, #+24]
   \   000001EA   0x920C             STR      R2,[SP, #+48]
   \   000001EC   0xAA02             ADD      R2,SP,#+8
   \   000001EE   0x7852             LDRB     R2,[R2, #+1]
   \   000001F0   0x2A03             CMP      R2,#+3
   \   000001F2   0xD139             BNE      ??parseDataInd_31
   \   000001F4   0x970A             STR      R7,[SP, #+40]
   \   000001F6   0x990B             LDR      R1,[SP, #+44]
   \   000001F8   0x700D             STRB     R5,[R1, #+0]
   \   000001FA   0xE028             B        ??parseDataInd_32
   \                     ??parseDataInd_33: (+1)
   \   000001FC   0x7801             LDRB     R1,[R0, #+0]
   \   000001FE   0x7842             LDRB     R2,[R0, #+1]
   \   00000200   0x0612             LSLS     R2,R2,#+24
   \   00000202   0x0C12             LSRS     R2,R2,#+16
   \   00000204   0x4311             ORRS     R1,R1,R2
   \   00000206   0x9B0C             LDR      R3,[SP, #+48]
   \   00000208   0x781A             LDRB     R2,[R3, #+0]
   \   0000020A   0x785D             LDRB     R5,[R3, #+1]
   \   0000020C   0x062D             LSLS     R5,R5,#+24
   \   0000020E   0x0C2D             LSRS     R5,R5,#+16
   \   00000210   0x432A             ORRS     R2,R2,R5
   \   00000212   0x4291             CMP      R1,R2
   \   00000214   0xD31B             BCC      ??parseDataInd_32
   \   00000216   0x4669             MOV      R1,SP
   \   00000218   0x7849             LDRB     R1,[R1, #+1]
   \   0000021A   0x789A             LDRB     R2,[R3, #+2]
   \   0000021C   0x4291             CMP      R1,R2
   \   0000021E   0xD216             BCS      ??parseDataInd_32
   \   00000220   0x7801             LDRB     R1,[R0, #+0]
   \   00000222   0x7842             LDRB     R2,[R0, #+1]
   \   00000224   0x0612             LSLS     R2,R2,#+24
   \   00000226   0x0C12             LSRS     R2,R2,#+16
   \   00000228   0x4311             ORRS     R1,R1,R2
   \   0000022A   0x9A01             LDR      R2,[SP, #+4]
   \   0000022C   0x7011             STRB     R1,[R2, #+0]
   \   0000022E   0x0A09             LSRS     R1,R1,#+8
   \   00000230   0x7051             STRB     R1,[R2, #+1]
   \   00000232   0x7881             LDRB     R1,[R0, #+2]
   \   00000234   0x9A01             LDR      R2,[SP, #+4]
   \   00000236   0x7091             STRB     R1,[R2, #+2]
   \   00000238   0x990A             LDR      R1,[SP, #+40]
   \   0000023A   0x1CC9             ADDS     R1,R1,#+3
   \   0000023C   0x910A             STR      R1,[SP, #+40]
   \   0000023E   0x9901             LDR      R1,[SP, #+4]
   \   00000240   0x1CC9             ADDS     R1,R1,#+3
   \   00000242   0x9101             STR      R1,[SP, #+4]
   \   00000244   0x4669             MOV      R1,SP
   \   00000246   0x7849             LDRB     R1,[R1, #+1]
   \   00000248   0x1C49             ADDS     R1,R1,#+1
   \   0000024A   0x466A             MOV      R2,SP
   \   0000024C   0x7051             STRB     R1,[R2, #+1]
   \                     ??parseDataInd_32: (+1)
   \   0000024E   0x0003             MOVS     R3,R0
   \   00000250   0xA802             ADD      R0,SP,#+8
   \   00000252   0x78C2             LDRB     R2,[R0, #+3]
   \   00000254   0x4668             MOV      R0,SP
   \   00000256   0x8841             LDRH     R1,[R0, #+2]
   \   00000258   0x7800             LDRB     R0,[R0, #+0]
   \   0000025A   0x.... 0x....      BL       zclGetNextAttribute
   \   0000025E   0x2800             CMP      R0,#+0
   \   00000260   0xD1CC             BNE      ??parseDataInd_33
   \   00000262   0x980B             LDR      R0,[SP, #+44]
   \   00000264   0x7007             STRB     R7,[R0, #+0]
   \   00000266   0x990A             LDR      R1,[SP, #+40]
   \                     ??parseDataInd_31: (+1)
   \   00000268   0xB2C9             UXTB     R1,R1
   \   0000026A   0x2050             MOVS     R0,#+80
   \   0000026C   0x5221             STRH     R1,[R4, R0]
   1296                  sendRelevantResponse(&frameDescriptor, buf, ind, ZCL_DISCOVER_ATTRIBUTES_RESPONSE_COMMAND_ID);
   \   0000026E   0x230D             MOVS     R3,#+13
   \   00000270   0xE048             B.N      ??parseDataInd_21
   1297                }
   1298                break;
   1299          
   1300              case ZCL_REPORT_ATTRIBUTES_COMMAND_ID:
   1301                zclReportInd(ind, &frameDescriptor);
   \                     ??parseDataInd_34: (+1)
   \   00000272   0xA902             ADD      R1,SP,#+8
   \   00000274   0x0030             MOVS     R0,R6
   \   00000276   0x.... 0x....      BL       zclReportInd
   1302                sendDefaultResponse(&auxParseData);
   \   0000027A   0xE059             B        ??parseDataInd_28
   1303                break;
   1304          
   1305              case ZCL_READ_REPORTING_CONFIGURATION_COMMAND_ID:
   1306                return zclReadReportingConfigurationHandler(ind, &frameDescriptor);
   \                     ??parseDataInd_35: (+1)
   \   0000027C   0xA902             ADD      R1,SP,#+8
   \   0000027E   0x0030             MOVS     R0,R6
   \   00000280   0x.... 0x....      BL       zclReadReportingConfigurationHandler
   \   00000284   0xE058             B        ??parseDataInd_36
   1307          
   1308              case ZCL_CONFIGURE_REPORTING_COMMAND_ID:
   1309                return zclConfigureReportingHandler(ind, &frameDescriptor);
   \                     ??parseDataInd_37: (+1)
   \   00000286   0xA902             ADD      R1,SP,#+8
   \   00000288   0x0030             MOVS     R0,R6
   \   0000028A   0x.... 0x....      BL       zclConfigureReportingHandler
   \   0000028E   0xE053             B        ??parseDataInd_36
   1310          
   1311              case ZCL_DISCOVER_COMMANDS_RECEIVED_COMMAND_ID:
   1312                {
   1313                  buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \                     ??parseDataInd_38: (+1)
   \   00000290   0x2003             MOVS     R0,#+3
   \   00000292   0x.... 0x....      BL       zclMmGetMem
   \   00000296   0x0004             MOVS     R4,R0
   1314                  if (!buf)
   \                     ??parseDataInd_30: (+1)
   \   00000298   0xD025             BEQ      ??parseDataInd_23
   1315                    return false;
   1316                  payloadOut = buf->frame + getZclAsduOffset() + frameDescriptor.headerLength;
   1317                  //form response
   1318                  buf->primitive.apsDataReq.asduLength = formDiscoverCommandsReceivedResponse((ZCL_DiscoverCommandsReceivedResp_t *) payloadOut,
   1319                                                                                        ind,
   1320                                                                                        &frameDescriptor);
   \   0000029A   0x0025             MOVS     R5,R4
   \   0000029C   0x3550             ADDS     R5,R5,#+80
   \   0000029E   0xAA02             ADD      R2,SP,#+8
   \   000002A0   0x0031             MOVS     R1,R6
   \   000002A2   0x69A8             LDR      R0,[R5, #+24]
   \   000002A4   0x466B             MOV      R3,SP
   \   000002A6   0x7A1B             LDRB     R3,[R3, #+8]
   \   000002A8   0x18C0             ADDS     R0,R0,R3
   \   000002AA   0x303B             ADDS     R0,R0,#+59
   \   000002AC   0x.... 0x....      BL       formDiscoverCommandsReceivedResponse
   \   000002B0   0x8028             STRH     R0,[R5, #+0]
   1321                  sendRelevantResponse(&frameDescriptor, buf, ind, ZCL_DISCOVER_COMMANDS_RECEIVED_RESPONSE_COMMAND_ID);
   \   000002B2   0x2312             MOVS     R3,#+18
   \   000002B4   0xE026             B.N      ??parseDataInd_21
   1322                }
   1323                break;
   1324          
   1325              case ZCL_DISCOVER_COMMANDS_GENERATED_COMMAND_ID:
   1326                {
   1327                  buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \                     ??parseDataInd_39: (+1)
   \   000002B6   0x2003             MOVS     R0,#+3
   \   000002B8   0x.... 0x....      BL       zclMmGetMem
   \   000002BC   0x0004             MOVS     R4,R0
   1328                  if (!buf)
   \   000002BE   0xD012             BEQ      ??parseDataInd_23
   1329                    return false;
   1330                  payloadOut = buf->frame + getZclAsduOffset() + frameDescriptor.headerLength;
   1331                  //form response
   1332                  buf->primitive.apsDataReq.asduLength = formDiscoverCommandsGeneratedResponse((ZCL_DiscoverCommandsGeneratedResp_t *) payloadOut,
   1333                                                                                ind,
   1334                                                                                &frameDescriptor);
   \   000002C0   0x0025             MOVS     R5,R4
   \   000002C2   0x3550             ADDS     R5,R5,#+80
   \   000002C4   0xAA02             ADD      R2,SP,#+8
   \   000002C6   0x0031             MOVS     R1,R6
   \   000002C8   0x69A8             LDR      R0,[R5, #+24]
   \   000002CA   0x466B             MOV      R3,SP
   \   000002CC   0x7A1B             LDRB     R3,[R3, #+8]
   \   000002CE   0x18C0             ADDS     R0,R0,R3
   \   000002D0   0x303B             ADDS     R0,R0,#+59
   \   000002D2   0x.... 0x....      BL       formDiscoverCommandsGeneratedResponse
   \   000002D6   0x8028             STRH     R0,[R5, #+0]
   1335                  sendRelevantResponse(&frameDescriptor, buf, ind, ZCL_DISCOVER_COMMANDS_GENERATED_RESPONSE_COMMAND_ID);
   \   000002D8   0x2314             MOVS     R3,#+20
   \   000002DA   0xE013             B.N      ??parseDataInd_21
   1336                }
   1337                break;
   1338          
   1339              case ZCL_DISCOVER_ATTRIBUTES_EXTENDED_COMMAND_ID:
   1340                {
   1341                  buf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \                     ??parseDataInd_40: (+1)
   \   000002DC   0x2003             MOVS     R0,#+3
   \   000002DE   0x.... 0x....      BL       zclMmGetMem
   \   000002E2   0x0004             MOVS     R4,R0
   1342                  if (!buf)
   \   000002E4   0xD101             BNE      ??parseDataInd_41
   1343                    return false;
   \                     ??parseDataInd_23: (+1)
   \   000002E6   0x2000             MOVS     R0,#+0
   \   000002E8   0xE026             B        ??parseDataInd_36
   1344                  payloadOut = buf->frame + getZclAsduOffset() + frameDescriptor.headerLength;
   1345                  //form response
   1346                  buf->primitive.apsDataReq.asduLength = formDiscoverAttributeExtendedsResponse((ZCL_DiscoverAttributesExtendedResp_t *) payloadOut,
   1347                                                                                        ind,
   1348                                                                                        &frameDescriptor);
   \                     ??parseDataInd_41: (+1)
   \   000002EA   0x0025             MOVS     R5,R4
   \   000002EC   0x3550             ADDS     R5,R5,#+80
   \   000002EE   0xAA02             ADD      R2,SP,#+8
   \   000002F0   0x0031             MOVS     R1,R6
   \   000002F2   0x69A8             LDR      R0,[R5, #+24]
   \   000002F4   0x466B             MOV      R3,SP
   \   000002F6   0x7A1B             LDRB     R3,[R3, #+8]
   \   000002F8   0x18C0             ADDS     R0,R0,R3
   \   000002FA   0x303B             ADDS     R0,R0,#+59
   \   000002FC   0x.... 0x....      BL       formDiscoverAttributeExtendedsResponse
   \   00000300   0x8028             STRH     R0,[R5, #+0]
   1349                  sendRelevantResponse(&frameDescriptor, buf, ind, ZCL_DISCOVER_ATTRIBUTES_EXTENDED_RESPONSE_COMMAND_ID);
   \   00000302   0x2316             MOVS     R3,#+22
   \                     ??parseDataInd_21: (+1)
   \   00000304   0x0032             MOVS     R2,R6
   \   00000306   0x0021             MOVS     R1,R4
   \   00000308   0xA802             ADD      R0,SP,#+8
   \   0000030A   0x.... 0x....      BL       sendRelevantResponse
   1350                }
   1351                break;
   \   0000030E   0xE012             B        ??parseDataInd_1
   1352          
   1353              case ZCL_DEFAULT_RESPONSE_COMMAND_ID:
   1354                return zclReceivedDefaultResponseHandler(&auxParseData);
   \                     ??parseDataInd_42: (+1)
   \   00000310   0xA807             ADD      R0,SP,#+28
   \   00000312   0x.... 0x....      BL       zclReceivedDefaultResponseHandler
   \   00000316   0xE00F             B        ??parseDataInd_36
   1355                break;
   1356          
   1357              default:
   1358                auxParseData.commandStatus = ZCL_UNSUP_GENERAL_COMMAND_STATUS;
   \                     ??parseDataInd_16: (+1)
   \   00000318   0x2082             MOVS     R0,#+130
   \                     ??parseDataInd_11: (+1)
   \   0000031A   0x7220             STRB     R0,[R4, #+8]
   1359                auxParseData.apsSecurity = APS_SECURED_WITH_ANY_LINK_KEY_STATUS(ind->securityStatus);;
   \                     ??parseDataInd_15: (+1)
   \   0000031C   0x3649             ADDS     R6,R6,#+73
   \   0000031E   0x7830             LDRB     R0,[R6, #+0]
   \   00000320   0x28AB             CMP      R0,#+171
   \   00000322   0xD003             BEQ      ??parseDataInd_43
   \   00000324   0x28B1             CMP      R0,#+177
   \   00000326   0xD001             BEQ      ??parseDataInd_43
   \   00000328   0x28B2             CMP      R0,#+178
   \   0000032A   0xD100             BNE      ??parseDataInd_8
   \                     ??parseDataInd_43: (+1)
   \   0000032C   0x2501             MOVS     R5,#+1
   \                     ??parseDataInd_8: (+1)
   \   0000032E   0x7265             STRB     R5,[R4, #+9]
   1360                sendDefaultResponse(&auxParseData);
   \                     ??parseDataInd_28: (+1)
   \   00000330   0xA807             ADD      R0,SP,#+28
   \   00000332   0x.... 0x....      BL       sendDefaultResponse
   1361                break;
   1362            }
   1363            return true;
   \                     ??parseDataInd_1: (+1)
   \   00000336   0x2001             MOVS     R0,#+1
   \                     ??parseDataInd_36: (+1)
   \   00000338   0xB00F             ADD      SP,SP,#+60
   \   0000033A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1364          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00000000         DC32 0H, 0H
   \              0x00000000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   1365          
   1366          /***************************************************************************//**
   1367          \brief Checks, if received command is Default Response command.
   1368          
   1369          \param[in] frameDescriptor - pointer to prepared frame descriptor.
   1370          
   1371          \return True, if received command is Default Response command; false - otherwise.
   1372          ******************************************************************************/
   1373          static inline bool isDefaultResponse(ZclFrameDescriptor_t *frameDescriptor)
   1374          {
   1375            return ZCL_FRAME_CONTROL_FRAME_TYPE_UNIVERSAL_COMMAND == frameDescriptor->frameType
   1376              && ZCL_DEFAULT_RESPONSE_COMMAND_ID == frameDescriptor->commandId;
   1377          }
   1378          
   1379          /***************************************************************************//**
   1380          \brief Handler of received default responses
   1381          
   1382          \param[in]
   1383            auxParseData - pointer to data from recieved frame
   1384          
   1385          \return true if received frame can be released, false - otherwise
   1386          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1387          static bool zclReceivedDefaultResponseHandler(ZclAuxParseData_t *auxParseData)
   1388          {
   \                     zclReceivedDefaultResponseHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   1389            APS_DataInd_t *apsData = auxParseData->ind;
   \   00000004   0x6844             LDR      R4,[R0, #+4]
   1390            ZclFrameDescriptor_t *frameDesc = auxParseData->frameDescriptor;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x9100             STR      R1,[SP, #+0]
   1391            ZCL_Cluster_t *cluster = NULL;
   \   0000000A   0x2600             MOVS     R6,#+0
   1392          
   1393            ZCL_Request_t *zclReq = zclFindAppropriateRequest(auxParseData);
   \   0000000C   0x.... 0x....      BL       zclFindAppropriateRequest
   1394          
   1395            if (zclReq)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD011             BEQ      ??zclReceivedDefaultResponseHandler_0
   1396            {
   1397              if (ZCL_REQ_FLAG_CONF_RCVD != (zclReq->service.statusflags & ZCL_REQ_RESP_CONF_MASK))
   \   00000014   0x7941             LDRB     R1,[R0, #+5]
   \   00000016   0x078A             LSLS     R2,R1,#+30
   \   00000018   0x0F92             LSRS     R2,R2,#+30
   \   0000001A   0x2A02             CMP      R2,#+2
   \   0000001C   0xD001             BEQ      ??zclReceivedDefaultResponseHandler_1
   1398                return false;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE04B             B        ??zclReceivedDefaultResponseHandler_2
   1399              if (zclReq->service.statusflags & ZCL_REQ_DEFAULT_RESP_RQRD)
   \                     ??zclReceivedDefaultResponseHandler_1: (+1)
   \   00000022   0x0709             LSLS     R1,R1,#+28
   \   00000024   0xD508             BPL      ??zclReceivedDefaultResponseHandler_0
   1400              {
   1401                if (!zclReq->ZCL_Notify)
   \   00000026   0x6981             LDR      R1,[R0, #+24]
   \   00000028   0x000A             MOVS     R2,R1
   \   0000002A   0xD045             BEQ      ??zclReceivedDefaultResponseHandler_3
   1402                  return true;
   1403                zclReq->notify.id = ZCL_DEFAULT_RESPONSE_ID;
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0x7242             STRB     R2,[R0, #+9]
   1404                zclReq->notify.status = ZCL_SUCCESS_STATUS;
   \   00000030   0x7206             STRB     R6,[R0, #+8]
   1405                zclReq->ZCL_Notify(&zclReq->notify);
   \   00000032   0x3008             ADDS     R0,R0,#+8
   \   00000034   0x4788             BLX      R1
   1406                return true;
   \   00000036   0xE03F             B        ??zclReceivedDefaultResponseHandler_3
   1407              }
   1408            }
   \                     ??zclReceivedDefaultResponseHandler_0: (+1)
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x78C2             LDRB     R2,[R0, #+3]
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x3020             ADDS     R0,R0,#+32
   \   00000040   0x8BC1             LDRH     R1,[R0, #+30]
   \   00000042   0x2020             MOVS     R0,#+32
   \   00000044   0x5C20             LDRB     R0,[R4, R0]
   1409          
   1410            cluster = ZCL_GetCluster(apsData->dstEndpoint,
   1411              apsData->clusterId,
   1412              getOwnClusterSideByIncomingCommandDirection(frameDesc->direction));
   \   00000046   0x.... 0x....      BL       ZCL_GetCluster
   \   0000004A   0x0007             MOVS     R7,R0
   1413          
   1414            if (cluster)
   \   0000004C   0xD034             BEQ      ??zclReceivedDefaultResponseHandler_3
   1415            {
   1416              ZCL_Addressing_t senderAddressing;
   1417          
   1418              senderAddressing.addrMode             = apsData->srcAddrMode;
   \   0000004E   0xAD02             ADD      R5,SP,#+8
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x3020             ADDS     R0,R0,#+32
   \   00000054   0x7840             LDRB     R0,[R0, #+1]
   \   00000056   0x7028             STRB     R0,[R5, #+0]
   1419              senderAddressing.addr                 = apsData->srcAddress;
   \   00000058   0xA802             ADD      R0,SP,#+8
   \   0000005A   0x3008             ADDS     R0,R0,#+8
   \   0000005C   0x0021             MOVS     R1,R4
   \   0000005E   0x3128             ADDS     R1,R1,#+40
   \   00000060   0x2210             MOVS     R2,#+16
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy4
   1420              senderAddressing.profileId            = apsData->profileId;
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x3020             ADDS     R0,R0,#+32
   \   0000006A   0x8B80             LDRH     R0,[R0, #+28]
   \   0000006C   0x8328             STRH     R0,[R5, #+24]
   1421              senderAddressing.endpointId           = apsData->srcEndpoint;
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x3020             ADDS     R0,R0,#+32
   \   00000072   0x7E80             LDRB     R0,[R0, #+26]
   \   00000074   0x76A8             STRB     R0,[R5, #+26]
   1422              senderAddressing.clusterId            = apsData->clusterId;
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x3020             ADDS     R0,R0,#+32
   \   0000007A   0x8BC0             LDRH     R0,[R0, #+30]
   \   0000007C   0x83A8             STRH     R0,[R5, #+28]
   1423              senderAddressing.clusterSide          =
   1424                getDstClusterSideByIncommingCommandDirection(frameDesc->direction);
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x78C0             LDRB     R0,[R0, #+3]
   \   00000082   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   00000086   0x77A8             STRB     R0,[R5, #+30]
   1425              senderAddressing.sequenceNumber       = frameDesc->sequenceNumber;
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000008C   0x2122             MOVS     R1,#+34
   \   0000008E   0x5468             STRB     R0,[R5, R1]
   1426          
   1427              if (ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC == frameDesc->manufacturerSpecific)
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x7940             LDRB     R0,[R0, #+5]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD101             BNE      ??zclReceivedDefaultResponseHandler_4
   1428                senderAddressing.manufacturerSpecCode = 0;
   \   00000098   0x842E             STRH     R6,[R5, #+32]
   \   0000009A   0xE002             B        ??zclReceivedDefaultResponseHandler_5
   1429              else
   1430                senderAddressing.manufacturerSpecCode = frameDesc->manufacturerCode;
   \                     ??zclReceivedDefaultResponseHandler_4: (+1)
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0x88C0             LDRH     R0,[R0, #+6]
   \   000000A0   0x8428             STRH     R0,[R5, #+32]
   1431          
   1432              if (cluster->ZCL_DefaultRespInd)
   \                     ??zclReceivedDefaultResponseHandler_5: (+1)
   \   000000A2   0x69BB             LDR      R3,[R7, #+24]
   \   000000A4   0x0018             MOVS     R0,R3
   \   000000A6   0xD007             BEQ      ??zclReceivedDefaultResponseHandler_3
   1433                cluster->ZCL_DefaultRespInd(&senderAddressing, sizeof(ZCL_DefaultResp_t),
   1434                  apsData->asdu + frameDesc->headerLength );
   \   000000A8   0x3420             ADDS     R4,R4,#+32
   \   000000AA   0x6A60             LDR      R0,[R4, #+36]
   \   000000AC   0x9900             LDR      R1,[SP, #+0]
   \   000000AE   0x7809             LDRB     R1,[R1, #+0]
   \   000000B0   0x1842             ADDS     R2,R0,R1
   \   000000B2   0x2102             MOVS     R1,#+2
   \   000000B4   0xA802             ADD      R0,SP,#+8
   \   000000B6   0x4798             BLX      R3
   1435            }
   1436          
   1437            return true;
   \                     ??zclReceivedDefaultResponseHandler_3: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \                     ??zclReceivedDefaultResponseHandler_2: (+1)
   \   000000BA   0xB00D             ADD      SP,SP,#+52
   \   000000BC   0xBDF0             POP      {R4-R7,PC}       ;; return
   1438          }
   1439          
   1440          /***************************************************************************//**
   1441          \brief Checking if Default Response is valid for received frame
   1442          
   1443           2.4.12.2 ZCL specification
   1444           The default response command is generated when a device receives a unicast
   1445           command, there is no other relevant response specified for the command, and
   1446           either an error results or the Disable default response bit of its Frame control field
   1447           is set to 0.
   1448          
   1449           If a device receives a command in error through a broadcast or multicast
   1450           transmission, the command shall be discarded and the default response command
   1451           shall not be generated.
   1452          
   1453           The Default Response command should never been send responsing other Default Response
   1454           command.
   1455          
   1456          \param[in] auxData - pointer to auxilliary structure with data for frame formation
   1457          \return true in case if Defalt Response is valid for received frame, false otherwise.
   1458          ******************************************************************************/
   1459          static bool zclDefaultResponseIsValid(ZclAuxParseData_t *auxData)
   1460          {
   1461            ZclFrameDescriptor_t *incomingFrameDesc = auxData->frameDescriptor;
   1462            APS_DataInd_t *ind = auxData->ind;
   1463          
   1464            /* Application forces to send a DefaultResponse */
   1465            if (ZCL_SUCCESS_WITH_DEFAULT_RESPONSE_STATUS == auxData->commandStatus)
   1466            {
   1467              auxData->commandStatus = ZCL_SUCCESS_STATUS;
   1468              return true;
   1469            }
   1470            /* No Default Resonse on other Default Response */
   1471            if (isDefaultResponse(incomingFrameDesc))
   1472              return false;
   1473            /* Command received by error, as a result of broadcast or multicast transmission -
   1474               no Default Response */
   1475            if (APS_EXT_ADDRESS == ind->dstAddrMode ||
   1476                APS_GROUP_ADDRESS == ind->dstAddrMode ||
   1477                IS_BROADCAST_ADDR(ind->dstAddress.shortAddress))
   1478              return false;
   1479            /* Default Response SHOULD be sent if error occured during processing or on-demand request */
   1480            if (ZCL_SUCCESS_STATUS != auxData->commandStatus)
   1481              return true;
   1482            /* No Default Response if relevant response existed */
   1483            if (auxData->relevantResponse)
   1484              return false;
   1485            /* Default response if there is no relevant response, no errors and default response is allowed */
   1486            if (ZCL_FRAME_CONTROL_ENABLE_DEFAULT_RESPONSE == incomingFrameDesc->defaultResponse)
   1487              return true;
   1488            /* Otherwise - false */
   1489            return false;
   1490          }
   1491          
   1492          /**************************************************************************//**
   1493            \brief Looks for related request for incoming packet
   1494          
   1495            \param[in] auxParseData - pointer to structure with incoming packet
   1496          
   1497            \returns pointer to appropriate ZCL request
   1498          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1499          static ZCL_Request_t * zclFindAppropriateRequest(ZclAuxParseData_t *auxParseData)
   1500          {
   \                     zclFindAppropriateRequest: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1501            ZCL_Request_t *req;
   1502            ZclMmBufferDescriptor_t *descr = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   1503          
   1504            while ((descr = zclMmGetNextOutputMemDescriptor(descr)))
   \                     ??zclFindAppropriateRequest_0: (+1)
   \   00000006   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD022             BEQ      ??zclFindAppropriateRequest_1
   1505            {
   1506              req = descr->link;
   \   0000000E   0x6885             LDR      R5,[R0, #+8]
   1507              // check if this is a response
   1508              if (req->dstAddressing.clusterSide != getOwnClusterSideByIncomingCommandDirection(auxParseData->frameDescriptor->direction))
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x313C             ADDS     R1,R1,#+60
   \   00000014   0x6822             LDR      R2,[R4, #+0]
   \   00000016   0x788B             LDRB     R3,[R1, #+2]
   \   00000018   0x78D6             LDRB     R6,[R2, #+3]
   \   0000001A   0x42B3             CMP      R3,R6
   \   0000001C   0xD0F3             BEQ      ??zclFindAppropriateRequest_0
   1509                if (req->dstAddressing.sequenceNumber == auxParseData->frameDescriptor->sequenceNumber)
   \   0000001E   0x798B             LDRB     R3,[R1, #+6]
   \   00000020   0x7A12             LDRB     R2,[R2, #+8]
   \   00000022   0x4293             CMP      R3,R2
   \   00000024   0xD1EF             BNE      ??zclFindAppropriateRequest_0
   1510                  if (req->dstAddressing.clusterId == auxParseData->ind->clusterId)
   \   00000026   0x8809             LDRH     R1,[R1, #+0]
   \   00000028   0x6862             LDR      R2,[R4, #+4]
   \   0000002A   0x8FD2             LDRH     R2,[R2, #+62]
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD1EA             BNE      ??zclFindAppropriateRequest_0
   1511                  {
   1512                    if (ZCL_REQ_FLAG_CONF_RCVD & req->service.statusflags)
   \   00000030   0x7969             LDRB     R1,[R5, #+5]
   \   00000032   0x078A             LSLS     R2,R1,#+30
   \   00000034   0xD50A             BPL      ??zclFindAppropriateRequest_2
   1513                    {
   1514                      zclMmFreeMem(&descr->buf);  // free memory located by sent request
   \   00000036   0x3010             ADDS     R0,R0,#+16
   \   00000038   0x.... 0x....      BL       zclMmFreeMem
   1515                      if (NULL == zclMmGetNextOutputMemDescriptor(NULL))
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD105             BNE      ??zclFindAppropriateRequest_3
   1516                        zclStopResponseWaitTimer();
   \   00000046   0x.... 0x....      BL       zclStopResponseWaitTimer
   \   0000004A   0xE002             B        ??zclFindAppropriateRequest_3
   1517                    }
   1518                    else
   1519                      req->service.statusflags |= ZCL_REQ_FLAG_RESP_RCVD;
   \                     ??zclFindAppropriateRequest_2: (+1)
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x4308             ORRS     R0,R0,R1
   \   00000050   0x7168             STRB     R0,[R5, #+5]
   1520          
   1521                    return req;
   \                     ??zclFindAppropriateRequest_3: (+1)
   \   00000052   0x0028             MOVS     R0,R5
   1522                  }
   1523            }
   1524          
   1525            return NULL;
   \                     ??zclFindAppropriateRequest_1: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   1526          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     parserMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     zclParserDataConf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     gAssertDbgCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x0000C302         DC32     0xc302

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     gAssertDbgCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x0000C701         DC32     0xc701

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x0000FFF8         DC32     0xfff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     formReadAttributesResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     formReadAttributesStructuredResponse
   1527          
   1528          #endif // ZCL_SUPPORT == 1
   1529          //eof zclParser.c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SYS_ByteMemcpy
      16   ZCL_GetNextElement
        16   -> SYS_ByteMemcpy
        16   -> getElementLength
      16   ZCL_PutNextElement
        16   -> SYS_ByteMemcpy
        16   -> getElementLength
      40   formDiscoverAttributeExtendedsResponse
        40   -> zclGetNextAttribute
      32   formDiscoverCommandsGeneratedResponse
        32   -> ZCL_GetCluster
        32   -> zclGetNextCommand
      32   formDiscoverCommandsReceivedResponse
        32   -> ZCL_GetCluster
        32   -> zclGetNextCommand
      56   formReadAttributesResponse
        56   -> SYS_DefAssertCallbackError
        56   -> ZCL_GetAttributeLength
        56   -> zclAttributeEventInd
        56   -> zclReadAttributeValueSafe
      56   formReadAttributesStructuredResponse
        56   -> ZCL_GetAttributeLength
        56   -> zclAttributeEventInd
        56   -> zclReadIndexedAttribute
      12   formServerDataReq
      56   formWriteAttributeResponse
        56   -> SYS_DefAssertCallbackError
        56   -> ZCL_GetAttributeLength
        56   -> zclAttributeEventInd
        56   -> zclRemoteWriteAttributeValue
      12   formZclHeader
       0   getDstClusterSideByIncommingCommandDirection
      16   getElementLength
        16   -> ZCL_GetAttributeLength
        16   -> ZCL_GetDataTypeDescriptor
      80   parseDataInd
        80   -- Indirect call
        80   -> CS_ReadParameter
        80   -> __aeabi_memclr4
        80   -> formDiscoverAttributeExtendedsResponse
        80   -> formDiscoverCommandsGeneratedResponse
        80   -> formDiscoverCommandsReceivedResponse
        80   -> formWriteAttributeResponse
        80   -> parseZclHeader
        80   -> sendDefaultResponse
        80   -> sendRelevantResponse
        80   -> zclCommandInd
        80   -> zclConfigureReportingHandler
        80   -> zclFindAppropriateRequest
        80   -> zclGetNextAttribute
        80   -> zclGetSecurityTypeByClusterId
        80   -> zclMmFreeMem
        80   -> zclMmGetMem
        80   -> zclReadReportingConfigurationHandler
        80   -> zclReceivedDefaultResponseHandler
        80   -> zclReportInd
        80   -> zclResponseInd
      24   parseZclHeader
        24   -> __aeabi_memclr4
      40   sendDefaultResponse
        40   -> formServerDataReq
        40   -> formZclHeader
        40   -> zclApsDataReq
        40   -> zclMmGetMem
      24   sendRelevantResponse
        24   -> formServerDataReq
        24   -> formZclHeader
        24   -> getDstClusterSideByIncommingCommandDirection
        24   -> zclApsDataReq
      24   zclDataInd
        24   -> CS_ReadParameter
        24   -> SYS_ByteMemcpy
        24   -> SYS_DefAssertCallbackError
        24   -> putQueueElem
        24   -> zclMmGetMem
        24   -> zclPostTask
      16   zclFindAppropriateRequest
        16   -> zclMmFreeMem
        16   -> zclMmGetNextOutputMemDescriptor
        16   -> zclStopResponseWaitTimer
      48   zclFormRequest
        48   -> __aeabi_memclr4
        48   -> formZclHeader
       8   zclParserDataConf
         8   -> zclMmFreeMem
       0   zclParserInit
      16   zclParserTaskHandler
        16   -> deleteHeadQueueElem
        16   -> parseDataInd
        16   -> zclMmFreeMem
        16   -> zclPostTask
      72   zclReceivedDefaultResponseHandler
        72   -- Indirect call
        72   -> ZCL_GetCluster
        72   -> __aeabi_memcpy4
        72   -> getDstClusterSideByIncommingCommandDirection
        72   -> zclFindAppropriateRequest


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
      12  ?_0
      24  SYS_ByteMemcpy
      86  ZCL_GetNextElement
      60  ZCL_PutNextElement
     214  formDiscoverAttributeExtendedsResponse
     136  formDiscoverCommandsGeneratedResponse
     134  formDiscoverCommandsReceivedResponse
     196  formReadAttributesResponse
     184  formReadAttributesStructuredResponse
      90  formServerDataReq
     246  formWriteAttributeResponse
     102  formZclHeader
       8  getDstClusterSideByIncommingCommandDirection
     194  getElementLength
     828  parseDataInd
     122  parseZclHeader
       8  parserMem
     186  sendDefaultResponse
      94  sendRelevantResponse
     132  zclDataInd
      86  zclFindAppropriateRequest
      64  zclFormRequest
      10  zclParserDataConf
      14  zclParserInit
      58  zclParserTaskHandler
     190  zclReceivedDefaultResponseHandler

 
     8 bytes in section .bss
    12 bytes in section .rodata
 3 494 bytes in section .text
 
 3 494 bytes of CODE  memory
    12 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
