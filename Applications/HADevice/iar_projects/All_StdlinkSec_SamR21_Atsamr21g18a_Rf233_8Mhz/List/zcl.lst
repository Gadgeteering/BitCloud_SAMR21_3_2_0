###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:41:15
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zcl.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zcl.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\zcl.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\zcl.o
#
###############################################################################


   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void *SYS_ByteMemcpy(void *, void const *, uint16_t)
   \                     SYS_ByteMemcpy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0xE003             B        ??SYS_ByteMemcpy_0
   \                     ??SYS_ByteMemcpy_1: (+1)
   \   00000006   0x780C             LDRB     R4,[R1, #+0]
   \   00000008   0x701C             STRB     R4,[R3, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??SYS_ByteMemcpy_0: (+1)
   \   0000000E   0x0014             MOVS     R4,R2
   \   00000010   0x1E62             SUBS     R2,R4,#+1
   \   00000012   0x0424             LSLS     R4,R4,#+16
   \   00000014   0xD1F7             BNE      ??SYS_ByteMemcpy_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZCL\src\zcl.c
      1          /************************************************************************//**
      2            \file zcl.c
      3          
      4            \brief
      5              The ZCL implementation
      6          
      7              The file inmplements the ZCL
      8          
      9            \author
     10              Atmel Corporation: http://www.atmel.com \n
     11              Support email: avr@atmel.com
     12          
     13            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     14            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     15          
     16            \internal
     17              History:
     18              01.12.08 I. Fedina & A. Potashov - Created.
     19          ******************************************************************************/
     20          #if ZCL_SUPPORT == 1
     21          
     22          /******************************************************************************
     23                             Includes section
     24          ******************************************************************************/
     25          #include <zclDbg.h>
     26          #include <zcl.h>

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t getDstClusterSideByIncommingCommandDirection(uint8_t)
   \                     getDstClusterSideByIncommingCommandDirection: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x4180             SBCS     R0,R0,R0
   \   00000004   0x0FC0             LSRS     R0,R0,#+31
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t ZCL_GetNextSeqNumber(void)
   \                     ZCL_GetNextSeqNumber: (+1)
   \   00000000   0x....             LDR      R1,??DataTable6
   \   00000002   0x7808             LDRB     R0,[R1, #+0]
   \   00000004   0x1C42             ADDS     R2,R0,#+1
   \   00000006   0x700A             STRB     R2,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
     27          #include <zclInt.h>
     28          #include <zclParser.h>
     29          #include <zclAttributes.h>
     30          #include <clusters.h>
     31          #include <zclTaskManager.h>
     32          #include <zclMemoryManager.h>
     33          #include <sysQueue.h>
     34          #include <appFramework.h>
     35          #include <sysUtils.h>
     36          #include <aps.h>
     37          #include <configServer.h>
     38          #include <zclCommandAnalyzer.h>
     39          #if (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
     40            #include <zclSecurityManager.h>
     41          #endif // (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
     42          #if APP_USE_OTAU == 1
     43            #include <zclOTAUCluster.h>
     44          #endif // APP_USE_OTAU == 1
     45          
     46          #if defined(ATMEL_APPLICATION_SUPPORT)
     47          #include <colorSceneRemoteBindings.h>
     48          #include <N_EndDeviceRobustness.h>
     49          #include <N_Cmi.h>
     50          #endif
     51          #include <sysTimer.h>
     52          #include <sysIdleHandler.h>
     53          #include <apsmeBind.h>
     54          #include <sysAssert.h>
     55          
     56          /******************************************************************************
     57                                      Definitions section.
     58          ******************************************************************************/
     59          #define ALL_ATTRIBUTES_ARE_WRITTEN 1
     60          
     61          #define IS_NON_UNICAST_TRANSMISSION(apsDataInd) \
     62            (IS_BROADCAST_ADDR((apsDataInd)->dstAddress.shortAddress) || \
     63            (APS_GROUP_ADDRESS == (apsDataInd)->dstAddrMode))
     64          
     65          #define GET_BUFFER_DESCRIPTOR_BY_BUFFER(buffer) \
     66            GET_STRUCT_BY_FIELD_POINTER(ZclMmBufferDescriptor_t, buf, buffer);
     67          
     68          #define REPOST_TASK_TIMER_PERIOD   10
     69          
     70          /******************************************************************************
     71                                      Types section
     72          ******************************************************************************/
     73          typedef struct
     74          {
     75            SYS_Timer_t       waitTimer;
     76            SYS_Timer_t       reportTimer;
     77            SYS_Timer_t       repostTaskTimer;
     78            QueueDescriptor_t requestQueue;
     79          } ZclModuleMem_t;
     80          
     81          /******************************************************************************
     82                             Static functions prototype section
     83          ******************************************************************************/
     84          static ZCL_Status_t zclExecuteRequest(ZCL_Request_t *req, ZclMmBuffer_t *buf);
     85          
     86          static void attributeConfirm(APS_DataConf_t *conf);
     87          static void commandConfirm(APS_DataConf_t *conf);
     88          static void reportConfirm(APS_DataConf_t *conf);
     89          static void responseConfirm(APS_DataConf_t *conf);
     90          static void configureReportingResponseConfirm(APS_DataConf_t *conf);
     91          
     92          static void zclWaitTimerFired(void);
     93          static void zclReportTimerFired(void);
     94          static void zclRepostTaskTimerFired(void);
     95          static uint8_t addToReportPayload(uint8_t *reportPayload, ZclAttribute_t *attr);
     96          static void zclVerifyConfirmResponseOrder(APS_DataConf_t *conf);
     97          #ifndef ZAPPSI_HOST
     98          static void isZclBusyOrPollRequest(SYS_EventId_t eventId, SYS_EventData_t data);
     99          #if defined _ENDDEVICE_ && defined _SLEEP_WHEN_IDLE_
    100          static bool zclIsPollRequired(void);
    101          #endif
    102          #endif
    103          static void zclStartWaitResponseTimer(ZclMmBufferDescriptor_t *descriptor);
    104          
    105          /******************************************************************************
    106                             Global variables section
    107          ******************************************************************************/

   \                                 In section .bss, align 4
    108          ZclMem_t zclMem;
   \                     zclMem:
   \   00000000                      DS8 8
    109          
    110          /******************************************************************************
    111                             Static variables section
    112          ******************************************************************************/

   \                                 In section .data, align 4
    113          static ZclModuleMem_t zclModuleMem;
   \                     zclModuleMem:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000004C   0x00000000         DC32 0H
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000058   0x........         DC32 isZclBusyOrPollRequest
    114          #ifndef ZAPPSI_HOST
    115          static SYS_EventReceiver_t zdoBusyPollCheck = { .func = isZclBusyOrPollRequest};
    116          #endif
    117          
    118          /******************************************************************************
    119                             Implementation section
    120          ******************************************************************************/
    121          /**************************************************************************//**
    122            \brief Resets ZigBee Cluster Library.
    123          
    124            \param none.
    125            \return none.
    126          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    127          void ZCL_ResetReq(void)
    128          {
   \                     ZCL_ResetReq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    129          #ifndef ZAPPSI_HOST
    130            SYS_SubscribeToEvent(BC_EVENT_BUSY_REQUEST, &zdoBusyPollCheck);
   \   00000002   0x....             LDR      R4,??DataTable6_1
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x314C             ADDS     R1,R1,#+76
   \   00000008   0x2025             MOVS     R0,#+37
   \   0000000A   0x.... 0x....      BL       SYS_SubscribeToEvent
    131            SYS_SubscribeToEvent(BC_EVENT_POLL_REQUEST, &zdoBusyPollCheck);
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x314C             ADDS     R1,R1,#+76
   \   00000012   0x2038             MOVS     R0,#+56
   \   00000014   0x.... 0x....      BL       SYS_SubscribeToEvent
    132          #endif
    133            resetQueue(&zclModuleMem.requestQueue);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x64A0             STR      R0,[R4, #+72]
    134          
    135            zclStopResponseWaitTimer();
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       SYS_StopTimer
    136            SYS_StopTimer(&zclModuleMem.repostTaskTimer);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x3030             ADDS     R0,R0,#+48
   \   00000026   0x.... 0x....      BL       SYS_StopTimer
    137            SYS_InitTimer(&zclModuleMem.repostTaskTimer, TIMER_ONE_SHOT_MODE, REPOST_TASK_TIMER_PERIOD, zclRepostTaskTimerFired);
   \   0000002A   0x....             LDR      R3,??DataTable7
   \   0000002C   0x220A             MOVS     R2,#+10
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x3030             ADDS     R0,R0,#+48
   \   00000034   0x.... 0x....      BL       SYS_InitTimer
    138            SYS_StopTimer(&zclModuleMem.reportTimer);
   \   00000038   0x3418             ADDS     R4,R4,#+24
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       SYS_StopTimer
    139          
    140            zclParserInit();
   \   00000040   0x.... 0x....      BL       zclParserInit
    141          
    142          #if (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
    143            ZCL_ResetSecurity();
   \   00000044   0x.... 0x....      BL       ZCL_ResetSecurity
    144          #endif // (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
    145          }
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    146          
    147          /**************************************************************************//**
    148            \brief Register device application.
    149          
    150            \param[in] endpoint - device descriptor.
    151            \return none.
    152          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    153          void ZCL_RegisterEndpoint(ZCL_DeviceEndpoint_t *endpoint)
    154          {
   \                     ZCL_RegisterEndpoint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    155            endpoint->service.apsEndpoint.simpleDescriptor = &endpoint->simpleDescriptor;
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x3114             ADDS     R1,R1,#+20
   \   00000006   0x6081             STR      R1,[R0, #+8]
    156            endpoint->service.apsEndpoint.APS_DataInd = zclDataInd;
   \   00000008   0x....             LDR      R1,??DataTable7_1
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
    157          
    158            APS_RegisterEndpointReq(&endpoint->service.apsEndpoint);
   \   0000000C   0x.... 0x....      BL       APS_RegisterEndpointReq
    159          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    160          
    161          /**************************************************************************//**
    162            \brief Unregister device application.
    163          
    164            \param[in] endpoint - device descriptor.
    165            \return none.
    166          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          void ZCL_UnregisterEndpoint(ZCL_DeviceEndpoint_t *endpoint)
    168          {
   \                     ZCL_UnregisterEndpoint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    169            endpoint->service.unregEpReq.endpoint = endpoint->simpleDescriptor.endpoint;
   \   00000002   0x7D01             LDRB     R1,[R0, #+20]
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    170            APS_UnregisterEndpointReq(&endpoint->service.unregEpReq);
   \   00000006   0x.... 0x....      BL       APS_UnregisterEndpointReq
    171          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    172          
    173          /**************************************************************************//**
    174            \brief Request to read/write/configure an attribute on a remote device.
    175          
    176            \param req - attribute descriptor.
    177            \return none
    178          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    179          void ZCL_AttributeReq(ZCL_Request_t *req)
    180          {
   \                     ZCL_AttributeReq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    181            req->service.requestType = ZCL_STANDARD_REQ_TYPE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7120             STRB     R0,[R4, #+4]
    182            req->dstAddressing.sequenceNumber = ZCL_GetNextSeqNumber();
   \   00000008   0x.... 0x....      BL       ZCL_GetNextSeqNumber
   \   0000000C   0x2142             MOVS     R1,#+66
   \   0000000E   0x5460             STRB     R0,[R4, R1]
    183            putQueueElem(&zclModuleMem.requestQueue, req);
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0x....             LDR      R0,??DataTable7_2
   \   00000014   0x.... 0x....      BL       putQueueElem
    184            zclPostTask(ZCL_SUBTASK_ID);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       zclPostTask
    185          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    186          
    187          /**************************************************************************//**
    188            \brief Request to send a cluster command to a remote device.
    189          
    190            \param req - request descriptor.
    191            \return none.
    192          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    193          void ZCL_CommandReq(ZCL_Request_t *req)
    194          {
   \                     ZCL_CommandReq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    195            req->service.requestType = ZCL_SPECIAL_REQ_TYPE;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7101             STRB     R1,[R0, #+4]
    196            putQueueElem(&zclModuleMem.requestQueue, req);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x....             LDR      R0,??DataTable7_2
   \   0000000A   0x.... 0x....      BL       putQueueElem
    197            zclPostTask(ZCL_SUBTASK_ID);
   \   0000000E   0x.... 0x....      BL       ?Subroutine1
    198          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      BL       zclPostTask
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    199          
    200          /*************************************************************************//**
    201           \brief Starts attributes reporting if any attributes are configured for
    202             reporting by application. Restarts reporting if it was in progress.
    203          
    204           \ingroup zcl_common
    205          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    206          void ZCL_StartReporting(void)
    207          {
   \                     ZCL_StartReporting: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x43F6             MVNS     R6,R6            ;; #-1
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    208            uint32_t  minTimeout = ~0ul;
    209            ApsBindingEntry_t *bindingEntry = NULL;
    210          
    211            /* Go through binding table to activate default attribute reporting */
    212            while (NULL != (bindingEntry = APS_NextBindingEntry(bindingEntry)))
   \                     ??ZCL_StartReporting_0: (+1)
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0x.... 0x....      BL       APS_NextBindingEntry
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD03C             BEQ      ??ZCL_StartReporting_1
    213            {
    214              if (IS_ACTIVE_BINDING_ENTRY(bindingEntry))
   \   00000016   0x3020             ADDS     R0,R0,#+32
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x28A4             CMP      R0,#+164
   \   0000001C   0xD1F5             BNE      ??ZCL_StartReporting_0
    215              {
    216                ZCL_DeviceEndpoint_t *endpoint = zclGetEndpoint(bindingEntry->srcEndpoint);
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x7A00             LDRB     R0,[R0, #+8]
   \   00000022   0x.... 0x....      BL       zclGetEndpoint
   \   00000026   0x0004             MOVS     R4,R0
    217                ZCL_Cluster_t *cluster = ZCL_GetCluster(bindingEntry->srcEndpoint, bindingEntry->clusterId, ZCL_CLUSTER_SIDE_SERVER);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x8941             LDRH     R1,[R0, #+10]
   \   0000002E   0x7A00             LDRB     R0,[R0, #+8]
   \   00000030   0x.... 0x....      BL       ZCL_GetCluster
   \   00000034   0x0007             MOVS     R7,R0
    218                ZclAttribute_t *attr;
    219          
    220                if (!endpoint || !cluster)
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD0E7             BEQ      ??ZCL_StartReporting_0
   \   0000003A   0x2F00             CMP      R7,#+0
   \   0000003C   0xD0E5             BEQ      ??ZCL_StartReporting_0
    221                  continue;
    222          
    223                attr = (ZclAttribute_t *)cluster->attributes;
   \   0000003E   0x687C             LDR      R4,[R7, #+4]
    224                // For all attributes
    225                for (uint8_t attrIndex = 0; attrIndex < cluster->attributesAmount; attrIndex++)
   \   00000040   0x2500             MOVS     R5,#+0
   \                     ??ZCL_StartReporting_2: (+1)
   \   00000042   0x78F8             LDRB     R0,[R7, #+3]
   \   00000044   0xB2ED             UXTB     R5,R5
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD2DF             BCS      ??ZCL_StartReporting_0
    226                {
    227                  if (attr->properties & ZCL_REPORTABLE_ATTRIBUTE)
   \   0000004A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004C   0x07C0             LSLS     R0,R0,#+31
   \   0000004E   0xD519             BPL      ??ZCL_StartReporting_3
    228                  {
    229                    uint8_t attrLength = ZCL_GetAttributeLength(attr->type, (uint8_t *)&attr->value);
    230                    uint8_t *reportCounterPtr = (uint8_t *)attr + ATTRIBUTE_ID_SIZE + ATTRIBUTE_TYPE_SIZE +
    231                                                sizeof(uint8_t) + attrLength; // properties + value
    232                    ZclReportableAttributeTail_t *tail = (ZclReportableAttributeTail_t *)reportCounterPtr;
   \   00000050   0x1D21             ADDS     R1,R4,#+4
   \   00000052   0x78A0             LDRB     R0,[R4, #+2]
   \   00000054   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000058   0xB2C0             UXTB     R0,R0
   \   0000005A   0x1820             ADDS     R0,R4,R0
   \   0000005C   0x1D00             ADDS     R0,R0,#+4
    233          
    234                    attr->properties |= ZCL_REPORTING_CONFIGURED;
   \   0000005E   0x78E1             LDRB     R1,[R4, #+3]
   \   00000060   0x2204             MOVS     R2,#+4
   \   00000062   0x430A             ORRS     R2,R2,R1
   \   00000064   0x70E2             STRB     R2,[R4, #+3]
    235                    tail->reportCounter = 0;
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x7001             STRB     R1,[R0, #+0]
   \   0000006A   0x7041             STRB     R1,[R0, #+1]
    236                    minTimeout = MIN(minTimeout, tail->maxReportInterval);
   \   0000006C   0x7901             LDRB     R1,[R0, #+4]
   \   0000006E   0x7942             LDRB     R2,[R0, #+5]
   \   00000070   0x0612             LSLS     R2,R2,#+24
   \   00000072   0x0C12             LSRS     R2,R2,#+16
   \   00000074   0x4311             ORRS     R1,R1,R2
   \   00000076   0x428E             CMP      R6,R1
   \   00000078   0xD304             BCC      ??ZCL_StartReporting_3
   \   0000007A   0x7906             LDRB     R6,[R0, #+4]
   \   0000007C   0x7941             LDRB     R1,[R0, #+5]
   \   0000007E   0x0609             LSLS     R1,R1,#+24
   \   00000080   0x0C09             LSRS     R1,R1,#+16
   \   00000082   0x430E             ORRS     R6,R6,R1
    237                  }
    238                  attr = jumpToNextAttribute(attr);
   \                     ??ZCL_StartReporting_3: (+1)
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       jumpToNextAttribute
   \   0000008A   0x0004             MOVS     R4,R0
    239                }
   \   0000008C   0x1C6D             ADDS     R5,R5,#+1
   \   0000008E   0xE7D8             B        ??ZCL_StartReporting_2
    240              }
    241            }
    242          
    243            if (~0ul != minTimeout)
   \                     ??ZCL_StartReporting_1: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000094   0x4286             CMP      R6,R0
   \   00000096   0xD00E             BEQ      ??ZCL_StartReporting_4
    244            {
    245              SYS_InitTimer(&zclModuleMem.reportTimer, TIMER_ONE_SHOT_MODE, minTimeout * 1000, zclReportTimerFired);
   \   00000098   0x....             LDR      R4,??DataTable6_1
   \   0000009A   0x....             LDR      R3,??DataTable9
   \   0000009C   0x20FA             MOVS     R0,#+250
   \   0000009E   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \   000000A0   0x4346             MULS     R6,R0,R6
   \   000000A2   0x0032             MOVS     R2,R6
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x3018             ADDS     R0,R0,#+24
   \   000000AA   0x.... 0x....      BL       SYS_InitTimer
    246              SYS_StartTimer(&zclModuleMem.reportTimer);
   \   000000AE   0x3418             ADDS     R4,R4,#+24
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       SYS_StartTimer
    247            }
    248          }
   \                     ??ZCL_StartReporting_4: (+1)
   \   000000B6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    249          
    250          /**************************************************************************//**
    251            \brief Stops response wait timer
    252          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          void zclStopResponseWaitTimer(void)
    254          {
   \                     zclStopResponseWaitTimer: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255            SYS_StopTimer(&zclModuleMem.waitTimer);
   \   00000002   0x....             LDR      R0,??DataTable6_1
   \   00000004   0x.... 0x....      BL       SYS_StopTimer
    256          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    257          
    258          /**************************************************************************//**
    259          \brief Execute ZCL request
    260          
    261          \param[in] req - request
    262          \param[in] buf - memory buffer
    263          
    264          \return ZCL_SUCCESS_STATUS - success case
    265                     ZCL_INVALID_PARAMETER_STATUS - when req has undefined cluster
    266          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    267          static ZCL_Status_t zclExecuteRequest(ZCL_Request_t *req, ZclMmBuffer_t *buf)
    268          {
   \                     zclExecuteRequest: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
    269            ZCL_Cluster_t *cluster;
    270            uint8_t headerLength;
    271            ZclCommand_t *command;
    272            APS_DataReq_t *apsdr = &buf->primitive.apsDataReq;
    273          
    274            cluster = ZCL_GetCluster(req->endpointId,
    275                                    req->dstAddressing.clusterId,
    276                                    getSrcClusterSideByDstClusterSide(req->dstAddressing.clusterSide));
   \   00000008   0x0035             MOVS     R5,R6
   \   0000000A   0x353A             ADDS     R5,R5,#+58
   \   0000000C   0x7928             LDRB     R0,[R5, #+4]
   \   0000000E   0x1E42             SUBS     R2,R0,#+1
   \   00000010   0x4192             SBCS     R2,R2,R2
   \   00000012   0x0FD2             LSRS     R2,R2,#+31
   \   00000014   0x8869             LDRH     R1,[R5, #+2]
   \   00000016   0x7BA8             LDRB     R0,[R5, #+14]
   \   00000018   0x.... 0x....      BL       ZCL_GetCluster
   \   0000001C   0x9003             STR      R0,[SP, #+12]
    277            if (NULL == cluster)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD106             BNE      ??zclExecuteRequest_0
    278            {
    279              SYS_E_ASSERT_ERROR(false, ZCL_UNDEFINED_CLUSTER_IN_REQUEST);
   \   00000022   0x....             LDR      R0,??DataTable9_1  ;; 0xc204
   \   00000024   0x....             LDR      R1,??DataTable9_2
   \   00000026   0x8008             STRH     R0,[R1, #+0]
   \   00000028   0x.... 0x....      BL       SYS_DefAssertCallbackError
    280              return ZCL_INVALID_PARAMETER_STATUS;
   \   0000002C   0x20FF             MOVS     R0,#+255
   \   0000002E   0xE0CF             B        ??zclExecuteRequest_1
    281            }
    282            /* if cluster is undefined, control breaks here with failure status */
    283          
    284            req->service.statusflags = ZCL_REQ_INIT_VAL;
   \                     ??zclExecuteRequest_0: (+1)
   \   00000030   0x1D37             ADDS     R7,R6,#+4
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7078             STRB     R0,[R7, #+1]
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x3058             ADDS     R0,R0,#+88
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0x303B             ADDS     R0,R0,#+59
   \   0000003E   0x0021             MOVS     R1,R4
   \   00000040   0x3130             ADDS     R1,R1,#+48
   \   00000042   0x6248             STR      R0,[R1, #+36]
    285          
    286            // initialize primitive
    287            apsdr->asdu = buf->frame + getZclAsduOffset();
    288          
    289            // form APS Data Req primitive
    290            apsdr->srcEndpoint = req->endpointId;
   \   00000044   0x7BA8             LDRB     R0,[R5, #+14]
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x3130             ADDS     R1,R1,#+48
   \   0000004A   0x7788             STRB     R0,[R1, #+30]
    291            apsdr->dstAddrMode = req->dstAddressing.addrMode;
   \   0000004C   0x7F38             LDRB     R0,[R7, #+28]
   \   0000004E   0x2130             MOVS     R1,#+48
   \   00000050   0x5460             STRB     R0,[R4, R1]
    292            apsdr->dstAddress  = req->dstAddressing.addr;
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x3038             ADDS     R0,R0,#+56
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0x3128             ADDS     R1,R1,#+40
   \   0000005A   0x2210             MOVS     R2,#+16
   \   0000005C   0x.... 0x....      BL       __aeabi_memcpy4
    293            apsdr->dstEndpoint = req->dstAddressing.endpointId;
   \   00000060   0x7828             LDRB     R0,[R5, #+0]
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x3130             ADDS     R1,R1,#+48
   \   00000066   0x7608             STRB     R0,[R1, #+24]
    294            apsdr->clusterId   = req->dstAddressing.clusterId;
   \   00000068   0x8868             LDRH     R0,[R5, #+2]
   \   0000006A   0x0021             MOVS     R1,R4
   \   0000006C   0x3130             ADDS     R1,R1,#+48
   \   0000006E   0x8388             STRH     R0,[R1, #+28]
    295          
    296            if ((PROFILE_ID_LIGHT_LINK == req->dstAddressing.profileId) &&
    297               (ZLL_COMMISSIONING_CLUSTER_ID != req->dstAddressing.clusterId))
   \   00000070   0x8EB8             LDRH     R0,[R7, #+52]
   \   00000072   0x....             LDR      R1,??DataTable10  ;; 0xc05e
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD106             BNE      ??zclExecuteRequest_2
   \   00000078   0x8869             LDRH     R1,[R5, #+2]
   \   0000007A   0x2280             MOVS     R2,#+128
   \   0000007C   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \   0000007E   0x4291             CMP      R1,R2
   \   00000080   0xD001             BEQ      ??zclExecuteRequest_2
    298            {
    299              apsdr->profileId = PROFILE_ID_HOME_AUTOMATION;
   \   00000082   0x2082             MOVS     R0,#+130
   \   00000084   0x0040             LSLS     R0,R0,#+1        ;; #+260
    300            }
    301            else
    302            {
    303              apsdr->profileId = req->dstAddressing.profileId;
   \                     ??zclExecuteRequest_2: (+1)
   \   00000086   0x0021             MOVS     R1,R4
   \   00000088   0x3130             ADDS     R1,R1,#+48
   \   0000008A   0x8348             STRH     R0,[R1, #+26]
   \   0000008C   0x7838             LDRB     R0,[R7, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD113             BNE      ??zclExecuteRequest_3
    304            }
    305          
    306            if (ZCL_STANDARD_REQ_TYPE == req->service.requestType)
    307            {
    308              apsdr->APS_DataConf = attributeConfirm;
   \   00000092   0x....             LDR      R0,??DataTable10_1
   \   00000094   0x0021             MOVS     R1,R4
   \   00000096   0x3158             ADDS     R1,R1,#+88
   \   00000098   0x6048             STR      R0,[R1, #+4]
   \   0000009A   0x7BE8             LDRB     R0,[R5, #+15]
   \   0000009C   0x280A             CMP      R0,#+10
   \   0000009E   0xD001             BEQ      ??zclExecuteRequest_4
   \   000000A0   0x2805             CMP      R0,#+5
   \   000000A2   0xD105             BNE      ??zclExecuteRequest_5
    309              if ((ZCL_REPORT_ATTRIBUTES_COMMAND_ID == req->id) ||
    310                  (ZCL_WRITE_ATTRIBUTES_NO_RESPONSE_COMMAND_ID == req->id))
    311              {
    312                if(ZCL_FRAME_CONTROL_ENABLE_DEFAULT_RESPONSE == req->defaultResponse)
   \                     ??zclExecuteRequest_4: (+1)
   \   000000A4   0x7C68             LDRB     R0,[R5, #+17]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD147             BNE      ??zclExecuteRequest_6
    313                  req->service.statusflags |= ZCL_REQ_DEFAULT_RESP_RQRD | ZCL_REQ_RESP_RQRD;
   \   000000AA   0x7878             LDRB     R0,[R7, #+1]
   \   000000AC   0x210C             MOVS     R1,#+12
   \   000000AE   0xE001             B.N      ??zclExecuteRequest_7
    314              }
    315              else
    316                req->service.statusflags |= ZCL_REQ_RESP_RQRD;
   \                     ??zclExecuteRequest_5: (+1)
   \   000000B0   0x7878             LDRB     R0,[R7, #+1]
   \   000000B2   0x2104             MOVS     R1,#+4
   \                     ??zclExecuteRequest_7: (+1)
   \   000000B4   0x4301             ORRS     R1,R1,R0
   \   000000B6   0x7079             STRB     R1,[R7, #+1]
   \   000000B8   0xE03F             B        ??zclExecuteRequest_6
    317            }
    318            else
    319            {
    320              apsdr->APS_DataConf = commandConfirm;
   \                     ??zclExecuteRequest_3: (+1)
   \   000000BA   0x....             LDR      R0,??DataTable10_2
   \   000000BC   0x0021             MOVS     R1,R4
   \   000000BE   0x3158             ADDS     R1,R1,#+88
   \   000000C0   0x6048             STR      R0,[R1, #+4]
    321          
    322              command = zclGetCommandByCluster(cluster,
    323                                               getOutgoingCommandDirectionByDstClusterSide(req->dstAddressing.clusterSide),
    324                                               req->id);
   \   000000C2   0x7BEA             LDRB     R2,[R5, #+15]
   \   000000C4   0x7929             LDRB     R1,[R5, #+4]
   \   000000C6   0x9803             LDR      R0,[SP, #+12]
   \   000000C8   0x.... 0x....      BL       zclGetCommandByCluster
   \   000000CC   0x9000             STR      R0,[SP, #+0]
    325          
    326              if (command && zclIsResponseRequiredByAddrMode(req))
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD023             BEQ      ??zclExecuteRequest_8
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0x.... 0x....      BL       zclIsResponseRequiredByAddrMode
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD01E             BEQ      ??zclExecuteRequest_8
    327              {
    328                if (ZCL_RESPONSE_CONTROLLED_BY_PAYLOAD == command->options.waitingResponse)
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   \   000000DE   0x7840             LDRB     R0,[R0, #+1]
   \   000000E0   0x0700             LSLS     R0,R0,#+28
   \   000000E2   0x0F80             LSRS     R0,R0,#+30
   \   000000E4   0x2802             CMP      R0,#+2
   \   000000E6   0xD10C             BNE      ??zclExecuteRequest_9
    329                  req->service.statusflags |= zclIsResponseRequiredByPayload(req->dstAddressing.clusterId, req->id,
    330                  req->dstAddressing.clusterSide, req->requestPayload) ? ZCL_REQ_RESP_RQRD : 0;
   \   000000E8   0x6CF3             LDR      R3,[R6, #+76]
   \   000000EA   0x792A             LDRB     R2,[R5, #+4]
   \   000000EC   0x7BE9             LDRB     R1,[R5, #+15]
   \   000000EE   0x8868             LDRH     R0,[R5, #+2]
   \   000000F0   0x.... 0x....      BL       zclIsResponseRequiredByPayload
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD000             BEQ      ??zclExecuteRequest_10
   \   000000F8   0x2004             MOVS     R0,#+4
   \                     ??zclExecuteRequest_10: (+1)
   \   000000FA   0x7879             LDRB     R1,[R7, #+1]
   \   000000FC   0x4308             ORRS     R0,R0,R1
   \   000000FE   0x7078             STRB     R0,[R7, #+1]
   \   00000100   0xE00B             B        ??zclExecuteRequest_8
    331                else if (ZCL_THERE_IS_RELEVANT_RESPONSE == command->options.waitingResponse)
   \                     ??zclExecuteRequest_9: (+1)
   \   00000102   0x2801             CMP      R0,#+1
   \   00000104   0xD102             BNE      ??zclExecuteRequest_11
    332                  req->service.statusflags |= ZCL_REQ_RESP_RQRD;
   \   00000106   0x7878             LDRB     R0,[R7, #+1]
   \   00000108   0x2104             MOVS     R1,#+4
   \   0000010A   0xE004             B        ??zclExecuteRequest_12
    333                else if (ZCL_FRAME_CONTROL_ENABLE_DEFAULT_RESPONSE == req->defaultResponse)
   \                     ??zclExecuteRequest_11: (+1)
   \   0000010C   0x7C68             LDRB     R0,[R5, #+17]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD103             BNE      ??zclExecuteRequest_8
    334                  req->service.statusflags |= ZCL_REQ_RESP_RQRD | ZCL_REQ_DEFAULT_RESP_RQRD;
   \   00000112   0x7878             LDRB     R0,[R7, #+1]
   \   00000114   0x210C             MOVS     R1,#+12
   \                     ??zclExecuteRequest_12: (+1)
   \   00000116   0x4301             ORRS     R1,R1,R0
   \   00000118   0x7079             STRB     R1,[R7, #+1]
    335              }
    336          
    337              apsdr->txOptions.acknowledgedTransmission = 0;
   \                     ??zclExecuteRequest_8: (+1)
   \   0000011A   0x2058             MOVS     R0,#+88
   \   0000011C   0x5C21             LDRB     R1,[R4, R0]
   \   0000011E   0x20FB             MOVS     R0,#+251
   \   00000120   0x4008             ANDS     R0,R0,R1
   \   00000122   0x2158             MOVS     R1,#+88
   \   00000124   0x5460             STRB     R0,[R4, R1]
    338              if (command && command->options.ackRequest)
   \   00000126   0x9900             LDR      R1,[SP, #+0]
   \   00000128   0x2900             CMP      R1,#+0
   \   0000012A   0xD006             BEQ      ??zclExecuteRequest_6
   \   0000012C   0x7849             LDRB     R1,[R1, #+1]
   \   0000012E   0x06C9             LSLS     R1,R1,#+27
   \   00000130   0xD503             BPL      ??zclExecuteRequest_6
    339                apsdr->txOptions.acknowledgedTransmission = 1;
   \   00000132   0x2104             MOVS     R1,#+4
   \   00000134   0x4301             ORRS     R1,R1,R0
   \   00000136   0x2058             MOVS     R0,#+88
   \   00000138   0x5421             STRB     R1,[R4, R0]
   \                     ??zclExecuteRequest_6: (+1)
   \   0000013A   0x7F38             LDRB     R0,[R7, #+28]
   \   0000013C   0x2802             CMP      R0,#+2
   \   0000013E   0xD104             BNE      ??zclExecuteRequest_13
   \   00000140   0x8CB8             LDRH     R0,[R7, #+36]
   \   00000142   0x....             LDR      R1,??DataTable10_3  ;; 0xfff8
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD202             BCS      ??zclExecuteRequest_14
   \   00000148   0xE007             B        ??zclExecuteRequest_15
   \                     ??zclExecuteRequest_13: (+1)
   \   0000014A   0x2801             CMP      R0,#+1
   \   0000014C   0xD105             BNE      ??zclExecuteRequest_15
    340            }
    341          
    342            if ((APS_SHORT_ADDRESS == req->dstAddressing.addrMode &&
    343                 IS_BROADCAST_ADDR(req->dstAddressing.addr.shortAddress))
    344          #ifdef _APS_MULTICAST_
    345                 || APS_GROUP_ADDRESS == req->dstAddressing.addrMode
    346          #endif
    347                )
    348              apsdr->txOptions.acknowledgedTransmission = 0;
   \                     ??zclExecuteRequest_14: (+1)
   \   0000014E   0x2058             MOVS     R0,#+88
   \   00000150   0x5C20             LDRB     R0,[R4, R0]
   \   00000152   0x21FB             MOVS     R1,#+251
   \   00000154   0x4001             ANDS     R1,R1,R0
   \   00000156   0x2058             MOVS     R0,#+88
   \   00000158   0x5421             STRB     R1,[R4, R0]
    349          
    350            apsdr->txOptions.noRouteDiscovery = 0;
   \                     ??zclExecuteRequest_15: (+1)
   \   0000015A   0x2058             MOVS     R0,#+88
   \   0000015C   0x5C20             LDRB     R0,[R4, R0]
   \   0000015E   0x0640             LSLS     R0,R0,#+25
   \   00000160   0x0E40             LSRS     R0,R0,#+25
   \   00000162   0x2158             MOVS     R1,#+88
   \   00000164   0x5460             STRB     R0,[R4, R1]
    351            apsdr->radius = 0;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x0021             MOVS     R1,R4
   \   0000016A   0x3158             ADDS     R1,R1,#+88
   \   0000016C   0x7048             STRB     R0,[R1, #+1]
    352            // ---
    353            // form request header
    354            headerLength = zclFormRequest(apsdr,
    355                                          req->service.requestType,
    356                                          getOutgoingCommandDirectionByDstClusterSide(req->dstAddressing.clusterSide),
    357                                          req->id,
    358                                          req->defaultResponse,
    359                                          req->dstAddressing.manufacturerSpecCode,
    360                                          req->dstAddressing.sequenceNumber);
   \   0000016E   0x7A28             LDRB     R0,[R5, #+8]
   \   00000170   0x9002             STR      R0,[SP, #+8]
   \   00000172   0x88E8             LDRH     R0,[R5, #+6]
   \   00000174   0x9001             STR      R0,[SP, #+4]
   \   00000176   0x7C68             LDRB     R0,[R5, #+17]
   \   00000178   0x9000             STR      R0,[SP, #+0]
   \   0000017A   0x7BEB             LDRB     R3,[R5, #+15]
   \   0000017C   0x792A             LDRB     R2,[R5, #+4]
   \   0000017E   0x7839             LDRB     R1,[R7, #+0]
   \   00000180   0x0020             MOVS     R0,R4
   \   00000182   0x.... 0x....      BL       zclFormRequest
   \   00000186   0x0007             MOVS     R7,R0
    361          
    362            // copy request payload
    363            SYS_BYTE_MEMCPY(apsdr->asdu + headerLength, req->requestPayload, req->requestLength);
   \   00000188   0x7C2A             LDRB     R2,[R5, #+16]
   \   0000018A   0x6CF1             LDR      R1,[R6, #+76]
   \   0000018C   0x0020             MOVS     R0,R4
   \   0000018E   0x3030             ADDS     R0,R0,#+48
   \   00000190   0x6A40             LDR      R0,[R0, #+36]
   \   00000192   0x19C0             ADDS     R0,R0,R7
   \   00000194   0x.... 0x....      BL       SYS_ByteMemcpy
    364            // set frame payload size
    365            apsdr->asduLength = headerLength + req->requestLength;
   \   00000198   0x7C28             LDRB     R0,[R5, #+16]
   \   0000019A   0x1838             ADDS     R0,R7,R0
   \   0000019C   0x0021             MOVS     R1,R4
   \   0000019E   0x3130             ADDS     R1,R1,#+48
   \   000001A0   0x8408             STRH     R0,[R1, #+32]
    366          
    367          #ifdef _APS_FRAGMENTATION_
    368            if(apsdr->txOptions.securityEnabledTransmission)
   \   000001A2   0x2158             MOVS     R1,#+88
   \   000001A4   0x5C61             LDRB     R1,[R4, R1]
   \   000001A6   0x07CA             LSLS     R2,R1,#+31
   \   000001A8   0xD503             BPL      ??zclExecuteRequest_16
    369            {
    370              if (apsdr->asduLength > APS_MAX_ASDU_SIZE)
   \   000001AA   0xB280             UXTH     R0,R0
   \   000001AC   0x283E             CMP      R0,#+62
   \   000001AE   0xD307             BCC      ??zclExecuteRequest_17
   \   000001B0   0xE002             B        ??zclExecuteRequest_18
    371                apsdr->txOptions.acknowledgedTransmission = 1;
    372            }
    373            else /* APS security frame and APS footer are not required*/
    374            {
    375              if (apsdr->asduLength > APS_MAX_NON_SECURITY_ASDU_SIZE)
   \                     ??zclExecuteRequest_16: (+1)
   \   000001B2   0xB280             UXTH     R0,R0
   \   000001B4   0x2852             CMP      R0,#+82
   \   000001B6   0xD303             BCC      ??zclExecuteRequest_17
    376                apsdr->txOptions.acknowledgedTransmission = 1;
   \                     ??zclExecuteRequest_18: (+1)
   \   000001B8   0x2004             MOVS     R0,#+4
   \   000001BA   0x4308             ORRS     R0,R0,R1
   \   000001BC   0x2158             MOVS     R1,#+88
   \   000001BE   0x5460             STRB     R0,[R4, R1]
    377            }
    378          #endif // _APS_FRAGMENTATION_
    379          
    380            //send command
    381            zclApsDataReq(apsdr, cluster->options.security);
   \                     ??zclExecuteRequest_17: (+1)
   \   000001C0   0x9803             LDR      R0,[SP, #+12]
   \   000001C2   0x7880             LDRB     R0,[R0, #+2]
   \   000001C4   0x0781             LSLS     R1,R0,#+30
   \   000001C6   0x0FC9             LSRS     R1,R1,#+31
   \   000001C8   0x0020             MOVS     R0,R4
   \   000001CA   0x.... 0x....      BL       zclApsDataReq
    382          
    383            return ZCL_SUCCESS_STATUS;
   \   000001CE   0x2000             MOVS     R0,#+0
   \                     ??zclExecuteRequest_1: (+1)
   \   000001D0   0xB005             ADD      SP,SP,#+20
   \   000001D2   0xBDF0             POP      {R4-R7,PC}       ;; return
    384          }
    385          
    386          /**************************************************************************//**
    387            \brief Task handler of ZCL component.
    388          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    389          void zclTaskHandler(void)
    390          {
   \                     zclTaskHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0xE007             B        ??zclTaskHandler_0
    391            ZclMmBuffer_t *reqMem;
    392            ZCL_Request_t *req;
    393            ZclMmBufferDescriptor_t *descr;
    394          
    395            while (NULL != (req = (ZCL_Request_t *)getQueueElem(&zclModuleMem.requestQueue)))
    396            {
    397              // Try to get memory for request
    398              reqMem = zclMmGetMem(ZCL_OUTPUT_DATA_BUFFER);
    399              if (!reqMem)
    400              {
    401                // no free memory buffers, try later
    402                SYS_StartTimer(&zclModuleMem.repostTaskTimer);
    403                return;
    404              }
    405          
    406              deleteQueueElem(&zclModuleMem.requestQueue, req);
    407          
    408              // verify that request fits into zcl memory buffer
    409              if ((uint16_t)req->requestLength > ZCL_MAX_TX_ZSDU_SIZE)
    410              {
    411                if (req->ZCL_Notify)
    412                {
    413                  SYS_E_ASSERT_WARN(false, ZCL_BUFFER_SIZE_IS_TOO_LOW);
    414                  req->notify.id = ZCL_APS_CONFIRM_ID;
    415                  req->notify.status = ZCL_INSUFFICIENT_SPACE_STATUS;
    416                  req->ZCL_Notify(&req->notify);
    417                }
    418          	  else
    419          	  {
    420          	    SYS_E_ASSERT_FATAL(false, ZCL_BUFFER_SIZE_IS_TOO_LOW);
   \                     ??zclTaskHandler_1: (+1)
   \   00000006   0x....             LDR      R0,??DataTable10_4  ;; 0xc302
   \   00000008   0x....             LDR      R1,??DataTable9_2
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
   \   0000000C   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    421          	  }
    422                zclMmFreeMem(reqMem);
   \                     ??zclTaskHandler_2: (+1)
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x.... 0x....      BL       zclMmFreeMem
    423                continue;
   \                     ??zclTaskHandler_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable10_5
   \   00000018   0x6C87             LDR      R7,[R0, #+72]
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD02E             BEQ      ??zclTaskHandler_3
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       zclMmGetMem
   \   00000024   0x0006             MOVS     R6,R0
   \   00000026   0xD102             BNE      ??zclTaskHandler_4
   \   00000028   0x....             LDR      R0,??DataTable10_6
   \   0000002A   0x.... 0x....      BL       ??Subroutine3_0
   \                     ??zclTaskHandler_4: (+1)
   \   0000002E   0x0039             MOVS     R1,R7
   \   00000030   0x....             LDR      R0,??DataTable10_7
   \   00000032   0x.... 0x....      BL       deleteQueueElem
   \   00000036   0x003C             MOVS     R4,R7
   \   00000038   0x3408             ADDS     R4,R4,#+8
   \   0000003A   0x204A             MOVS     R0,#+74
   \   0000003C   0x5C38             LDRB     R0,[R7, R0]
   \   0000003E   0x283E             CMP      R0,#+62
   \   00000040   0xD309             BCC      ??zclTaskHandler_5
   \   00000042   0x6920             LDR      R0,[R4, #+16]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD0DE             BEQ      ??zclTaskHandler_1
   \   00000048   0x7065             STRB     R5,[R4, #+1]
   \   0000004A   0x2089             MOVS     R0,#+137
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x6921             LDR      R1,[R4, #+16]
   \   00000052   0x4788             BLX      R1
   \   00000054   0xE7DC             B        ??zclTaskHandler_2
    424              }
    425          
    426              // store the link to an appropriate request
    427              descr = GET_BUFFER_DESCRIPTOR_BY_BUFFER(reqMem);
    428              descr->link = req;
   \                     ??zclTaskHandler_5: (+1)
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x3808             SUBS     R0,R0,#+8
   \   0000005A   0x6007             STR      R7,[R0, #+0]
    429          
    430              if (ZCL_SUCCESS_STATUS != zclExecuteRequest(req, reqMem))
   \   0000005C   0x0031             MOVS     R1,R6
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0x.... 0x....      BL       zclExecuteRequest
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD0D6             BEQ      ??zclTaskHandler_0
    431              {
    432                if (req->ZCL_Notify)
   \   00000068   0x6920             LDR      R0,[R4, #+16]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD0D3             BEQ      ??zclTaskHandler_0
    433                {
    434                  req->notify.id = ZCL_APS_CONFIRM_ID;
   \   0000006E   0x7065             STRB     R5,[R4, #+1]
    435                  req->notify.status = ZCL_INVALID_PARAMETER_STATUS;
   \   00000070   0x20FF             MOVS     R0,#+255
   \   00000072   0x7020             STRB     R0,[R4, #+0]
    436                  req->ZCL_Notify(&req->notify);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x6921             LDR      R1,[R4, #+16]
   \   00000078   0x4788             BLX      R1
   \   0000007A   0xE7CC             B        ??zclTaskHandler_0
    437                }
    438              }
    439            }
    440          }
   \                     ??zclTaskHandler_3: (+1)
   \   0000007C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine3_0: (+1)
   \   00000000   0x.... 0x....      BL       SYS_StartTimer
   \   00000004   0xBDF1             POP      {R0,R4-R7,PC}
    441          
    442          /*************************************************************************//**
    443            \brief Confirmation of APS layer about data sending.
    444          
    445            \param[in] - confirm parameters.
    446            \return none.
    447          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    448          static void attributeConfirm(APS_DataConf_t *conf)
    449          {
   \                     attributeConfirm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    450            ZclMmBufferDescriptor_t *descr = GET_PARENT_BY_FIELD(ZclMmBufferDescriptor_t, buf.primitive.apsDataReq.confirm, conf);
   \   00000004   0x0025             MOVS     R5,R4
   \   00000006   0x3D70             SUBS     R5,R5,#+112
    451            ZCL_Request_t *req             = descr->link;
   \   00000008   0x68A9             LDR      R1,[R5, #+8]
    452            ZCL_Notify_t  *ntfy            = &req->notify;
   \   0000000A   0x0008             MOVS     R0,R1
   \   0000000C   0x3008             ADDS     R0,R0,#+8
    453          
    454            if (APS_SUCCESS_STATUS == conf->status)
   \   0000000E   0x7823             LDRB     R3,[R4, #+0]
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD11E             BNE      ??attributeConfirm_0
    455            {
    456              switch (req->id)
   \   00000016   0x2349             MOVS     R3,#+73
   \   00000018   0x5CCB             LDRB     R3,[R1, R3]
   \   0000001A   0x2B05             CMP      R3,#+5
   \   0000001C   0xD004             BEQ      ??attributeConfirm_1
   \   0000001E   0x2B0A             CMP      R3,#+10
   \   00000020   0xD002             BEQ      ??attributeConfirm_1
   \   00000022   0x2B0B             CMP      R3,#+11
   \   00000024   0xD006             BEQ      ??attributeConfirm_2
   \   00000026   0xE00A             B        ??attributeConfirm_3
    457              {
    458                case ZCL_REPORT_ATTRIBUTES_COMMAND_ID:
    459                case ZCL_WRITE_ATTRIBUTES_NO_RESPONSE_COMMAND_ID:
    460                  ntfy->status = ZCL_SUCCESS_STATUS;
   \                     ??attributeConfirm_1: (+1)
   \   00000028   0x7002             STRB     R2,[R0, #+0]
    461                  ntfy->id = ZCL_APS_CONFIRM_ID;
   \   0000002A   0x7042             STRB     R2,[R0, #+1]
    462                  if (req->ZCL_Notify)
   \   0000002C   0x6989             LDR      R1,[R1, #+24]
   \   0000002E   0x000A             MOVS     R2,R1
   \   00000030   0xD000             BEQ      ??attributeConfirm_2
    463                    req->ZCL_Notify(ntfy);
   \   00000032   0x4788             BLX      R1
    464                case ZCL_DEFAULT_RESPONSE_COMMAND_ID:
    465                  zclMmFreeMem(&descr->buf);
   \                     ??attributeConfirm_2: (+1)
   \   00000034   0x3510             ADDS     R5,R5,#+16
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       zclMmFreeMem
    466                  break;
   \   0000003C   0xE006             B        ??attributeConfirm_4
    467                default:
    468                  descr->timeout = NWK_GetUnicastDeliveryTime() * 2 + ZCL_RESPONSE_SPACING;
   \                     ??attributeConfirm_3: (+1)
   \   0000003E   0x.... 0x....      BL       NWK_GetUnicastDeliveryTime
   \   00000042   0x0040             LSLS     R0,R0,#+1
   \   00000044   0x6028             STR      R0,[R5, #+0]
    469                  zclStartWaitResponseTimer(descr);
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       zclStartWaitResponseTimer
    470                  break;
    471              }
    472            }
    473            else
    474            {
    475              ntfy->status = conf->status;
    476              ntfy->id = ZCL_APS_CONFIRM_ID;
    477              if (req->ZCL_Notify)
    478                req->ZCL_Notify(ntfy);
    479              zclMmFreeMem(&descr->buf);
    480              if (NULL == zclMmGetNextOutputMemDescriptor(NULL))
    481                zclStopResponseWaitTimer();
    482              return;
    483            }
    484          
    485            zclVerifyConfirmResponseOrder(conf);
   \                     ??attributeConfirm_4: (+1)
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       zclVerifyConfirmResponseOrder
    486          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??attributeConfirm_0: (+1)
   \   00000054   0x7003             STRB     R3,[R0, #+0]
   \   00000056   0x7042             STRB     R2,[R0, #+1]
   \   00000058   0x6989             LDR      R1,[R1, #+24]
   \   0000005A   0x000A             MOVS     R2,R1
   \   0000005C   0xD000             BEQ      ??attributeConfirm_5
   \   0000005E   0x4788             BLX      R1
   \                     ??attributeConfirm_5: (+1)
   \   00000060   0x3510             ADDS     R5,R5,#+16
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       zclMmFreeMem
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD102             BNE      ??attributeConfirm_6
   \   00000072   0x....             LDR      R0,??DataTable10_5
   \   00000074   0x.... 0x....      BL       SYS_StopTimer
   \                     ??attributeConfirm_6: (+1)
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    487          
    488          /**************************************************************************//**
    489          \brief Confirmation callback for sending of ZCL command
    490          
    491          \param[in] conf - confirmation data
    492          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    493          static void commandConfirm(APS_DataConf_t *conf)
    494          {
   \                     commandConfirm: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    495            ZclMmBufferDescriptor_t *descr = GET_PARENT_BY_FIELD(ZclMmBufferDescriptor_t, buf.primitive.apsDataReq.confirm, conf);
   \   00000004   0x0025             MOVS     R5,R4
   \   00000006   0x3D70             SUBS     R5,R5,#+112
    496            ZCL_Request_t *req             = descr->link;
   \   00000008   0x68AE             LDR      R6,[R5, #+8]
    497            ZCL_Notify_t *ntfy = &req->notify;
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x3008             ADDS     R0,R0,#+8
    498          
    499            // set sending status
    500            if (APS_SUCCESS_STATUS == conf->status)
   \   0000000E   0x7821             LDRB     R1,[R4, #+0]
   \   00000010   0x2200             MOVS     R2,#+0
    501              ntfy->status = ZCL_SUCCESS_STATUS;
    502            else
    503              ntfy->status = conf->status;
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    504          
    505            ntfy->id = ZCL_APS_CONFIRM_ID;
   \   00000014   0x7042             STRB     R2,[R0, #+1]
    506            // call response function
    507            if ((APS_SUCCESS_STATUS != conf->status) || !(req->service.statusflags & ZCL_REQ_DEFAULT_RESP_RQRD))
   \   00000016   0x7821             LDRB     R1,[R4, #+0]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD102             BNE      ??commandConfirm_0
   \   0000001C   0x7971             LDRB     R1,[R6, #+5]
   \   0000001E   0x0709             LSLS     R1,R1,#+28
   \   00000020   0xD413             BMI      ??commandConfirm_1
    508            {
    509              if (req->ZCL_Notify)
   \                     ??commandConfirm_0: (+1)
   \   00000022   0x69B1             LDR      R1,[R6, #+24]
   \   00000024   0x000A             MOVS     R2,R1
   \   00000026   0xD000             BEQ      ??commandConfirm_2
    510                req->ZCL_Notify(ntfy);
   \   00000028   0x4788             BLX      R1
    511            }
    512            if (APS_SUCCESS_STATUS != conf->status)
   \                     ??commandConfirm_2: (+1)
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00C             BEQ      ??commandConfirm_1
    513            {
    514              zclMmFreeMem(&descr->buf);
   \   00000030   0x3510             ADDS     R5,R5,#+16
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       zclMmFreeMem
    515              if (NULL == zclMmGetNextOutputMemDescriptor(NULL))
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10F             BNE      ??commandConfirm_3
    516                zclStopResponseWaitTimer();
   \   00000042   0x....             LDR      R0,??DataTable10_5
   \   00000044   0x.... 0x....      BL       SYS_StopTimer
    517              return;
   \   00000048   0xBD70             POP      {R4-R6,PC}
    518            }
    519            if (req->responseWaitTimeout)
   \                     ??commandConfirm_1: (+1)
   \   0000004A   0x6D30             LDR      R0,[R6, #+80]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD101             BNE      ??commandConfirm_4
    520              descr->timeout = req->responseWaitTimeout;
    521            else
    522              descr->timeout = NWK_GetUnicastDeliveryTime();
   \   00000050   0x.... 0x....      BL       NWK_GetUnicastDeliveryTime
   \                     ??commandConfirm_4: (+1)
   \   00000054   0x6028             STR      R0,[R5, #+0]
    523            zclStartWaitResponseTimer(descr);
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x.... 0x....      BL       zclStartWaitResponseTimer
    524          
    525            zclVerifyConfirmResponseOrder(conf);
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       zclVerifyConfirmResponseOrder
    526          }
   \                     ??commandConfirm_3: (+1)
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
    527          
    528          /**************************************************************************//**
    529          \brief Confirmation callback for sending ZCL report
    530          
    531          \param[in] conf - confirmation data
    532          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    533          static void reportConfirm(APS_DataConf_t *conf)
    534          {
   \                     reportConfirm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    535            APS_DataReq_t *req = GET_PARENT_BY_FIELD(APS_DataReq_t, confirm, conf);
   \   00000002   0x3860             SUBS     R0,R0,#+96
   \   00000004   0x0004             MOVS     R4,R0
    536          
    537            ZCL_Cluster_t *cluster = ZCL_GetCluster(req->srcEndpoint, req->clusterId, ZCL_CLUSTER_SIDE_SERVER);
   \   00000006   0x304C             ADDS     R0,R0,#+76
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x8801             LDRH     R1,[R0, #+0]
   \   0000000C   0x7880             LDRB     R0,[R0, #+2]
   \   0000000E   0x.... 0x....      BL       ZCL_GetCluster
    538            if (cluster)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ      ??reportConfirm_0
    539              cluster->isReporting = 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7401             STRB     R1,[R0, #+16]
    540          
    541            // free memory
    542            zclMmFreeMem((ZclMmBuffer_t *)req);
   \                     ??reportConfirm_0: (+1)
   \   0000001A   0x....             B.N      ?Subroutine0
    543          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x0020             MOVS     R0,R4
   \   00000002   0x.... 0x....      BL       zclMmFreeMem
   \   00000006   0xBD10             POP      {R4,PC}          ;; return
    544          
    545          /**************************************************************************//**
    546          \brief Confirmation callback for sending ZCL response
    547          
    548          \param[in] conf - confirmation data
    549          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    550          static void responseConfirm(APS_DataConf_t *conf)
    551          {
   \                     responseConfirm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    552            // free memory
    553            zclMmFreeMem((ZclMmBuffer_t *)GET_PARENT_BY_FIELD(APS_DataReq_t, confirm, conf));
   \   00000002   0x3860             SUBS     R0,R0,#+96
   \   00000004   0x.... 0x....      BL       zclMmFreeMem
    554          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    555          
    556          
    557          /**************************************************************************//**
    558          \brief Confirmation callback for sending ZCL configure reporting response
    559          
    560          \param[in] conf - confirmation data
    561          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    562          static void configureReportingResponseConfirm(APS_DataConf_t *conf)
    563          {
   \                     configureReportingResponseConfirm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    564            if (APS_SUCCESS_STATUS == conf->status)
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??configureReportingResponseConfirm_0
    565            {
    566              zclStartReportTimer();
   \   0000000A   0x.... 0x....      BL       zclStartReportTimer
    567            }
    568            // free memory
    569            zclMmFreeMem((ZclMmBuffer_t *)GET_PARENT_BY_FIELD(APS_DataReq_t, confirm, conf));
   \                     ??configureReportingResponseConfirm_0: (+1)
   \   0000000E   0x3C60             SUBS     R4,R4,#+96
   \   00000010                      REQUIRE ?Subroutine0
   \   00000010                      ;; // Fall through to label ?Subroutine0
    570          }
    571          
    572          /*************************************************************************//**
    573            \brief Response has been received.
    574          
    575            \param[in] auxData - pointer to structure with command payload and
    576            descriptor of received command frame.
    577            \param[in] req - pointer to request, which is the reason of the response.
    578          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    579          void zclResponseInd(ZclAuxParseData_t *auxData, ZCL_Request_t *req)
    580          {
   \                     zclResponseInd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x000C             MOVS     R4,R1
    581            APS_DataInd_t           *apsData   = auxData->ind;
   \   00000006   0x6847             LDR      R7,[R0, #+4]
    582            ZclFrameDescriptor_t    *frameDesc = auxData->frameDescriptor;
   \   00000008   0x6806             LDR      R6,[R0, #+0]
   \   0000000A   0x0038             MOVS     R0,R7
   \   0000000C   0x303C             ADDS     R0,R0,#+60
   \   0000000E   0x8880             LDRH     R0,[R0, #+4]
   \   00000010   0x7831             LDRB     R1,[R6, #+0]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x3108             ADDS     R1,R1,#+8
   \   00000018   0x7208             STRB     R0,[R1, #+8]
    583            ZCL_Addressing_t        rxAddressing;
    584          
    585            req->notify.responseLength = apsData->asduLength - frameDesc->headerLength;
    586            req->notify.responsePayload = apsData->asdu + frameDesc->headerLength;
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0x303C             ADDS     R0,R0,#+60
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0x7831             LDRB     R1,[R6, #+0]
   \   00000022   0x1840             ADDS     R0,R0,R1
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x3108             ADDS     R1,R1,#+8
   \   00000028   0x60C8             STR      R0,[R1, #+12]
    587            req->notify.id = ZCL_ZCL_RESPONSE_ID;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x3108             ADDS     R1,R1,#+8
   \   00000030   0x7048             STRB     R0,[R1, #+1]
    588            req->notify.addressing = &rxAddressing;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x0021             MOVS     R1,R4
   \   00000036   0x3108             ADDS     R1,R1,#+8
   \   00000038   0x6048             STR      R0,[R1, #+4]
   \   0000003A   0x466D             MOV      R5,SP
   \   0000003C   0x2021             MOVS     R0,#+33
   \   0000003E   0x5C38             LDRB     R0,[R7, R0]
   \   00000040   0x7028             STRB     R0,[R5, #+0]
    589          
    590            rxAddressing.addrMode             = apsData->srcAddrMode;
    591            rxAddressing.addr                 = apsData->srcAddress;
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x3008             ADDS     R0,R0,#+8
   \   00000046   0x0039             MOVS     R1,R7
   \   00000048   0x3128             ADDS     R1,R1,#+40
   \   0000004A   0x2210             MOVS     R2,#+16
   \   0000004C   0x.... 0x....      BL       __aeabi_memcpy4
    592            rxAddressing.profileId            = apsData->profileId;
   \   00000050   0x8FB8             LDRH     R0,[R7, #+60]
   \   00000052   0x8328             STRH     R0,[R5, #+24]
    593            rxAddressing.endpointId           = apsData->srcEndpoint;
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x3021             ADDS     R0,R0,#+33
   \   00000058   0x7E40             LDRB     R0,[R0, #+25]
   \   0000005A   0x76A8             STRB     R0,[R5, #+26]
    594            rxAddressing.clusterId            = apsData->clusterId;
   \   0000005C   0x373C             ADDS     R7,R7,#+60
   \   0000005E   0x8878             LDRH     R0,[R7, #+2]
   \   00000060   0x83A8             STRH     R0,[R5, #+28]
    595            rxAddressing.clusterSide          = getDstClusterSideByIncommingCommandDirection(frameDesc->direction);
   \   00000062   0x78F0             LDRB     R0,[R6, #+3]
   \   00000064   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   00000068   0x77A8             STRB     R0,[R5, #+30]
    596          
    597            rxAddressing.sequenceNumber = frameDesc->sequenceNumber;
   \   0000006A   0x7A30             LDRB     R0,[R6, #+8]
   \   0000006C   0x2122             MOVS     R1,#+34
   \   0000006E   0x5468             STRB     R0,[R5, R1]
    598          
    599            if (ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC == frameDesc->manufacturerSpecific)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7971             LDRB     R1,[R6, #+5]
   \   00000074   0x2900             CMP      R1,#+0
   \   00000076   0xD101             BNE      ??zclResponseInd_0
    600              rxAddressing.manufacturerSpecCode = 0;
   \   00000078   0x8428             STRH     R0,[R5, #+32]
   \   0000007A   0xE001             B        ??zclResponseInd_1
    601            else
    602              rxAddressing.manufacturerSpecCode = frameDesc->manufacturerCode;
   \                     ??zclResponseInd_0: (+1)
   \   0000007C   0x88F1             LDRH     R1,[R6, #+6]
   \   0000007E   0x8429             STRH     R1,[R5, #+32]
    603          
    604            if (ZCL_WRITE_ATTRIBUTES_COMMAND_ID == req->id)
   \                     ??zclResponseInd_1: (+1)
   \   00000080   0x2149             MOVS     R1,#+73
   \   00000082   0x5C61             LDRB     R1,[R4, R1]
   \   00000084   0x2902             CMP      R1,#+2
   \   00000086   0xD105             BNE      ??zclResponseInd_2
    605            {
    606              if (ALL_ATTRIBUTES_ARE_WRITTEN == req->notify.responseLength)
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0x3108             ADDS     R1,R1,#+8
   \   0000008C   0x7A09             LDRB     R1,[R1, #+8]
   \   0000008E   0x2901             CMP      R1,#+1
   \   00000090   0xD000             BEQ      ??zclResponseInd_2
    607                req->notify.status = ZCL_SUCCESS_STATUS;
    608              else
    609                req->notify.status = ZCL_WRITE_ATTRIBUTES_FAILURE_STATUS;
   \   00000092   0x200F             MOVS     R0,#+15
    610            }
    611            else
    612              req->notify.status = ZCL_SUCCESS_STATUS;
   \                     ??zclResponseInd_2: (+1)
   \   00000094   0x7220             STRB     R0,[R4, #+8]
    613          
    614            if (req->ZCL_Notify)
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x3008             ADDS     R0,R0,#+8
   \   0000009A   0x6901             LDR      R1,[R0, #+16]
   \   0000009C   0x0008             MOVS     R0,R1
   \   0000009E   0xD002             BEQ      ??zclResponseInd_3
    615              req->ZCL_Notify(&req->notify);
   \   000000A0   0x3408             ADDS     R4,R4,#+8
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x4788             BLX      R1
    616          }
   \                     ??zclResponseInd_3: (+1)
   \   000000A6   0xB00B             ADD      SP,SP,#+44
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
    617          
    618          /*************************************************************************//**
    619            \brief Report has been received.
    620          
    621            \param[in] apsData - report payload
    622            \param[in] frameDesc - descriptor of received report frame
    623          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          void zclReportInd(APS_DataInd_t *apsData, ZclFrameDescriptor_t *frameDesc)
    625          {
   \                     zclReportInd: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0005             MOVS     R5,R0
    626            ZCL_Addressing_t addressing;
    627            ZCL_Cluster_t *cluster = ZCL_GetCluster(apsData->dstEndpoint, apsData->clusterId, frameDesc->direction);
   \   00000006   0x002F             MOVS     R7,R5
   \   00000008   0x3720             ADDS     R7,R7,#+32
   \   0000000A   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000C   0x8BF9             LDRH     R1,[R7, #+30]
   \   0000000E   0x7838             LDRB     R0,[R7, #+0]
   \   00000010   0x.... 0x....      BL       ZCL_GetCluster
   \   00000014   0x0006             MOVS     R6,R0
    628          
    629            if (!cluster || !cluster->ZCL_ReportInd)
   \   00000016   0xD02C             BEQ      ??zclReportInd_0
   \   00000018   0x6970             LDR      R0,[R6, #+20]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD029             BEQ      ??zclReportInd_0
    630              return;
    631          
    632            addressing.addrMode             = apsData->srcAddrMode;
   \   0000001E   0x466C             MOV      R4,SP
   \   00000020   0x7878             LDRB     R0,[R7, #+1]
   \   00000022   0x7020             STRB     R0,[R4, #+0]
    633            addressing.addr                 = apsData->srcAddress;
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x3008             ADDS     R0,R0,#+8
   \   00000028   0x3528             ADDS     R5,R5,#+40
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x2210             MOVS     R2,#+16
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy4
    634            addressing.profileId            = apsData->profileId;
   \   00000032   0x8BB8             LDRH     R0,[R7, #+28]
   \   00000034   0x8320             STRH     R0,[R4, #+24]
    635            addressing.endpointId           = apsData->srcEndpoint;
   \   00000036   0x7EB8             LDRB     R0,[R7, #+26]
   \   00000038   0x76A0             STRB     R0,[R4, #+26]
    636            addressing.clusterId            = apsData->clusterId;
   \   0000003A   0x8BF8             LDRH     R0,[R7, #+30]
   \   0000003C   0x83A0             STRH     R0,[R4, #+28]
    637            addressing.clusterSide          = getDstClusterSideByIncommingCommandDirection(frameDesc->direction);
   \   0000003E   0x980A             LDR      R0,[SP, #+40]
   \   00000040   0x78C0             LDRB     R0,[R0, #+3]
   \   00000042   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   00000046   0x77A0             STRB     R0,[R4, #+30]
    638            addressing.sequenceNumber       = frameDesc->sequenceNumber;
   \   00000048   0x980A             LDR      R0,[SP, #+40]
   \   0000004A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000004C   0x2122             MOVS     R1,#+34
   \   0000004E   0x5460             STRB     R0,[R4, R1]
    639          
    640            if (ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC == frameDesc->manufacturerSpecific)
   \   00000050   0x980A             LDR      R0,[SP, #+40]
   \   00000052   0x7940             LDRB     R0,[R0, #+5]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD001             BEQ      ??zclReportInd_1
    641              addressing.manufacturerSpecCode = 0;
    642            else
    643              addressing.manufacturerSpecCode = frameDesc->manufacturerCode;
   \   00000058   0x980A             LDR      R0,[SP, #+40]
   \   0000005A   0x88C0             LDRH     R0,[R0, #+6]
   \                     ??zclReportInd_1: (+1)
   \   0000005C   0x8420             STRH     R0,[R4, #+32]
    644          
    645            cluster->ZCL_ReportInd(&addressing,
    646                                   apsData->asduLength - frameDesc->headerLength,
    647                                   apsData->asdu + frameDesc->headerLength);
   \   0000005E   0x980A             LDR      R0,[SP, #+40]
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x6A79             LDR      R1,[R7, #+36]
   \   00000064   0x180A             ADDS     R2,R1,R0
   \   00000066   0x8C39             LDRH     R1,[R7, #+32]
   \   00000068   0x1A09             SUBS     R1,R1,R0
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x6973             LDR      R3,[R6, #+20]
   \   00000070   0x4798             BLX      R3
    648          }
   \                     ??zclReportInd_0: (+1)
   \   00000072   0xB00B             ADD      SP,SP,#+44
   \   00000074   0xBDF0             POP      {R4-R7,PC}       ;; return
    649          
    650          /*************************************************************************//**
    651            \brief The attribute has been read or written.
    652          
    653            \param[in] apsDataInd - attribute payload
    654            \param[in] incomingFrameInfo - information from the header of the incoming frame
    655            \param[in] event - event type
    656            \param[in] attributeId - attribute identifier
    657          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    658          void zclAttributeEventInd(const APS_DataInd_t *apsDataInd,
    659                                    const ZclFrameDescriptor_t *incomingFrameInfo,
    660                                    ZCL_AttributeEvent_t event,
    661                                    ZCL_AttributeId_t attributeId)
    662          {
   \                     zclAttributeEventInd: (+1)
   \   00000000   0xB5FC             PUSH     {R2-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x78FA             LDRB     R2,[R7, #+3]
   \   0000000A   0x3020             ADDS     R0,R0,#+32
   \   0000000C   0x8BC1             LDRH     R1,[R0, #+30]
   \   0000000E   0x2020             MOVS     R0,#+32
   \   00000010   0x5C20             LDRB     R0,[R4, R0]
    663            ZCL_Addressing_t addressing;
    664            ZCL_Cluster_t *cluster = ZCL_GetCluster(apsDataInd->dstEndpoint, apsDataInd->clusterId, incomingFrameInfo->direction);
   \   00000012   0x.... 0x....      BL       ZCL_GetCluster
   \   00000016   0x0006             MOVS     R6,R0
    665          
    666            if (!cluster || !cluster->ZCL_AttributeEventInd)
   \   00000018   0xD028             BEQ      ??zclAttributeEventInd_0
   \   0000001A   0x69F0             LDR      R0,[R6, #+28]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD025             BEQ      ??zclAttributeEventInd_0
    667              return;
    668          
    669            addressing.addrMode = apsDataInd->srcAddrMode;
   \   00000020   0x466D             MOV      R5,SP
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x3020             ADDS     R0,R0,#+32
   \   00000026   0x7840             LDRB     R0,[R0, #+1]
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    670            addressing.addr = apsDataInd->srcAddress;
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x3008             ADDS     R0,R0,#+8
   \   0000002E   0x0021             MOVS     R1,R4
   \   00000030   0x3128             ADDS     R1,R1,#+40
   \   00000032   0x2210             MOVS     R2,#+16
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy4
    671            addressing.profileId = apsDataInd->profileId;
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x3020             ADDS     R0,R0,#+32
   \   0000003C   0x8B80             LDRH     R0,[R0, #+28]
   \   0000003E   0x8328             STRH     R0,[R5, #+24]
    672            addressing.endpointId = apsDataInd->srcEndpoint;
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x3020             ADDS     R0,R0,#+32
   \   00000044   0x7E80             LDRB     R0,[R0, #+26]
   \   00000046   0x76A8             STRB     R0,[R5, #+26]
    673            addressing.clusterId = apsDataInd->clusterId;
   \   00000048   0x3420             ADDS     R4,R4,#+32
   \   0000004A   0x8BE0             LDRH     R0,[R4, #+30]
   \   0000004C   0x83A8             STRH     R0,[R5, #+28]
    674            addressing.clusterSide = getDstClusterSideByIncommingCommandDirection(incomingFrameInfo->direction);
   \   0000004E   0x78F8             LDRB     R0,[R7, #+3]
   \   00000050   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   00000054   0x77A8             STRB     R0,[R5, #+30]
    675            addressing.manufacturerSpecCode = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x8428             STRH     R0,[R5, #+32]
    676            addressing.sequenceNumber = incomingFrameInfo->sequenceNumber;
   \   0000005A   0x7A38             LDRB     R0,[R7, #+8]
   \   0000005C   0x3522             ADDS     R5,R5,#+34
   \   0000005E   0x7028             STRB     R0,[R5, #+0]
    677          
    678            cluster->ZCL_AttributeEventInd(&addressing, attributeId, event);
   \   00000060   0xA80B             ADD      R0,SP,#+44
   \   00000062   0x7802             LDRB     R2,[R0, #+0]
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x8E01             LDRH     R1,[R0, #+48]
   \   00000068   0x69F3             LDR      R3,[R6, #+28]
   \   0000006A   0x4798             BLX      R3
    679          }
   \                     ??zclAttributeEventInd_0: (+1)
   \   0000006C   0xB00D             ADD      SP,SP,#+52
   \   0000006E   0xBDF0             POP      {R4-R7,PC}       ;; return
    680          
    681          /*************************************************************************//**
    682            \brief Special cluster command has been received.
    683          
    684            \param[in] auxData - pointer to structure with command payload and
    685            descriptor of received command frame.
    686          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    687          void zclCommandInd(ZclAuxParseData_t *auxData)
    688          {
   \                     zclCommandInd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x0007             MOVS     R7,R0
    689            ZclCommand_t *command;
    690            APS_DataInd_t *apsData = auxData->ind;
   \   00000006   0x687C             LDR      R4,[R7, #+4]
    691            ZclFrameDescriptor_t *frameDesc = auxData->frameDescriptor;
   \   00000008   0x683E             LDR      R6,[R7, #+0]
   \   0000000A   0x7A73             LDRB     R3,[R6, #+9]
   \   0000000C   0x78F2             LDRB     R2,[R6, #+3]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x303A             ADDS     R0,R0,#+58
   \   00000012   0x8881             LDRH     R1,[R0, #+4]
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x300C             ADDS     R0,R0,#+12
   \   00000018   0x7D00             LDRB     R0,[R0, #+20]
    692            ZCL_Addressing_t addressing;
    693          
    694            command = zclGetCommand(apsData->dstEndpoint,
    695                                    apsData->clusterId,
    696                                    frameDesc->direction,
    697                                    frameDesc->commandId);
   \   0000001A   0x.... 0x....      BL       zclGetCommand
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    698          
    699            // Default result
    700            auxData->commandStatus = ZCL_UNSUP_CLUSTER_COMMAND_STATUS;
   \   00000020   0x2081             MOVS     R0,#+129
   \   00000022   0x7238             STRB     R0,[R7, #+8]
    701          
    702            if (!command || !command->callback)
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD055             BEQ      ??zclCommandInd_0
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD052             BEQ      ??zclCommandInd_0
    703              return;
    704          
    705            addressing.addrMode             = apsData->srcAddrMode;
   \   00000030   0xAD02             ADD      R5,SP,#+8
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x300C             ADDS     R0,R0,#+12
   \   00000036   0x7D40             LDRB     R0,[R0, #+21]
   \   00000038   0x7028             STRB     R0,[R5, #+0]
    706            addressing.addr                 = apsData->srcAddress;
   \   0000003A   0xA802             ADD      R0,SP,#+8
   \   0000003C   0x3008             ADDS     R0,R0,#+8
   \   0000003E   0x0021             MOVS     R1,R4
   \   00000040   0x3128             ADDS     R1,R1,#+40
   \   00000042   0x2210             MOVS     R2,#+16
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy4
    707            addressing.profileId            = apsData->profileId;
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x303A             ADDS     R0,R0,#+58
   \   0000004C   0x8840             LDRH     R0,[R0, #+2]
   \   0000004E   0x8328             STRH     R0,[R5, #+24]
    708            addressing.endpointId           = apsData->srcEndpoint;
   \   00000050   0x203A             MOVS     R0,#+58
   \   00000052   0x5C20             LDRB     R0,[R4, R0]
   \   00000054   0x76A8             STRB     R0,[R5, #+26]
    709            addressing.clusterId            = apsData->clusterId;
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x303A             ADDS     R0,R0,#+58
   \   0000005A   0x8880             LDRH     R0,[R0, #+4]
   \   0000005C   0x83A8             STRH     R0,[R5, #+28]
    710            addressing.clusterSide          = getDstClusterSideByIncommingCommandDirection(frameDesc->direction);
   \   0000005E   0x78F0             LDRB     R0,[R6, #+3]
   \   00000060   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   00000064   0x77A8             STRB     R0,[R5, #+30]
    711            addressing.sequenceNumber       = frameDesc->sequenceNumber;
   \   00000066   0x7A30             LDRB     R0,[R6, #+8]
   \   00000068   0x2122             MOVS     R1,#+34
   \   0000006A   0x5468             STRB     R0,[R5, R1]
    712            addressing.nonUnicast           = IS_NON_UNICAST_TRANSMISSION(apsData);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0x310C             ADDS     R1,R1,#+12
   \   00000072   0x8889             LDRH     R1,[R1, #+4]
   \   00000074   0x....             LDR      R2,??DataTable12  ;; 0xfff8
   \   00000076   0x4291             CMP      R1,R2
   \   00000078   0xD202             BCS      ??zclCommandInd_1
   \   0000007A   0x7B21             LDRB     R1,[R4, #+12]
   \   0000007C   0x2901             CMP      R1,#+1
   \   0000007E   0xD101             BNE      ??zclCommandInd_2
   \                     ??zclCommandInd_1: (+1)
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0xE000             B        ??zclCommandInd_3
   \                     ??zclCommandInd_2: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   \                     ??zclCommandInd_3: (+1)
   \   00000086   0x2223             MOVS     R2,#+35
   \   00000088   0x54A9             STRB     R1,[R5, R2]
    713          
    714            if (ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC == frameDesc->manufacturerSpecific)
   \   0000008A   0x7971             LDRB     R1,[R6, #+5]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD000             BEQ      ??zclCommandInd_4
    715              addressing.manufacturerSpecCode = 0;
    716            else
    717              addressing.manufacturerSpecCode = frameDesc->manufacturerCode;
   \   00000090   0x88F0             LDRH     R0,[R6, #+6]
   \                     ??zclCommandInd_4: (+1)
   \   00000092   0x8428             STRH     R0,[R5, #+32]
    718          
    719            auxData->commandStatus = command->callback(&addressing, apsData->asduLength - frameDesc->headerLength, apsData->asdu + frameDesc->headerLength);
   \   00000094   0x7830             LDRB     R0,[R6, #+0]
   \   00000096   0x6C61             LDR      R1,[R4, #+68]
   \   00000098   0x180A             ADDS     R2,R1,R0
   \   0000009A   0x0021             MOVS     R1,R4
   \   0000009C   0x313A             ADDS     R1,R1,#+58
   \   0000009E   0x88C9             LDRH     R1,[R1, #+6]
   \   000000A0   0x1A09             SUBS     R1,R1,R0
   \   000000A2   0xB2C9             UXTB     R1,R1
   \   000000A4   0xA802             ADD      R0,SP,#+8
   \   000000A6   0x9B00             LDR      R3,[SP, #+0]
   \   000000A8   0x685B             LDR      R3,[R3, #+4]
   \   000000AA   0x4798             BLX      R3
   \   000000AC   0x7238             STRB     R0,[R7, #+8]
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x7840             LDRB     R0,[R0, #+1]
   \   000000B2   0x0700             LSLS     R0,R0,#+28
   \   000000B4   0x0F81             LSRS     R1,R0,#+30
   \   000000B6   0x2902             CMP      R1,#+2
   \   000000B8   0xD109             BNE      ??zclCommandInd_5
    720            if (ZCL_RESPONSE_CONTROLLED_BY_PAYLOAD == command->options.waitingResponse)
    721              auxData->relevantResponse = zclIsResponseRequiredByPayload(apsData->clusterId,
    722                frameDesc->commandId, frameDesc->direction, apsData->asdu + frameDesc->headerLength);
   \   000000BA   0x6C60             LDR      R0,[R4, #+68]
   \   000000BC   0x7831             LDRB     R1,[R6, #+0]
   \   000000BE   0x1843             ADDS     R3,R0,R1
   \   000000C0   0x78F2             LDRB     R2,[R6, #+3]
   \   000000C2   0x7A71             LDRB     R1,[R6, #+9]
   \   000000C4   0x343A             ADDS     R4,R4,#+58
   \   000000C6   0x88A0             LDRH     R0,[R4, #+4]
   \   000000C8   0x.... 0x....      BL       zclIsResponseRequiredByPayload
   \   000000CC   0xE002             B        ??zclCommandInd_6
    723            else
    724              auxData->relevantResponse = (bool)command->options.waitingResponse;
   \                     ??zclCommandInd_5: (+1)
   \   000000CE   0x0008             MOVS     R0,R1
   \   000000D0   0xD000             BEQ      ??zclCommandInd_6
   \   000000D2   0x2001             MOVS     R0,#+1
   \                     ??zclCommandInd_6: (+1)
   \   000000D4   0x72B8             STRB     R0,[R7, #+10]
    725          }
   \                     ??zclCommandInd_0: (+1)
   \   000000D6   0xB00D             ADD      SP,SP,#+52
   \   000000D8   0xBDF0             POP      {R4-R7,PC}       ;; return
    726          
    727          /**************************************************************************//**
    728          \brief Handler for Read Reporting Configuration command
    729          
    730          \param[in] apsDataInd - APS data indication;
    731          \param[in, out] frameDescriptor - descriptor for response frame creation
    732          
    733          \returns true if corresponding request may be removed, false otherwise
    734          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    735          bool zclReadReportingConfigurationHandler(APS_DataInd_t *apsDataInd, ZclFrameDescriptor_t *frameDescriptor)
    736          {
   \                     zclReadReportingConfigurationHandler: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    737            ZclMmBuffer_t *outBuf;
    738            ZCL_ReadReportingConfigurationResp_t *resp;
    739            ZCL_ReadReportingConfigurationReq_t *req = (ZCL_ReadReportingConfigurationReq_t *)frameDescriptor->payload;
   \   00000004   0x6908             LDR      R0,[R1, #+16]
   \   00000006   0x9006             STR      R0,[SP, #+24]
    740            uint8_t inPayloadLength = frameDescriptor->payloadLength;
   \   00000008   0x980C             LDR      R0,[SP, #+48]
   \   0000000A   0x7840             LDRB     R0,[R0, #+1]
   \   0000000C   0x900A             STR      R0,[SP, #+40]
    741            uint8_t outPayloadLength;
    742            ZclAttribute_t *attribute;
    743            Endpoint_t endpoint = apsDataInd->dstEndpoint;
   \   0000000E   0x980B             LDR      R0,[SP, #+44]
   \   00000010   0x3020             ADDS     R0,R0,#+32
   \   00000012   0x9009             STR      R0,[SP, #+36]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x7348             STRB     R0,[R1, #+13]
    744            ClusterId_t clusterId = apsDataInd->clusterId;
   \   0000001A   0x9809             LDR      R0,[SP, #+36]
   \   0000001C   0x8BC0             LDRH     R0,[R0, #+30]
   \   0000001E   0x81C8             STRH     R0,[R1, #+14]
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7308             STRB     R0,[R1, #+12]
    745            uint8_t predictedRecordLength;
    746            uint8_t recordsProcessedAmount = 0;
    747            ZCL_Status_t status;
    748            uint8_t *ptr;
    749            APS_DataReq_t *apsDataReq;
    750            ZCL_DataTypeDescriptor_t dataTypeDescriptor;
    751          
    752            // get buffer for response
    753            outBuf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x.... 0x....      BL       zclMmGetMem
   \   0000002A   0x9005             STR      R0,[SP, #+20]
    754            if (NULL == outBuf)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD100             BNE      .+4
   \   00000030   0xE0E6             B        ??zclReadReportingConfigurationHandler_0
    755              return false;
    756          
    757            apsDataReq = &outBuf->primitive.apsDataReq;
    758            apsDataReq->asdu = outBuf->frame + getZclAsduOffset();
   \   00000032   0x3058             ADDS     R0,R0,#+88
   \   00000034   0x9007             STR      R0,[SP, #+28]
   \   00000036   0x9805             LDR      R0,[SP, #+20]
   \   00000038   0x3030             ADDS     R0,R0,#+48
   \   0000003A   0x9004             STR      R0,[SP, #+16]
   \   0000003C   0x9807             LDR      R0,[SP, #+28]
   \   0000003E   0x6900             LDR      R0,[R0, #+16]
   \   00000040   0x303B             ADDS     R0,R0,#+59
   \   00000042   0x9904             LDR      R1,[SP, #+16]
   \   00000044   0x6248             STR      R0,[R1, #+36]
    759            apsDataReq->APS_DataConf = responseConfirm;
   \   00000046   0x....             LDR      R0,??DataTable12_1
   \   00000048   0x9907             LDR      R1,[SP, #+28]
   \   0000004A   0x6048             STR      R0,[R1, #+4]
    760          
    761            // form request header
    762            outPayloadLength = zclFormRequest(apsDataReq,
    763                                              ZCL_STANDARD_REQ_TYPE,
    764                                              ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT,
    765                                              ZCL_READ_REPORTING_CONFIGURATION_RESPONSE_COMMAND_ID,
    766                                              ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RESPONSE,
    767                                              ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC,
    768                                              frameDescriptor->sequenceNumber);
   \   0000004C   0x980C             LDR      R0,[SP, #+48]
   \   0000004E   0x7A00             LDRB     R0,[R0, #+8]
   \   00000050   0x9002             STR      R0,[SP, #+8]
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0x2309             MOVS     R3,#+9
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x9805             LDR      R0,[SP, #+20]
   \   00000062   0x.... 0x....      BL       zclFormRequest
   \   00000066   0x9000             STR      R0,[SP, #+0]
    769          
    770            resp = (ZCL_ReadReportingConfigurationResp_t *) (outBuf->frame + getZclAsduOffset() + outPayloadLength);
   \   00000068   0x9807             LDR      R0,[SP, #+28]
   \   0000006A   0x6900             LDR      R0,[R0, #+16]
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0x1847             ADDS     R7,R0,R1
   \   00000070   0x373B             ADDS     R7,R7,#+59
   \   00000072   0xE00E             B        ??zclReadReportingConfigurationHandler_1
    771          
    772            while (0 != inPayloadLength)
    773            {
    774              status = ZCL_SUCCESS_STATUS;
    775              //Get the next attribute descriptor to predict possible response record length.
    776              //It is needed to prevent memeory damage.
    777              attribute = zclGetAttribute(endpoint, clusterId, frameDescriptor->direction, req->attributeId);
    778              predictedRecordLength = SLICE_SIZE(ZCL_ReadReportingConfigurationResp_t, status, attributeId);
    779          
    780              if (ZCL_FRAME_CONTROL_DIRECTION_CLIENT_TO_SERVER == req->direction)
    781              {
    782                if (attribute)                //attribute is supported
    783                {
    784                  if (attribute->properties & ZCL_REPORTABLE_ATTRIBUTE)
    785                  {
    786                    ZCL_GetDataTypeDescriptor(attribute->type, attribute->value, &dataTypeDescriptor);
    787                    predictedRecordLength += SLICE_SIZE(ZCL_ReadReportingConfigurationResp_t, attributeType, maxReportingInterval);
    788                    if (ZCL_DATA_TYPE_ANALOG_KIND == dataTypeDescriptor.kind)
    789                      predictedRecordLength += /*reportableChange*/     dataTypeDescriptor.length;
    790                  }
    791                  else
    792                  {
    793                    status = ZCL_UNREPORTABLE_ATTRIBUTE_STATUS;
    794                  }
    795                }
    796                else
    797                {
    798                  status = ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
    799                }
    800              }
    801              else
    802              {
    803                predictedRecordLength += /*timeoutPeriod*/ sizeof(uint16_t);
    804              }
    805          
    806              if (ZCL_MAX_TX_ZSDU_SIZE >= outPayloadLength + predictedRecordLength)
    807              {
    808                resp->status = status;
    809                resp->direction = req->direction;
    810                resp->attributeId = req->attributeId;
    811                if (ZCL_SUCCESS_STATUS == status)
    812                {
    813                  if (ZCL_FRAME_CONTROL_DIRECTION_CLIENT_TO_SERVER == req->direction)
    814                  {
    815                    resp->attributeType = attribute->type;
    816                    ptr = (uint8_t *)attribute + SLICE_SIZE(ZclAttribute_t, id, properties) + sizeof(ZCL_ReportTime_t) + dataTypeDescriptor.length;
    817                    resp->minReportingInterval = ((u16Packed_t *)ptr)->val;
    818                    ptr += sizeof(ZCL_ReportTime_t);
    819                    resp->maxReportingInterval = ((u16Packed_t *)ptr)->val;
    820                    if (ZCL_DATA_TYPE_ANALOG_KIND == dataTypeDescriptor.kind)
    821                    {
    822                      ptr += sizeof(ZCL_ReportTime_t);
    823                      SYS_BYTE_MEMCPY(resp->reportableChange, ptr, dataTypeDescriptor.length);
    824                    }
    825                  }
    826                  else
    827                  {
    828                    resp->timeoutPeriod = 0xffff;
    829                  }
    830                }
    831          
    832                if (sizeof(ZCL_ReadReportingConfigurationReq_t) <= inPayloadLength)
    833                {
    834                  inPayloadLength -= sizeof(ZCL_ReadReportingConfigurationReq_t);
    835                }
    836                else
    837                {
    838                  inPayloadLength = 0;
   \                     ??zclReadReportingConfigurationHandler_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??zclReadReportingConfigurationHandler_3: (+1)
   \   00000076   0x900A             STR      R0,[SP, #+40]
    839                }
    840                req++;
   \   00000078   0x9806             LDR      R0,[SP, #+24]
   \   0000007A   0x1CC0             ADDS     R0,R0,#+3
   \   0000007C   0x9006             STR      R0,[SP, #+24]
    841                resp = (ZCL_ReadReportingConfigurationResp_t *)(((uint8_t *) resp) + predictedRecordLength);
   \   0000007E   0x193F             ADDS     R7,R7,R4
    842                recordsProcessedAmount++;
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x7B00             LDRB     R0,[R0, #+12]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x7308             STRB     R0,[R1, #+12]
    843                outPayloadLength += predictedRecordLength;
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x1900             ADDS     R0,R0,R4
   \   0000008E   0xB2C0             UXTB     R0,R0
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \                     ??zclReadReportingConfigurationHandler_1: (+1)
   \   00000092   0x980A             LDR      R0,[SP, #+40]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD071             BEQ      ??zclReadReportingConfigurationHandler_4
   \   00000098   0x2500             MOVS     R5,#+0
   \   0000009A   0x9806             LDR      R0,[SP, #+24]
   \   0000009C   0x7843             LDRB     R3,[R0, #+1]
   \   0000009E   0x7881             LDRB     R1,[R0, #+2]
   \   000000A0   0x0609             LSLS     R1,R1,#+24
   \   000000A2   0x0C09             LSRS     R1,R1,#+16
   \   000000A4   0x430B             ORRS     R3,R3,R1
   \   000000A6   0x980C             LDR      R0,[SP, #+48]
   \   000000A8   0x78C2             LDRB     R2,[R0, #+3]
   \   000000AA   0x4668             MOV      R0,SP
   \   000000AC   0x89C1             LDRH     R1,[R0, #+14]
   \   000000AE   0x7B40             LDRB     R0,[R0, #+13]
   \   000000B0   0x.... 0x....      BL       zclGetAttribute
   \   000000B4   0x0006             MOVS     R6,R0
   \   000000B6   0x2404             MOVS     R4,#+4
   \   000000B8   0x9806             LDR      R0,[SP, #+24]
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD117             BNE      ??zclReadReportingConfigurationHandler_5
   \   000000C0   0x2E00             CMP      R6,#+0
   \   000000C2   0xD013             BEQ      ??zclReadReportingConfigurationHandler_6
   \   000000C4   0x78F0             LDRB     R0,[R6, #+3]
   \   000000C6   0x07C0             LSLS     R0,R0,#+31
   \   000000C8   0xD50E             BPL      ??zclReadReportingConfigurationHandler_7
   \   000000CA   0xAA08             ADD      R2,SP,#+32
   \   000000CC   0x1D31             ADDS     R1,R6,#+4
   \   000000CE   0x78B0             LDRB     R0,[R6, #+2]
   \   000000D0   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
   \   000000D4   0x2409             MOVS     R4,#+9
   \   000000D6   0xA808             ADD      R0,SP,#+32
   \   000000D8   0x7880             LDRB     R0,[R0, #+2]
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD109             BNE      ??zclReadReportingConfigurationHandler_8
   \   000000DE   0x4668             MOV      R0,SP
   \   000000E0   0x8C04             LDRH     R4,[R0, #+32]
   \   000000E2   0x3409             ADDS     R4,R4,#+9
   \   000000E4   0xB2E4             UXTB     R4,R4
   \   000000E6   0xE004             B        ??zclReadReportingConfigurationHandler_8
   \                     ??zclReadReportingConfigurationHandler_7: (+1)
   \   000000E8   0x258C             MOVS     R5,#+140
   \   000000EA   0xE002             B        ??zclReadReportingConfigurationHandler_8
   \                     ??zclReadReportingConfigurationHandler_6: (+1)
   \   000000EC   0x2586             MOVS     R5,#+134
   \   000000EE   0xE000             B        ??zclReadReportingConfigurationHandler_8
   \                     ??zclReadReportingConfigurationHandler_5: (+1)
   \   000000F0   0x2406             MOVS     R4,#+6
   \                     ??zclReadReportingConfigurationHandler_8: (+1)
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x1900             ADDS     R0,R0,R4
   \   000000F6   0x283E             CMP      R0,#+62
   \   000000F8   0xD240             BCS      ??zclReadReportingConfigurationHandler_4
   \   000000FA   0x703D             STRB     R5,[R7, #+0]
   \   000000FC   0x9806             LDR      R0,[SP, #+24]
   \   000000FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000100   0x7078             STRB     R0,[R7, #+1]
   \   00000102   0x9906             LDR      R1,[SP, #+24]
   \   00000104   0x7848             LDRB     R0,[R1, #+1]
   \   00000106   0x788A             LDRB     R2,[R1, #+2]
   \   00000108   0x0612             LSLS     R2,R2,#+24
   \   0000010A   0x0C12             LSRS     R2,R2,#+16
   \   0000010C   0x4310             ORRS     R0,R0,R2
   \   0000010E   0x70B8             STRB     R0,[R7, #+2]
   \   00000110   0x0A00             LSRS     R0,R0,#+8
   \   00000112   0x70F8             STRB     R0,[R7, #+3]
   \   00000114   0x2D00             CMP      R5,#+0
   \   00000116   0xD12A             BNE      ??zclReadReportingConfigurationHandler_9
   \   00000118   0x9806             LDR      R0,[SP, #+24]
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD122             BNE      ??zclReadReportingConfigurationHandler_10
   \   00000120   0x78B0             LDRB     R0,[R6, #+2]
   \   00000122   0x7138             STRB     R0,[R7, #+4]
   \   00000124   0x4668             MOV      R0,SP
   \   00000126   0x8C00             LDRH     R0,[R0, #+32]
   \   00000128   0x1831             ADDS     R1,R6,R0
   \   0000012A   0x1D89             ADDS     R1,R1,#+6
   \   0000012C   0x7808             LDRB     R0,[R1, #+0]
   \   0000012E   0x784A             LDRB     R2,[R1, #+1]
   \   00000130   0x0612             LSLS     R2,R2,#+24
   \   00000132   0x0C12             LSRS     R2,R2,#+16
   \   00000134   0x4310             ORRS     R0,R0,R2
   \   00000136   0x7178             STRB     R0,[R7, #+5]
   \   00000138   0x0A00             LSRS     R0,R0,#+8
   \   0000013A   0x71B8             STRB     R0,[R7, #+6]
   \   0000013C   0x1C89             ADDS     R1,R1,#+2
   \   0000013E   0x7808             LDRB     R0,[R1, #+0]
   \   00000140   0x784A             LDRB     R2,[R1, #+1]
   \   00000142   0x0612             LSLS     R2,R2,#+24
   \   00000144   0x0C12             LSRS     R2,R2,#+16
   \   00000146   0x4310             ORRS     R0,R0,R2
   \   00000148   0x71F8             STRB     R0,[R7, #+7]
   \   0000014A   0x0A00             LSRS     R0,R0,#+8
   \   0000014C   0x7238             STRB     R0,[R7, #+8]
   \   0000014E   0xA808             ADD      R0,SP,#+32
   \   00000150   0x7880             LDRB     R0,[R0, #+2]
   \   00000152   0x2801             CMP      R0,#+1
   \   00000154   0xD10B             BNE      ??zclReadReportingConfigurationHandler_9
   \   00000156   0x4668             MOV      R0,SP
   \   00000158   0x8C02             LDRH     R2,[R0, #+32]
   \   0000015A   0x1C89             ADDS     R1,R1,#+2
   \   0000015C   0x0038             MOVS     R0,R7
   \   0000015E   0x3009             ADDS     R0,R0,#+9
   \   00000160   0x.... 0x....      BL       SYS_ByteMemcpy
   \   00000164   0xE003             B        ??zclReadReportingConfigurationHandler_9
   \                     ??zclReadReportingConfigurationHandler_10: (+1)
   \   00000166   0x....             LDR      R0,??DataTable13  ;; 0xffff
   \   00000168   0x7138             STRB     R0,[R7, #+4]
   \   0000016A   0x20FF             MOVS     R0,#+255
   \   0000016C   0x7178             STRB     R0,[R7, #+5]
   \                     ??zclReadReportingConfigurationHandler_9: (+1)
   \   0000016E   0x980A             LDR      R0,[SP, #+40]
   \   00000170   0x2803             CMP      R0,#+3
   \   00000172   0xD200             BCS      .+4
   \   00000174   0xE77E             B        ??zclReadReportingConfigurationHandler_2
   \   00000176   0x1EC0             SUBS     R0,R0,#+3
   \   00000178   0xB2C0             UXTB     R0,R0
   \   0000017A   0xE77C             B        ??zclReadReportingConfigurationHandler_3
    844              }
    845              else
    846              {
    847                break;
    848              }
    849            }
    850          
    851            if (0 == recordsProcessedAmount)
   \                     ??zclReadReportingConfigurationHandler_4: (+1)
   \   0000017C   0x4668             MOV      R0,SP
   \   0000017E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD103             BNE      ??zclReadReportingConfigurationHandler_11
    852            {
    853              zclMmFreeMem(outBuf);
   \   00000184   0x9805             LDR      R0,[SP, #+20]
   \   00000186   0x.... 0x....      BL       zclMmFreeMem
   \   0000018A   0xE038             B        ??zclReadReportingConfigurationHandler_12
    854            }
    855            else
    856            {
    857              //APS Data Request for response
    858              apsDataReq->dstAddrMode = apsDataInd->srcAddrMode;
   \                     ??zclReadReportingConfigurationHandler_11: (+1)
   \   0000018C   0x9809             LDR      R0,[SP, #+36]
   \   0000018E   0x7840             LDRB     R0,[R0, #+1]
   \   00000190   0x9904             LDR      R1,[SP, #+16]
   \   00000192   0x7008             STRB     R0,[R1, #+0]
    859              SYS_BYTE_MEMCPY(&apsDataReq->dstAddress, &apsDataInd->srcAddress, sizeof(APS_Address_t));
   \   00000194   0x2210             MOVS     R2,#+16
   \   00000196   0x990B             LDR      R1,[SP, #+44]
   \   00000198   0x3128             ADDS     R1,R1,#+40
   \   0000019A   0x9805             LDR      R0,[SP, #+20]
   \   0000019C   0x3038             ADDS     R0,R0,#+56
   \   0000019E   0x.... 0x....      BL       SYS_ByteMemcpy
    860              apsDataReq->dstEndpoint = apsDataInd->srcEndpoint;
   \   000001A2   0x9809             LDR      R0,[SP, #+36]
   \   000001A4   0x7E80             LDRB     R0,[R0, #+26]
   \   000001A6   0x9904             LDR      R1,[SP, #+16]
   \   000001A8   0x7608             STRB     R0,[R1, #+24]
    861              apsDataReq->srcEndpoint = apsDataInd->dstEndpoint;
   \   000001AA   0x9809             LDR      R0,[SP, #+36]
   \   000001AC   0x7800             LDRB     R0,[R0, #+0]
   \   000001AE   0x9904             LDR      R1,[SP, #+16]
   \   000001B0   0x7788             STRB     R0,[R1, #+30]
    862              apsDataReq->clusterId = clusterId;
   \   000001B2   0x4668             MOV      R0,SP
   \   000001B4   0x89C0             LDRH     R0,[R0, #+14]
   \   000001B6   0x9904             LDR      R1,[SP, #+16]
   \   000001B8   0x8388             STRH     R0,[R1, #+28]
    863              apsDataReq->profileId = apsDataInd->profileId;
   \   000001BA   0x9809             LDR      R0,[SP, #+36]
   \   000001BC   0x8B80             LDRH     R0,[R0, #+28]
   \   000001BE   0x9904             LDR      R1,[SP, #+16]
   \   000001C0   0x8348             STRH     R0,[R1, #+26]
    864              apsDataReq->asduLength = outPayloadLength;
   \   000001C2   0x9800             LDR      R0,[SP, #+0]
   \   000001C4   0xB2C0             UXTB     R0,R0
   \   000001C6   0x9904             LDR      R1,[SP, #+16]
   \   000001C8   0x8408             STRH     R0,[R1, #+32]
    865              apsDataReq->txOptions.acknowledgedTransmission    = 1;
    866              apsDataReq->txOptions.doNotDecrypt                = 1;
    867              apsDataReq->txOptions.noRouteDiscovery            = 0;
   \   000001CA   0x9807             LDR      R0,[SP, #+28]
   \   000001CC   0x7800             LDRB     R0,[R0, #+0]
   \   000001CE   0x0640             LSLS     R0,R0,#+25
   \   000001D0   0x0E40             LSRS     R0,R0,#+25
   \   000001D2   0x2124             MOVS     R1,#+36
   \   000001D4   0x4301             ORRS     R1,R1,R0
   \   000001D6   0x9807             LDR      R0,[SP, #+28]
   \   000001D8   0x7001             STRB     R1,[R0, #+0]
    868              apsDataReq->radius                                = 0;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x9907             LDR      R1,[SP, #+28]
   \   000001DE   0x7048             STRB     R0,[R1, #+1]
    869              apsDataReq->asduLength = outPayloadLength;
    870              zclApsDataReq(apsDataReq, APS_SECURED_WITH_ANY_LINK_KEY_STATUS(apsDataInd->securityStatus));
   \   000001E0   0x980B             LDR      R0,[SP, #+44]
   \   000001E2   0x3049             ADDS     R0,R0,#+73
   \   000001E4   0x7800             LDRB     R0,[R0, #+0]
   \   000001E6   0x28AB             CMP      R0,#+171
   \   000001E8   0xD003             BEQ      ??zclReadReportingConfigurationHandler_13
   \   000001EA   0x28B1             CMP      R0,#+177
   \   000001EC   0xD001             BEQ      ??zclReadReportingConfigurationHandler_13
   \   000001EE   0x28B2             CMP      R0,#+178
   \   000001F0   0xD101             BNE      ??zclReadReportingConfigurationHandler_14
   \                     ??zclReadReportingConfigurationHandler_13: (+1)
   \   000001F2   0x2101             MOVS     R1,#+1
   \   000001F4   0xE000             B        ??zclReadReportingConfigurationHandler_15
   \                     ??zclReadReportingConfigurationHandler_14: (+1)
   \   000001F6   0x2100             MOVS     R1,#+0
   \                     ??zclReadReportingConfigurationHandler_15: (+1)
   \   000001F8   0x9805             LDR      R0,[SP, #+20]
   \   000001FA   0x.... 0x....      BL       zclApsDataReq
    871            }
    872          
    873            return true;
   \                     ??zclReadReportingConfigurationHandler_12: (+1)
   \   000001FE   0x2001             MOVS     R0,#+1
   \                     ??zclReadReportingConfigurationHandler_0: (+1)
   \   00000200   0xB00D             ADD      SP,SP,#+52
   \   00000202   0xBDF0             POP      {R4-R7,PC}       ;; return
    874          }
    875          
    876          
    877          /**************************************************************************//**
    878          \brief Handler for Configure Reporting command
    879          
    880          \param[in] apsDataInd - APS data indication
    881          \param[in, out] frameDescriptor - descriptor for creating response frame
    882          
    883          \returns true if corresponding request may be removed, false otherwise
    884          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    885          bool zclConfigureReportingHandler(APS_DataInd_t *apsDataInd, ZclFrameDescriptor_t *frameDescriptor)
    886          {
   \                     zclConfigureReportingHandler: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    887            ZclMmBuffer_t *outBuf;
    888            ZCL_ConfigureReportingResp_t *resp;
    889            ZCL_ConfigureReportingReq_t *req = (ZCL_ConfigureReportingReq_t *) frameDescriptor->payload;
   \   00000004   0x690D             LDR      R5,[R1, #+16]
    890            uint8_t inPayloadLength = frameDescriptor->payloadLength;
   \   00000006   0x7848             LDRB     R0,[R1, #+1]
   \   00000008   0x9009             STR      R0,[SP, #+36]
    891            uint8_t outPayloadLength;
    892            ZclAttribute_t *attribute;
    893            Endpoint_t endpoint = apsDataInd->dstEndpoint;
   \   0000000A   0x980B             LDR      R0,[SP, #+44]
   \   0000000C   0x3020             ADDS     R0,R0,#+32
   \   0000000E   0x9008             STR      R0,[SP, #+32]
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x7348             STRB     R0,[R1, #+13]
    894            ClusterId_t clusterId = apsDataInd->clusterId;
   \   00000016   0x9808             LDR      R0,[SP, #+32]
   \   00000018   0x8BC0             LDRH     R0,[R0, #+30]
   \   0000001A   0x81C8             STRH     R0,[R1, #+14]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7308             STRB     R0,[R1, #+12]
    895            uint8_t predictedRecordLength;
    896            uint8_t recordsProcessedAmount = 0;
    897            ZCL_Status_t status;
    898            uint8_t *ptr;
    899            APS_DataReq_t *apsDataReq;
    900            ZCL_DataTypeDescriptor_t dataTypeDescriptor;
    901          
    902            // get buffer for response
    903            outBuf = zclMmGetMem(ZCL_OUTPUT_RESPONSE_BUFFER);
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x.... 0x....      BL       zclMmGetMem
   \   00000026   0x9005             STR      R0,[SP, #+20]
    904            if (NULL == outBuf)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD100             BNE      .+4
   \   0000002C   0xE119             B        ??zclConfigureReportingHandler_0
    905              return false;
    906          
    907            apsDataReq = &outBuf->primitive.apsDataReq;
    908            apsDataReq->asdu = outBuf->frame + getZclAsduOffset();
   \   0000002E   0x3058             ADDS     R0,R0,#+88
   \   00000030   0x9006             STR      R0,[SP, #+24]
   \   00000032   0x9805             LDR      R0,[SP, #+20]
   \   00000034   0x3030             ADDS     R0,R0,#+48
   \   00000036   0x9004             STR      R0,[SP, #+16]
   \   00000038   0x9806             LDR      R0,[SP, #+24]
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0x303B             ADDS     R0,R0,#+59
   \   0000003E   0x9904             LDR      R1,[SP, #+16]
   \   00000040   0x6248             STR      R0,[R1, #+36]
    909            apsDataReq->APS_DataConf = configureReportingResponseConfirm;
   \   00000042   0x....             LDR      R0,??DataTable14
   \   00000044   0x9906             LDR      R1,[SP, #+24]
   \   00000046   0x6048             STR      R0,[R1, #+4]
    910          
    911            // form request header
    912            outPayloadLength = zclFormRequest(apsDataReq,
    913                                              ZCL_STANDARD_REQ_TYPE,
    914                                              getDstClusterSideByIncommingCommandDirection(frameDescriptor->direction),
    915                                              ZCL_CONFIGURE_REPORTING_RESPONSE_COMMAND_ID,
    916                                              ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RESPONSE,
    917                                              ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC,
    918                                              frameDescriptor->sequenceNumber);
   \   00000048   0x980C             LDR      R0,[SP, #+48]
   \   0000004A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000004C   0x.... 0x....      BL       getDstClusterSideByIncommingCommandDirection
   \   00000050   0x0002             MOVS     R2,R0
   \   00000052   0x980C             LDR      R0,[SP, #+48]
   \   00000054   0x7A00             LDRB     R0,[R0, #+8]
   \   00000056   0x9002             STR      R0,[SP, #+8]
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x2307             MOVS     R3,#+7
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x9805             LDR      R0,[SP, #+20]
   \   00000066   0x.... 0x....      BL       zclFormRequest
   \   0000006A   0x0007             MOVS     R7,R0
    919          
    920            resp = (ZCL_ConfigureReportingResp_t *) (outBuf->frame + getZclAsduOffset() + outPayloadLength);
   \   0000006C   0x9806             LDR      R0,[SP, #+24]
   \   0000006E   0x6900             LDR      R0,[R0, #+16]
   \   00000070   0x19C0             ADDS     R0,R0,R7
   \   00000072   0x303B             ADDS     R0,R0,#+59
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0xE00C             B        ??zclConfigureReportingHandler_1
    921          
    922            while (0 != inPayloadLength)
    923            {
    924              status = ZCL_SUCCESS_STATUS;
    925              predictedRecordLength = /*direction*/     sizeof(uint8_t) +
    926                                      /*attributeId*/   sizeof(uint16_t);
    927              if (ZCL_MAX_TX_ZSDU_SIZE >= outPayloadLength + sizeof(ZCL_ConfigureReportingResp_t))
    928              {
    929                if (ZCL_FRAME_CONTROL_DIRECTION_CLIENT_TO_SERVER == req->direction)
    930                {
    931                  ZCL_GetDataTypeDescriptor(req->attributeType, req->reportableChange, &dataTypeDescriptor);
    932                  predictedRecordLength +=  /*attributeType*/       sizeof(uint8_t) +
    933                                            /*minReportInterval*/   sizeof(uint16_t) +
    934                                            /*maxReportInterval*/   sizeof(uint16_t);
    935                  if (ZCL_DATA_TYPE_ANALOG_KIND == dataTypeDescriptor.kind)
    936                    predictedRecordLength += /*reportableChange*/    dataTypeDescriptor.length;
    937          
    938                  attribute = zclGetAttribute(endpoint, clusterId, frameDescriptor->direction, req->attributeId);
    939                  if (NULL == attribute)
    940                    status = ZCL_UNSUPPORTED_ATTRIBUTE_STATUS;
    941                  else
    942                  {
    943                    if (!(attribute->properties & ZCL_REPORTABLE_ATTRIBUTE))
    944                      status = ZCL_UNREPORTABLE_ATTRIBUTE_STATUS;
    945                    else
    946                    {
    947                      if (predictedRecordLength <= inPayloadLength)
    948                      {
    949                        if (attribute->type == req->attributeType)
    950                        {
    951                          if (req->maxReportingInterval && (req->maxReportingInterval < req->minReportingInterval))
    952                              status = ZCL_INVALID_VALUE_STATUS;
    953                          else
    954                          {
    955                          if (0xFFFF != req->maxReportingInterval)
    956                            attribute->properties |= ZCL_REPORTING_CONFIGURED;
    957                            else
    958                              attribute->properties &= ~(uint8_t)ZCL_REPORTING_CONFIGURED;
    959                          //Modify the internal ZCL attribute properties
    960                          ptr = (uint8_t *)attribute + SLICE_SIZE(ZclAttribute_t, id, properties);
    961                          //((u16Packed_t*)ptr)->val = req->maxReportingInterval;
    962                          ptr += sizeof(ZCL_ReportTime_t) + dataTypeDescriptor.length;
    963                          ((u16Packed_t*)ptr)->val = req->minReportingInterval;
    964                          ptr += sizeof(ZCL_ReportTime_t);
    965                          ((u16Packed_t*)ptr)->val = req->maxReportingInterval;
    966                          ptr += sizeof(ZCL_ReportTime_t);
    967                          if (ZCL_DATA_TYPE_ANALOG_KIND == dataTypeDescriptor.kind)
    968                            SYS_BYTE_MEMCPY(ptr, req->reportableChange, dataTypeDescriptor.length);
    969                            
    970                          zclAttributeEventInd(apsDataInd, frameDescriptor, ZCL_CONFIGURE_ATTRIBUTE_REPORTING_EVENT, req->attributeId);
    971                        }
    972                        }
    973                        else
    974                          status = ZCL_INVALID_DATA_TYPE_STATUS;
    975                      }
    976                      else
    977                        status = ZCL_INVALID_FIELD_STATUS;
    978                    }
    979                  }
    980                }
    981                else
    982                {
    983                  predictedRecordLength += sizeof(ZCL_ReportTime_t); // timeoutPeriod
    984                  zclAttributeEventInd(apsDataInd, frameDescriptor, ZCL_CONFIGURED_ATTRIBUTE_REPORTING_NOTIFICATION_EVENT, req->attributeId);
    985                }
    986          
    987                resp->status = status;
    988                resp->direction = req->direction;
    989                resp->attributeId = req->attributeId;
    990          
    991                if (predictedRecordLength <= inPayloadLength)
    992                  inPayloadLength -= predictedRecordLength;
    993                else
    994                  inPayloadLength = 0;
   \                     ??zclConfigureReportingHandler_2: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??zclConfigureReportingHandler_3: (+1)
   \   0000007A   0x9009             STR      R0,[SP, #+36]
    995                resp++;
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x1D00             ADDS     R0,R0,#+4
   \   00000080   0x9000             STR      R0,[SP, #+0]
    996                req = (ZCL_ConfigureReportingReq_t *) (((uint8_t *) req) + predictedRecordLength);
   \   00000082   0x19AD             ADDS     R5,R5,R6
    997                recordsProcessedAmount++;
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x7B00             LDRB     R0,[R0, #+12]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0x7308             STRB     R0,[R1, #+12]
    998                outPayloadLength += sizeof(ZCL_ConfigureReportingResp_t);
   \   0000008E   0x1D3F             ADDS     R7,R7,#+4
   \   00000090   0xB2FF             UXTB     R7,R7
   \                     ??zclConfigureReportingHandler_1: (+1)
   \   00000092   0x9809             LDR      R0,[SP, #+36]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD100             BNE      .+4
   \   00000098   0xE0A3             B        ??zclConfigureReportingHandler_4
   \   0000009A   0x2400             MOVS     R4,#+0
   \   0000009C   0x1D38             ADDS     R0,R7,#+4
   \   0000009E   0x283E             CMP      R0,#+62
   \   000000A0   0xD300             BCC      .+4
   \   000000A2   0xE09E             B        ??zclConfigureReportingHandler_4
   \   000000A4   0x7828             LDRB     R0,[R5, #+0]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD17B             BNE      ??zclConfigureReportingHandler_5
   \   000000AA   0xAA07             ADD      R2,SP,#+28
   \   000000AC   0x0029             MOVS     R1,R5
   \   000000AE   0x3108             ADDS     R1,R1,#+8
   \   000000B0   0x78E8             LDRB     R0,[R5, #+3]
   \   000000B2   0x.... 0x....      BL       ZCL_GetDataTypeDescriptor
   \   000000B6   0x2608             MOVS     R6,#+8
   \   000000B8   0xA807             ADD      R0,SP,#+28
   \   000000BA   0x7880             LDRB     R0,[R0, #+2]
   \   000000BC   0x2801             CMP      R0,#+1
   \   000000BE   0xD103             BNE      ??zclConfigureReportingHandler_6
   \   000000C0   0x4668             MOV      R0,SP
   \   000000C2   0x8B86             LDRH     R6,[R0, #+28]
   \   000000C4   0x3608             ADDS     R6,R6,#+8
   \   000000C6   0xB2F6             UXTB     R6,R6
   \                     ??zclConfigureReportingHandler_6: (+1)
   \   000000C8   0x786B             LDRB     R3,[R5, #+1]
   \   000000CA   0x78A8             LDRB     R0,[R5, #+2]
   \   000000CC   0x0600             LSLS     R0,R0,#+24
   \   000000CE   0x0C00             LSRS     R0,R0,#+16
   \   000000D0   0x4303             ORRS     R3,R3,R0
   \   000000D2   0x980C             LDR      R0,[SP, #+48]
   \   000000D4   0x78C2             LDRB     R2,[R0, #+3]
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x89C1             LDRH     R1,[R0, #+14]
   \   000000DA   0x7B40             LDRB     R0,[R0, #+13]
   \   000000DC   0x.... 0x....      BL       zclGetAttribute
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD101             BNE      ??zclConfigureReportingHandler_7
   \   000000E4   0x2486             MOVS     R4,#+134
   \   000000E6   0xE067             B        ??zclConfigureReportingHandler_8
   \                     ??zclConfigureReportingHandler_7: (+1)
   \   000000E8   0x78C1             LDRB     R1,[R0, #+3]
   \   000000EA   0x07CA             LSLS     R2,R1,#+31
   \   000000EC   0xD401             BMI      ??zclConfigureReportingHandler_9
   \   000000EE   0x248C             MOVS     R4,#+140
   \   000000F0   0xE062             B        ??zclConfigureReportingHandler_8
   \                     ??zclConfigureReportingHandler_9: (+1)
   \   000000F2   0x9A09             LDR      R2,[SP, #+36]
   \   000000F4   0x42B2             CMP      R2,R6
   \   000000F6   0xDB52             BLT      ??zclConfigureReportingHandler_10
   \   000000F8   0x7882             LDRB     R2,[R0, #+2]
   \   000000FA   0x78EB             LDRB     R3,[R5, #+3]
   \   000000FC   0x429A             CMP      R2,R3
   \   000000FE   0xD14C             BNE      ??zclConfigureReportingHandler_11
   \   00000100   0x79AA             LDRB     R2,[R5, #+6]
   \   00000102   0x79EB             LDRB     R3,[R5, #+7]
   \   00000104   0x061B             LSLS     R3,R3,#+24
   \   00000106   0x0C1B             LSRS     R3,R3,#+16
   \   00000108   0x431A             ORRS     R2,R2,R3
   \   0000010A   0xD011             BEQ      ??zclConfigureReportingHandler_12
   \   0000010C   0x79AA             LDRB     R2,[R5, #+6]
   \   0000010E   0x79EB             LDRB     R3,[R5, #+7]
   \   00000110   0x061B             LSLS     R3,R3,#+24
   \   00000112   0x0C1B             LSRS     R3,R3,#+16
   \   00000114   0x431A             ORRS     R2,R2,R3
   \   00000116   0x466B             MOV      R3,SP
   \   00000118   0x809A             STRH     R2,[R3, #+4]
   \   0000011A   0x792A             LDRB     R2,[R5, #+4]
   \   0000011C   0x796B             LDRB     R3,[R5, #+5]
   \   0000011E   0x061B             LSLS     R3,R3,#+24
   \   00000120   0x0C1B             LSRS     R3,R3,#+16
   \   00000122   0x431A             ORRS     R2,R2,R3
   \   00000124   0x466B             MOV      R3,SP
   \   00000126   0x889B             LDRH     R3,[R3, #+4]
   \   00000128   0x4293             CMP      R3,R2
   \   0000012A   0xD201             BCS      ??zclConfigureReportingHandler_12
   \   0000012C   0x2487             MOVS     R4,#+135
   \   0000012E   0xE043             B        ??zclConfigureReportingHandler_8
   \                     ??zclConfigureReportingHandler_12: (+1)
   \   00000130   0x79AA             LDRB     R2,[R5, #+6]
   \   00000132   0x79EB             LDRB     R3,[R5, #+7]
   \   00000134   0x061B             LSLS     R3,R3,#+24
   \   00000136   0x0C1B             LSRS     R3,R3,#+16
   \   00000138   0x431A             ORRS     R2,R2,R3
   \   0000013A   0x....             LDR      R3,??DataTable13  ;; 0xffff
   \   0000013C   0x429A             CMP      R2,R3
   \   0000013E   0xD002             BEQ      ??zclConfigureReportingHandler_13
   \   00000140   0x2204             MOVS     R2,#+4
   \   00000142   0x430A             ORRS     R2,R2,R1
   \   00000144   0xE001             B        ??zclConfigureReportingHandler_14
   \                     ??zclConfigureReportingHandler_13: (+1)
   \   00000146   0x22FB             MOVS     R2,#+251
   \   00000148   0x400A             ANDS     R2,R2,R1
   \                     ??zclConfigureReportingHandler_14: (+1)
   \   0000014A   0x70C2             STRB     R2,[R0, #+3]
   \   0000014C   0x4669             MOV      R1,SP
   \   0000014E   0x8B89             LDRH     R1,[R1, #+28]
   \   00000150   0x1840             ADDS     R0,R0,R1
   \   00000152   0x1D80             ADDS     R0,R0,#+6
   \   00000154   0x7929             LDRB     R1,[R5, #+4]
   \   00000156   0x796A             LDRB     R2,[R5, #+5]
   \   00000158   0x0612             LSLS     R2,R2,#+24
   \   0000015A   0x0C12             LSRS     R2,R2,#+16
   \   0000015C   0x4311             ORRS     R1,R1,R2
   \   0000015E   0x7001             STRB     R1,[R0, #+0]
   \   00000160   0x0A09             LSRS     R1,R1,#+8
   \   00000162   0x7041             STRB     R1,[R0, #+1]
   \   00000164   0x1C80             ADDS     R0,R0,#+2
   \   00000166   0x79A9             LDRB     R1,[R5, #+6]
   \   00000168   0x79EA             LDRB     R2,[R5, #+7]
   \   0000016A   0x0612             LSLS     R2,R2,#+24
   \   0000016C   0x0C12             LSRS     R2,R2,#+16
   \   0000016E   0x4311             ORRS     R1,R1,R2
   \   00000170   0x7001             STRB     R1,[R0, #+0]
   \   00000172   0x0A09             LSRS     R1,R1,#+8
   \   00000174   0x7041             STRB     R1,[R0, #+1]
   \   00000176   0xA907             ADD      R1,SP,#+28
   \   00000178   0x7889             LDRB     R1,[R1, #+2]
   \   0000017A   0x2901             CMP      R1,#+1
   \   0000017C   0xD106             BNE      ??zclConfigureReportingHandler_15
   \   0000017E   0x4669             MOV      R1,SP
   \   00000180   0x8B8A             LDRH     R2,[R1, #+28]
   \   00000182   0x0029             MOVS     R1,R5
   \   00000184   0x3108             ADDS     R1,R1,#+8
   \   00000186   0x1C80             ADDS     R0,R0,#+2
   \   00000188   0x.... 0x....      BL       SYS_ByteMemcpy
   \                     ??zclConfigureReportingHandler_15: (+1)
   \   0000018C   0x786B             LDRB     R3,[R5, #+1]
   \   0000018E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000190   0x0600             LSLS     R0,R0,#+24
   \   00000192   0x0C00             LSRS     R0,R0,#+16
   \   00000194   0x4303             ORRS     R3,R3,R0
   \   00000196   0x2202             MOVS     R2,#+2
   \   00000198   0xE00A             B        ??zclConfigureReportingHandler_16
   \                     ??zclConfigureReportingHandler_11: (+1)
   \   0000019A   0x248D             MOVS     R4,#+141
   \   0000019C   0xE00C             B        ??zclConfigureReportingHandler_8
   \                     ??zclConfigureReportingHandler_10: (+1)
   \   0000019E   0x2485             MOVS     R4,#+133
   \   000001A0   0xE00A             B        ??zclConfigureReportingHandler_8
   \                     ??zclConfigureReportingHandler_5: (+1)
   \   000001A2   0x2605             MOVS     R6,#+5
   \   000001A4   0x786B             LDRB     R3,[R5, #+1]
   \   000001A6   0x78A8             LDRB     R0,[R5, #+2]
   \   000001A8   0x0600             LSLS     R0,R0,#+24
   \   000001AA   0x0C00             LSRS     R0,R0,#+16
   \   000001AC   0x4303             ORRS     R3,R3,R0
   \   000001AE   0x2203             MOVS     R2,#+3
   \                     ??zclConfigureReportingHandler_16: (+1)
   \   000001B0   0x990C             LDR      R1,[SP, #+48]
   \   000001B2   0x980B             LDR      R0,[SP, #+44]
   \   000001B4   0x.... 0x....      BL       zclAttributeEventInd
   \                     ??zclConfigureReportingHandler_8: (+1)
   \   000001B8   0x9800             LDR      R0,[SP, #+0]
   \   000001BA   0x7004             STRB     R4,[R0, #+0]
   \   000001BC   0x7828             LDRB     R0,[R5, #+0]
   \   000001BE   0x9900             LDR      R1,[SP, #+0]
   \   000001C0   0x7048             STRB     R0,[R1, #+1]
   \   000001C2   0x7868             LDRB     R0,[R5, #+1]
   \   000001C4   0x78A9             LDRB     R1,[R5, #+2]
   \   000001C6   0x0609             LSLS     R1,R1,#+24
   \   000001C8   0x0C09             LSRS     R1,R1,#+16
   \   000001CA   0x4308             ORRS     R0,R0,R1
   \   000001CC   0x9900             LDR      R1,[SP, #+0]
   \   000001CE   0x7088             STRB     R0,[R1, #+2]
   \   000001D0   0x0A00             LSRS     R0,R0,#+8
   \   000001D2   0x70C8             STRB     R0,[R1, #+3]
   \   000001D4   0x9809             LDR      R0,[SP, #+36]
   \   000001D6   0x42B0             CMP      R0,R6
   \   000001D8   0xDA00             BGE      .+4
   \   000001DA   0xE74D             B        ??zclConfigureReportingHandler_2
   \   000001DC   0x1B80             SUBS     R0,R0,R6
   \   000001DE   0xB2C0             UXTB     R0,R0
   \   000001E0   0xE74B             B        ??zclConfigureReportingHandler_3
    999              }
   1000              else
   1001                break;
   1002            }
   1003          
   1004            if (0 == recordsProcessedAmount)
   \                     ??zclConfigureReportingHandler_4: (+1)
   \   000001E2   0x4668             MOV      R0,SP
   \   000001E4   0x7B00             LDRB     R0,[R0, #+12]
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD103             BNE      ??zclConfigureReportingHandler_17
   1005              zclMmFreeMem(outBuf);
   \   000001EA   0x9805             LDR      R0,[SP, #+20]
   \   000001EC   0x.... 0x....      BL       zclMmFreeMem
   \   000001F0   0xE036             B        ??zclConfigureReportingHandler_18
   1006            else
   1007            {
   1008              //APS Data Request for response
   1009              apsDataReq->dstAddrMode = apsDataInd->srcAddrMode;
   \                     ??zclConfigureReportingHandler_17: (+1)
   \   000001F2   0x9808             LDR      R0,[SP, #+32]
   \   000001F4   0x7840             LDRB     R0,[R0, #+1]
   \   000001F6   0x9904             LDR      R1,[SP, #+16]
   \   000001F8   0x7008             STRB     R0,[R1, #+0]
   1010              SYS_BYTE_MEMCPY(&apsDataReq->dstAddress, &apsDataInd->srcAddress, sizeof(APS_Address_t));
   \   000001FA   0x2210             MOVS     R2,#+16
   \   000001FC   0x990B             LDR      R1,[SP, #+44]
   \   000001FE   0x3128             ADDS     R1,R1,#+40
   \   00000200   0x9805             LDR      R0,[SP, #+20]
   \   00000202   0x3038             ADDS     R0,R0,#+56
   \   00000204   0x.... 0x....      BL       SYS_ByteMemcpy
   1011              apsDataReq->dstEndpoint = apsDataInd->srcEndpoint;
   \   00000208   0x9808             LDR      R0,[SP, #+32]
   \   0000020A   0x7E80             LDRB     R0,[R0, #+26]
   \   0000020C   0x9904             LDR      R1,[SP, #+16]
   \   0000020E   0x7608             STRB     R0,[R1, #+24]
   1012              apsDataReq->srcEndpoint = apsDataInd->dstEndpoint;
   \   00000210   0x9808             LDR      R0,[SP, #+32]
   \   00000212   0x7800             LDRB     R0,[R0, #+0]
   \   00000214   0x9904             LDR      R1,[SP, #+16]
   \   00000216   0x7788             STRB     R0,[R1, #+30]
   1013              apsDataReq->clusterId = clusterId;
   \   00000218   0x4668             MOV      R0,SP
   \   0000021A   0x89C0             LDRH     R0,[R0, #+14]
   \   0000021C   0x9904             LDR      R1,[SP, #+16]
   \   0000021E   0x8388             STRH     R0,[R1, #+28]
   1014              apsDataReq->profileId = apsDataInd->profileId;
   \   00000220   0x9808             LDR      R0,[SP, #+32]
   \   00000222   0x8B80             LDRH     R0,[R0, #+28]
   \   00000224   0x9904             LDR      R1,[SP, #+16]
   \   00000226   0x8348             STRH     R0,[R1, #+26]
   1015              apsDataReq->asduLength = outPayloadLength;
   \   00000228   0x9804             LDR      R0,[SP, #+16]
   \   0000022A   0x8407             STRH     R7,[R0, #+32]
   1016              apsDataReq->txOptions.acknowledgedTransmission    = 1;
   1017              apsDataReq->txOptions.doNotDecrypt                = 1;
   1018              apsDataReq->txOptions.noRouteDiscovery            = 0;
   \   0000022C   0x9806             LDR      R0,[SP, #+24]
   \   0000022E   0x7800             LDRB     R0,[R0, #+0]
   \   00000230   0x0640             LSLS     R0,R0,#+25
   \   00000232   0x0E40             LSRS     R0,R0,#+25
   \   00000234   0x2124             MOVS     R1,#+36
   \   00000236   0x4301             ORRS     R1,R1,R0
   \   00000238   0x9806             LDR      R0,[SP, #+24]
   \   0000023A   0x7001             STRB     R1,[R0, #+0]
   1019              apsDataReq->radius                                = 0;
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0x9906             LDR      R1,[SP, #+24]
   \   00000240   0x7048             STRB     R0,[R1, #+1]
   1020              apsDataReq->asduLength = outPayloadLength;
   1021              zclApsDataReq(apsDataReq, APS_SECURED_WITH_ANY_LINK_KEY_STATUS(apsDataInd->securityStatus));
   \   00000242   0x980B             LDR      R0,[SP, #+44]
   \   00000244   0x3049             ADDS     R0,R0,#+73
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0x28AB             CMP      R0,#+171
   \   0000024A   0xD003             BEQ      ??zclConfigureReportingHandler_19
   \   0000024C   0x28B1             CMP      R0,#+177
   \   0000024E   0xD001             BEQ      ??zclConfigureReportingHandler_19
   \   00000250   0x28B2             CMP      R0,#+178
   \   00000252   0xD101             BNE      ??zclConfigureReportingHandler_20
   \                     ??zclConfigureReportingHandler_19: (+1)
   \   00000254   0x2101             MOVS     R1,#+1
   \   00000256   0xE000             B        ??zclConfigureReportingHandler_21
   \                     ??zclConfigureReportingHandler_20: (+1)
   \   00000258   0x2100             MOVS     R1,#+0
   \                     ??zclConfigureReportingHandler_21: (+1)
   \   0000025A   0x9805             LDR      R0,[SP, #+20]
   \   0000025C   0x.... 0x....      BL       zclApsDataReq
   1022            }
   1023          
   1024            return true;
   \                     ??zclConfigureReportingHandler_18: (+1)
   \   00000260   0x2001             MOVS     R0,#+1
   \                     ??zclConfigureReportingHandler_0: (+1)
   \   00000262   0xB00D             ADD      SP,SP,#+52
   \   00000264   0xBDF0             POP      {R4-R7,PC}       ;; return
   1025          }
   1026          
   1027          /**************************************************************************//**
   1028          \brief Callback for ZCL wait-for-response timer
   1029          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1030          static void zclWaitTimerFired(void)
   1031          {
   \                     zclWaitTimerFired: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1032            ZclMmBufferDescriptor_t *descr = NULL;
   \   00000002   0x2400             MOVS     R4,#+0
   1033            uint32_t minTimeout = ~0ul;
   \   00000004   0x2700             MOVS     R7,#+0
   \   00000006   0x43FF             MVNS     R7,R7            ;; #-1
   \   00000008   0x003D             MOVS     R5,R7
   \   0000000A   0xE00D             B        ??zclWaitTimerFired_0
   1034          
   1035            while (NULL != (descr = zclMmGetNextOutputMemDescriptor(descr)))
   1036            {
   1037              ZCL_Request_t *req = descr->link;
   1038          
   1039              if (req->service.statusflags & ZCL_REQ_FLAG_CONF_RCVD)
   1040              {
   1041                descr->timeout -= zclModuleMem.waitTimer.timer.interval;
   1042                if (0 == descr->timeout)
   1043                {
   1044                  zclMmFreeMem(&descr->buf);
   \                     ??zclWaitTimerFired_1: (+1)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x3010             ADDS     R0,R0,#+16
   \   00000010   0x.... 0x....      BL       zclMmFreeMem
   1045                  req->notify.status = ZCL_NO_RESPONSE_ERROR_STATUS;
   \   00000014   0x20C3             MOVS     R0,#+195
   \   00000016   0x7230             STRB     R0,[R6, #+8]
   1046                  req->notify.id     = ZCL_ZCL_RESPONSE_ID;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x7270             STRB     R0,[R6, #+9]
   1047                  if (req->ZCL_Notify)
   \   0000001C   0x69B1             LDR      R1,[R6, #+24]
   \   0000001E   0x0008             MOVS     R0,R1
   \   00000020   0xD002             BEQ      ??zclWaitTimerFired_0
   1048                    req->ZCL_Notify(&req->notify);
   \   00000022   0x3608             ADDS     R6,R6,#+8
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x4788             BLX      R1
   1049                }
   \                     ??zclWaitTimerFired_0: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   0000002E   0x0004             MOVS     R4,R0
   \   00000030   0xD00D             BEQ      ??zclWaitTimerFired_2
   \   00000032   0x68A6             LDR      R6,[R4, #+8]
   \   00000034   0x7970             LDRB     R0,[R6, #+5]
   \   00000036   0x0780             LSLS     R0,R0,#+30
   \   00000038   0xD5F6             BPL      ??zclWaitTimerFired_0
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x....             LDR      R1,??DataTable15
   \   0000003E   0x68C9             LDR      R1,[R1, #+12]
   \   00000040   0x1A40             SUBS     R0,R0,R1
   \   00000042   0x6020             STR      R0,[R4, #+0]
   \   00000044   0xD0E2             BEQ      ??zclWaitTimerFired_1
   1050                else
   1051                  minTimeout = MIN(minTimeout, descr->timeout);
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD3EE             BCC      ??zclWaitTimerFired_0
   \   0000004A   0x0005             MOVS     R5,R0
   \   0000004C   0xE7EC             B        ??zclWaitTimerFired_0
   1052              }
   1053            }
   1054          
   1055            if (~0ul != minTimeout)
   \                     ??zclWaitTimerFired_2: (+1)
   \   0000004E   0x42BD             CMP      R5,R7
   \   00000050   0xD002             BEQ      ??zclWaitTimerFired_3
   1056            {
   1057              SYS_InitTimer(&zclModuleMem.waitTimer, TIMER_ONE_SHOT_MODE, minTimeout, zclWaitTimerFired);
   \   00000052   0x....             LDR      R3,??DataTable15_1
   \   00000054   0x002A             MOVS     R2,R5
   \   00000056   0x....             B.N      ?Subroutine2
   1058              SYS_StartTimer(&zclModuleMem.waitTimer);
   1059            }
   1060            else
   1061              zclStopResponseWaitTimer();
   \                     ??zclWaitTimerFired_3: (+1)
   \   00000058   0x....             LDR      R0,??DataTable15
   \   0000005A   0x.... 0x....      BL       SYS_StopTimer
   1062          }
   \   0000005E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR      R0,??DataTable17_2
   \   00000004   0x.... 0x....      BL       SYS_InitTimer
   \   00000008   0x....             LDR      R0,??DataTable17_2
   \   0000000A                      REQUIRE ??Subroutine3_0
   \   0000000A                      ;; // Fall through to label ??Subroutine3_0
   1063          
   1064          /**************************************************************************//**
   1065          \brief Callback for ZCL periodic report timer
   1066          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1067          static void zclReportTimerFired(void)
   1068          {
   \                     zclReportTimerFired: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9004             STR      R0,[SP, #+16]
   1069            ZclMmBuffer_t *reportFrame = NULL;
   1070            ZCL_DeviceEndpoint_t *endpoint = NULL;
   \   00000008   0x9006             STR      R0,[SP, #+24]
   1071            ZCL_Cluster_t *cluster = NULL;
   \   0000000A   0x9005             STR      R0,[SP, #+20]
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0x43FF             MVNS     R7,R7            ;; #-1
   1072            uint8_t clusterCounter;
   1073            uint32_t minTimeout = ~0ul;
   1074          
   1075            // For all endpoints
   1076            while (NULL != (endpoint = zclNextEndpoint(endpoint)))
   \                     ??zclReportTimerFired_0: (+1)
   \   00000010   0x9806             LDR      R0,[SP, #+24]
   \   00000012   0x.... 0x....      BL       zclNextEndpoint
   \   00000016   0x9006             STR      R0,[SP, #+24]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD100             BNE      .+4
   \   0000001C   0xE147             B        ??zclReportTimerFired_1
   1077            {
   1078              clusterCounter = endpoint->simpleDescriptor.AppInClustersCount;
   \   0000001E   0x7E80             LDRB     R0,[R0, #+26]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x7308             STRB     R0,[R1, #+12]
   1079              // For all clusters
   1080              if (clusterCounter)
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x7B00             LDRB     R0,[R0, #+12]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD061             BEQ      ??zclReportTimerFired_2
   1081                cluster = ZCL_GetHeadCluster(endpoint, ZCL_CLUSTER_SIDE_SERVER);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x9806             LDR      R0,[SP, #+24]
   \   00000030   0x.... 0x....      BL       ZCL_GetHeadCluster
   \   00000034   0xE05B             B        ??zclReportTimerFired_3
   1082          
   1083              while (clusterCounter--)
   1084              {
   1085                uint8_t *reportPayload = NULL;
   1086                uint8_t *attrPtr = cluster->attributes;
   1087                ZclCommand_t *command = NULL;
   1088                // For all attributes from this cluster
   1089                for (uint8_t attrIndex = 0; attrIndex < cluster->attributesAmount; attrIndex++)
   1090                {
   1091                  ZclAttribute_t *attr = (ZclAttribute_t *)attrPtr;
   1092                  uint8_t attrLength = ZCL_GetAttributeLength(attr->type, (uint8_t *)&attr->value);
   1093          		uint8_t boundaryCheckParamLength = 0;
   1094          		if (attr->properties & ZCL_BOUNDARY_CHECK)
   1095                  {
   1096                    if (attr->properties & ZCL_CHECK_OTHER_ATTR)
   1097                      boundaryCheckParamLength = sizeof(ZCL_AttributeId_t) * 2;
   1098          		  else
   1099                      boundaryCheckParamLength = attrLength * 2;
   1100          		}
   1101                  // Advance to next attribute (length of attribute struct = size of common fields + size of value)
   1102                  attrPtr += SLICE_SIZE(ZclAttribute_t, id, properties) + attrLength;
   1103          
   1104                  if (!(attr->properties & ZCL_REPORTABLE_ATTRIBUTE))
   1105                  {
   1106                    attrPtr += boundaryCheckParamLength;
   1107                    continue;
   1108                  }
   1109                  if (!isReportingPermitted(attr))
   1110                  {
   1111                    attrPtr += sizeof(ZclReportableAttributeTail_t) + attrLength + sizeof(ZCL_ReportTime_t) + attrLength + boundaryCheckParamLength; // tail + reportableChange + timeoutPeriod + value + boundary check parameters
   1112                    continue;
   1113                  }
   1114          
   1115                  // Reportable attributes have an extra fields - attributePointer in fact points to them
   1116                  ZclReportableAttributeTail_t *tail = (ZclReportableAttributeTail_t *)attrPtr;
   1117                  uint8_t *pLastRepValue = attrPtr + sizeof(ZclReportableAttributeTail_t) + attrLength + sizeof(ZCL_ReportTime_t);
   1118          
   1119                  attrPtr += sizeof(ZclReportableAttributeTail_t) + attrLength + sizeof(ZCL_ReportTime_t) + attrLength + boundaryCheckParamLength; // tail + reportableChange + timeoutPeriod + value + boundary check parameters
   1120                  tail->reportCounter += zclModuleMem.reportTimer.timer.interval / 1000;
   1121          
   1122                  if (attr->properties & ZCL_ON_CHANGE_REPORT)
   1123                  {
   1124                    if (tail->reportCounter < tail->minReportInterval)
   1125                    {
   1126                      minTimeout = MIN(minTimeout, (uint32_t)(tail->minReportInterval - tail->reportCounter));
   1127                      continue;
   1128                    }
   1129                    attr->properties &= ~ZCL_ON_CHANGE_REPORT;
   1130                    // Need to send report and check for maxReportInterval to schedulethe next report
   1131                    if (tail->maxReportInterval)
   1132                      minTimeout = MIN(minTimeout, tail->maxReportInterval);
   1133                  }
   1134                  else if(tail->maxReportInterval)
   1135                  {
   1136                    if (tail->reportCounter < tail->maxReportInterval)
   1137                    {
   1138                    minTimeout = MIN(minTimeout, (uint32_t)(tail->maxReportInterval - tail->reportCounter));
   1139                    continue;
   1140                  }
   1141                    // scheduling next report after sending the current report
   1142                  minTimeout = MIN(minTimeout, tail->maxReportInterval);
   \                     ??zclReportTimerFired_4: (+1)
   \   00000036   0x0609             LSLS     R1,R1,#+24
   \   00000038   0x0C09             LSRS     R1,R1,#+16
   \   0000003A   0x4308             ORRS     R0,R0,R1
   \   0000003C   0x4287             CMP      R7,R0
   \   0000003E   0xD304             BCC      ??zclReportTimerFired_5
   \   00000040   0x7927             LDRB     R7,[R4, #+4]
   \   00000042   0x7960             LDRB     R0,[R4, #+5]
   \   00000044   0x0600             LSLS     R0,R0,#+24
   \   00000046   0x0C00             LSRS     R0,R0,#+16
   \   00000048   0x4307             ORRS     R7,R7,R0
   1143                  }
   1144                  else
   1145                  {
   1146                    // maxReportInterval is zero & change report is not enabled so nothing to do
   1147                    continue;
   1148                  }
   1149                  tail->reportCounter = 0;
   \                     ??zclReportTimerFired_5: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
   \   0000004E   0x7060             STRB     R0,[R4, #+1]
   1150          
   1151                  if (NULL == reportFrame)
   \   00000050   0x9804             LDR      R0,[SP, #+16]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD171             BNE      ??zclReportTimerFired_6
   1152                  {
   1153                    // First attribute in report - construct header
   1154                    uint8_t headerLength;
   1155          
   1156                    reportFrame = zclMmGetMem(ZCL_OUTPUT_REPORT_BUFFER);
   \   00000056   0x2004             MOVS     R0,#+4
   \   00000058   0x.... 0x....      BL       zclMmGetMem
   \   0000005C   0x9004             STR      R0,[SP, #+16]
   1157                    if (NULL == reportFrame)
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD153             BNE      ??zclReportTimerFired_7
   1158                    {
   1159                      //skip attribute reporting
   1160                      //report will be postponed to next iteration
   1161                      break;
   1162                    }
   1163                    reportFrame->primitive.apsDataReq.asdu = reportFrame->frame + getZclAsduOffset();
   1164                    reportFrame->primitive.apsDataReq.APS_DataConf = reportConfirm;
   1165          
   1166                    // form request header
   1167                    headerLength = zclFormRequest(&reportFrame->primitive.apsDataReq,
   1168                                                  ZCL_STANDARD_REQ_TYPE,
   1169                                                  ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT,
   1170                                                  ZCL_REPORT_ATTRIBUTES_COMMAND_ID,
   1171                                                  ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RESPONSE,
   1172                                                  ZCL_FRAME_CONTROL_MANUFACTURER_NONSPECIFIC,
   1173                                                  ZCL_GetNextSeqNumber());
   1174          
   1175                    reportPayload = reportFrame->primitive.apsDataReq.asdu + headerLength;
   1176                  }
   1177          
   1178                  memcpy(pLastRepValue, attr->value, attrLength);
   1179                  tail->reportCounter = 0;
   1180                  reportPayload += addToReportPayload(reportPayload, attr);
   1181                }
   1182          
   1183                //if there is something to send
   1184                if (reportPayload)
   \                     ??zclReportTimerFired_8: (+1)
   \   00000062   0x9801             LDR      R0,[SP, #+4]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD03B             BEQ      ??zclReportTimerFired_9
   1185                {
   1186                  reportFrame->primitive.apsDataReq.dstAddrMode = APS_NO_ADDRESS;
   \   00000068   0x9D04             LDR      R5,[SP, #+16]
   \   0000006A   0x3530             ADDS     R5,R5,#+48
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7028             STRB     R0,[R5, #+0]
   1187                  reportFrame->primitive.apsDataReq.clusterId = cluster->id;
   \   00000070   0x9805             LDR      R0,[SP, #+20]
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x83A8             STRH     R0,[R5, #+28]
   1188                  reportFrame->primitive.apsDataReq.profileId = endpoint->simpleDescriptor.AppProfileId;
   \   00000076   0x9906             LDR      R1,[SP, #+24]
   \   00000078   0x7D48             LDRB     R0,[R1, #+21]
   \   0000007A   0x7D8A             LDRB     R2,[R1, #+22]
   \   0000007C   0x0612             LSLS     R2,R2,#+24
   \   0000007E   0x0C12             LSRS     R2,R2,#+16
   \   00000080   0x4310             ORRS     R0,R0,R2
   \   00000082   0x8368             STRH     R0,[R5, #+26]
   1189                  reportFrame->primitive.apsDataReq.txOptions.acknowledgedTransmission = 0;
   \   00000084   0x9C04             LDR      R4,[SP, #+16]
   \   00000086   0x3458             ADDS     R4,R4,#+88
   \   00000088   0x7820             LDRB     R0,[R4, #+0]
   \   0000008A   0x21FB             MOVS     R1,#+251
   \   0000008C   0x4001             ANDS     R1,R1,R0
   \   0000008E   0x7021             STRB     R1,[R4, #+0]
   1190                  command = zclGetCommandByCluster(cluster,
   1191                                                   ZCL_FRAME_CONTROL_DIRECTION_SERVER_TO_CLIENT,
   1192                                                   ZCL_REPORT_ATTRIBUTES_COMMAND_ID);
   \   00000090   0x220A             MOVS     R2,#+10
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x9805             LDR      R0,[SP, #+20]
   \   00000096   0x.... 0x....      BL       zclGetCommandByCluster
   1193                  if (command && command->options.ackRequest)
   \   0000009A   0x2101             MOVS     R1,#+1
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD007             BEQ      ??zclReportTimerFired_10
   \   000000A0   0x7840             LDRB     R0,[R0, #+1]
   \   000000A2   0x0900             LSRS     R0,R0,#+4
   \   000000A4   0x4208             TST      R0,R1
   \   000000A6   0xD003             BEQ      ??zclReportTimerFired_10
   1194                    reportFrame->primitive.apsDataReq.txOptions.acknowledgedTransmission = 1;
   \   000000A8   0x7820             LDRB     R0,[R4, #+0]
   \   000000AA   0x2204             MOVS     R2,#+4
   \   000000AC   0x4302             ORRS     R2,R2,R0
   \   000000AE   0x7022             STRB     R2,[R4, #+0]
   1195          
   1196                  reportFrame->primitive.apsDataReq.txOptions.doNotDecrypt = 0;
   1197                  reportFrame->primitive.apsDataReq.txOptions.noRouteDiscovery = 0;
   \                     ??zclReportTimerFired_10: (+1)
   \   000000B0   0x7820             LDRB     R0,[R4, #+0]
   \   000000B2   0x225F             MOVS     R2,#+95
   \   000000B4   0x4002             ANDS     R2,R2,R0
   \   000000B6   0x7022             STRB     R2,[R4, #+0]
   1198                  reportFrame->primitive.apsDataReq.radius = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x7060             STRB     R0,[R4, #+1]
   1199                  reportFrame->primitive.apsDataReq.srcEndpoint = endpoint->simpleDescriptor.endpoint;
   \   000000BC   0x9806             LDR      R0,[SP, #+24]
   \   000000BE   0x7D00             LDRB     R0,[R0, #+20]
   \   000000C0   0x77A8             STRB     R0,[R5, #+30]
   1200                  // set frame payload size
   1201                  reportFrame->primitive.apsDataReq.asduLength = reportPayload - reportFrame->primitive.apsDataReq.asdu;
   \   000000C2   0x9801             LDR      R0,[SP, #+4]
   \   000000C4   0x6A6A             LDR      R2,[R5, #+36]
   \   000000C6   0x1A80             SUBS     R0,R0,R2
   \   000000C8   0x8428             STRH     R0,[R5, #+32]
   1202                  cluster->isReporting = 1;
   \   000000CA   0x9805             LDR      R0,[SP, #+20]
   \   000000CC   0x7401             STRB     R1,[R0, #+16]
   1203                  zclApsDataReq(&reportFrame->primitive.apsDataReq, cluster->options.security);
   \   000000CE   0x9805             LDR      R0,[SP, #+20]
   \   000000D0   0x7880             LDRB     R0,[R0, #+2]
   \   000000D2   0x0781             LSLS     R1,R0,#+30
   \   000000D4   0x0FC9             LSRS     R1,R1,#+31
   \   000000D6   0x9804             LDR      R0,[SP, #+16]
   \   000000D8   0x.... 0x....      BL       zclApsDataReq
   1204                  reportFrame = NULL; //allocate new frame if needed
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x9004             STR      R0,[SP, #+16]
   1205                }
   1206                if (clusterCounter)
   \                     ??zclReportTimerFired_9: (+1)
   \   000000E0   0x4668             MOV      R0,SP
   \   000000E2   0x7B00             LDRB     R0,[R0, #+12]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD003             BEQ      ??zclReportTimerFired_2
   1207                  cluster = ZCL_GetNextCluster(cluster);
   \   000000E8   0x9805             LDR      R0,[SP, #+20]
   \   000000EA   0x.... 0x....      BL       ZCL_GetNextCluster
   \                     ??zclReportTimerFired_3: (+1)
   \   000000EE   0x9005             STR      R0,[SP, #+20]
   \                     ??zclReportTimerFired_2: (+1)
   \   000000F0   0x4668             MOV      R0,SP
   \   000000F2   0x7B00             LDRB     R0,[R0, #+12]
   \   000000F4   0x1E41             SUBS     R1,R0,#+1
   \   000000F6   0x466A             MOV      R2,SP
   \   000000F8   0x7311             STRB     R1,[R2, #+12]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD088             BEQ      ??zclReportTimerFired_0
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9001             STR      R0,[SP, #+4]
   \   00000102   0x9805             LDR      R0,[SP, #+20]
   \   00000104   0x6846             LDR      R6,[R0, #+4]
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xE037             B        ??zclReportTimerFired_11
   \                     ??zclReportTimerFired_7: (+1)
   \   0000010A   0x6E80             LDR      R0,[R0, #+104]
   \   0000010C   0x303B             ADDS     R0,R0,#+59
   \   0000010E   0x9904             LDR      R1,[SP, #+16]
   \   00000110   0x6548             STR      R0,[R1, #+84]
   \   00000112   0x....             LDR      R0,??DataTable16
   \   00000114   0x9904             LDR      R1,[SP, #+16]
   \   00000116   0x65C8             STR      R0,[R1, #+92]
   \   00000118   0x.... 0x....      BL       ZCL_GetNextSeqNumber
   \   0000011C   0x9002             STR      R0,[SP, #+8]
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x9001             STR      R0,[SP, #+4]
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x9000             STR      R0,[SP, #+0]
   \   00000126   0x230A             MOVS     R3,#+10
   \   00000128   0x2201             MOVS     R2,#+1
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0x9804             LDR      R0,[SP, #+16]
   \   0000012E   0x.... 0x....      BL       zclFormRequest
   \   00000132   0x9904             LDR      R1,[SP, #+16]
   \   00000134   0x6D49             LDR      R1,[R1, #+84]
   \   00000136   0x1808             ADDS     R0,R1,R0
   \   00000138   0x9001             STR      R0,[SP, #+4]
   \                     ??zclReportTimerFired_6: (+1)
   \   0000013A   0x9A07             LDR      R2,[SP, #+28]
   \   0000013C   0x1D29             ADDS     R1,R5,#+4
   \   0000013E   0x9808             LDR      R0,[SP, #+32]
   \   00000140   0x.... 0x....      BL       __aeabi_memcpy
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x7020             STRB     R0,[R4, #+0]
   \   00000148   0x7060             STRB     R0,[R4, #+1]
   \   0000014A   0x1D29             ADDS     R1,R5,#+4
   \   0000014C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000014E   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000152   0xB2C4             UXTB     R4,R0
   \   00000154   0x2203             MOVS     R2,#+3
   \   00000156   0x0029             MOVS     R1,R5
   \   00000158   0x9801             LDR      R0,[SP, #+4]
   \   0000015A   0x.... 0x....      BL       SYS_ByteMemcpy
   \   0000015E   0x0022             MOVS     R2,R4
   \   00000160   0x1D29             ADDS     R1,R5,#+4
   \   00000162   0x9801             LDR      R0,[SP, #+4]
   \   00000164   0x1CC0             ADDS     R0,R0,#+3
   \   00000166   0x.... 0x....      BL       SYS_ByteMemcpy
   \   0000016A   0x9801             LDR      R0,[SP, #+4]
   \   0000016C   0x1CE4             ADDS     R4,R4,#+3
   \   0000016E   0xB2E4             UXTB     R4,R4
   \   00000170   0x1900             ADDS     R0,R0,R4
   \   00000172   0x9001             STR      R0,[SP, #+4]
   \                     ??zclReportTimerFired_12: (+1)
   \   00000174   0x4668             MOV      R0,SP
   \   00000176   0x7B40             LDRB     R0,[R0, #+13]
   \   00000178   0x1C40             ADDS     R0,R0,#+1
   \                     ??zclReportTimerFired_11: (+1)
   \   0000017A   0x4669             MOV      R1,SP
   \   0000017C   0x7348             STRB     R0,[R1, #+13]
   \   0000017E   0x4668             MOV      R0,SP
   \   00000180   0x7B40             LDRB     R0,[R0, #+13]
   \   00000182   0x9905             LDR      R1,[SP, #+20]
   \   00000184   0x78C9             LDRB     R1,[R1, #+3]
   \   00000186   0x4288             CMP      R0,R1
   \   00000188   0xD300             BCC      .+4
   \   0000018A   0xE76A             B        ??zclReportTimerFired_8
   \   0000018C   0x0035             MOVS     R5,R6
   \   0000018E   0x1D29             ADDS     R1,R5,#+4
   \   00000190   0x78A8             LDRB     R0,[R5, #+2]
   \   00000192   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   00000196   0xB2C0             UXTB     R0,R0
   \   00000198   0x9007             STR      R0,[SP, #+28]
   \   0000019A   0x2100             MOVS     R1,#+0
   \   0000019C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000019E   0x06C2             LSLS     R2,R0,#+27
   \   000001A0   0xD505             BPL      ??zclReportTimerFired_13
   \   000001A2   0x0681             LSLS     R1,R0,#+26
   \   000001A4   0xD501             BPL      ??zclReportTimerFired_14
   \   000001A6   0x2104             MOVS     R1,#+4
   \   000001A8   0xE001             B        ??zclReportTimerFired_13
   \                     ??zclReportTimerFired_14: (+1)
   \   000001AA   0x9907             LDR      R1,[SP, #+28]
   \   000001AC   0x0049             LSLS     R1,R1,#+1
   \                     ??zclReportTimerFired_13: (+1)
   \   000001AE   0x9A07             LDR      R2,[SP, #+28]
   \   000001B0   0x18B4             ADDS     R4,R6,R2
   \   000001B2   0x1D24             ADDS     R4,R4,#+4
   \   000001B4   0x07C0             LSLS     R0,R0,#+31
   \   000001B6   0xD402             BMI      ??zclReportTimerFired_15
   \   000001B8   0xB2C9             UXTB     R1,R1
   \   000001BA   0x1866             ADDS     R6,R4,R1
   \   000001BC   0xE7DA             B        ??zclReportTimerFired_12
   \                     ??zclReportTimerFired_15: (+1)
   \   000001BE   0x0050             LSLS     R0,R2,#+1
   \   000001C0   0xB2C9             UXTB     R1,R1
   \   000001C2   0x1840             ADDS     R0,R0,R1
   \   000001C4   0x1826             ADDS     R6,R4,R0
   \   000001C6   0x0028             MOVS     R0,R5
   \   000001C8   0x.... 0x....      BL       isReportingPermitted
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD101             BNE      ??zclReportTimerFired_16
   \   000001D0   0x3608             ADDS     R6,R6,#+8
   \   000001D2   0xE7CF             B        ??zclReportTimerFired_12
   \                     ??zclReportTimerFired_16: (+1)
   \   000001D4   0x9807             LDR      R0,[SP, #+28]
   \   000001D6   0x1820             ADDS     R0,R4,R0
   \   000001D8   0x3008             ADDS     R0,R0,#+8
   \   000001DA   0x9008             STR      R0,[SP, #+32]
   \   000001DC   0x3608             ADDS     R6,R6,#+8
   \   000001DE   0x7821             LDRB     R1,[R4, #+0]
   \   000001E0   0x7860             LDRB     R0,[R4, #+1]
   \   000001E2   0x0600             LSLS     R0,R0,#+24
   \   000001E4   0x0C00             LSRS     R0,R0,#+16
   \   000001E6   0x4301             ORRS     R1,R1,R0
   \   000001E8   0x9100             STR      R1,[SP, #+0]
   \   000001EA   0x....             LDR      R0,??DataTable15
   \   000001EC   0x6A40             LDR      R0,[R0, #+36]
   \   000001EE   0x21FA             MOVS     R1,#+250
   \   000001F0   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   000001F2   0x.... 0x....      BL       __aeabi_uidiv
   \   000001F6   0x9900             LDR      R1,[SP, #+0]
   \   000001F8   0x1808             ADDS     R0,R1,R0
   \   000001FA   0x7020             STRB     R0,[R4, #+0]
   \   000001FC   0x0A00             LSRS     R0,R0,#+8
   \   000001FE   0x7060             STRB     R0,[R4, #+1]
   \   00000200   0x78E8             LDRB     R0,[R5, #+3]
   \   00000202   0x0701             LSLS     R1,R0,#+28
   \   00000204   0xD531             BPL      ??zclReportTimerFired_17
   \   00000206   0x7821             LDRB     R1,[R4, #+0]
   \   00000208   0x7862             LDRB     R2,[R4, #+1]
   \   0000020A   0x0612             LSLS     R2,R2,#+24
   \   0000020C   0x0C12             LSRS     R2,R2,#+16
   \   0000020E   0x4311             ORRS     R1,R1,R2
   \   00000210   0x78A2             LDRB     R2,[R4, #+2]
   \   00000212   0x78E3             LDRB     R3,[R4, #+3]
   \   00000214   0x061B             LSLS     R3,R3,#+24
   \   00000216   0x0C1B             LSRS     R3,R3,#+16
   \   00000218   0x431A             ORRS     R2,R2,R3
   \   0000021A   0x4291             CMP      R1,R2
   \   0000021C   0xD218             BCS      ??zclReportTimerFired_18
   \   0000021E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000220   0x78E1             LDRB     R1,[R4, #+3]
   \   00000222   0x0609             LSLS     R1,R1,#+24
   \   00000224   0x0C09             LSRS     R1,R1,#+16
   \   00000226   0x4308             ORRS     R0,R0,R1
   \   00000228   0x7821             LDRB     R1,[R4, #+0]
   \   0000022A   0x7862             LDRB     R2,[R4, #+1]
   \   0000022C   0x0612             LSLS     R2,R2,#+24
   \   0000022E   0x0C12             LSRS     R2,R2,#+16
   \   00000230   0x4311             ORRS     R1,R1,R2
   \   00000232   0x1A40             SUBS     R0,R0,R1
   \   00000234   0x4287             CMP      R7,R0
   \   00000236   0xD39D             BCC      ??zclReportTimerFired_12
   \   00000238   0x78A0             LDRB     R0,[R4, #+2]
   \   0000023A   0x78E1             LDRB     R1,[R4, #+3]
   \                     ??zclReportTimerFired_19: (+1)
   \   0000023C   0x0609             LSLS     R1,R1,#+24
   \   0000023E   0x0C09             LSRS     R1,R1,#+16
   \   00000240   0x4308             ORRS     R0,R0,R1
   \   00000242   0x7821             LDRB     R1,[R4, #+0]
   \   00000244   0x7862             LDRB     R2,[R4, #+1]
   \   00000246   0x0612             LSLS     R2,R2,#+24
   \   00000248   0x0C12             LSRS     R2,R2,#+16
   \   0000024A   0x4311             ORRS     R1,R1,R2
   \   0000024C   0x1A47             SUBS     R7,R0,R1
   \                     ??zclReportTimerFired_20: (+1)
   \   0000024E   0xE791             B        ??zclReportTimerFired_12
   \                     ??zclReportTimerFired_18: (+1)
   \   00000250   0x21F7             MOVS     R1,#+247
   \   00000252   0x4001             ANDS     R1,R1,R0
   \   00000254   0x70E9             STRB     R1,[R5, #+3]
   \   00000256   0x7920             LDRB     R0,[R4, #+4]
   \   00000258   0x7961             LDRB     R1,[R4, #+5]
   \   0000025A   0x0609             LSLS     R1,R1,#+24
   \   0000025C   0x0C09             LSRS     R1,R1,#+16
   \   0000025E   0x4308             ORRS     R0,R0,R1
   \   00000260   0xD100             BNE      .+4
   \   00000262   0xE6F2             B        ??zclReportTimerFired_5
   \   00000264   0x7920             LDRB     R0,[R4, #+4]
   \   00000266   0x7961             LDRB     R1,[R4, #+5]
   \                     ??zclReportTimerFired_21: (+1)
   \   00000268   0xE6E5             B        ??zclReportTimerFired_4
   \                     ??zclReportTimerFired_17: (+1)
   \   0000026A   0x7920             LDRB     R0,[R4, #+4]
   \   0000026C   0x7961             LDRB     R1,[R4, #+5]
   \   0000026E   0x0609             LSLS     R1,R1,#+24
   \   00000270   0x0C09             LSRS     R1,R1,#+16
   \   00000272   0x4308             ORRS     R0,R0,R1
   \   00000274   0xD0EB             BEQ      ??zclReportTimerFired_20
   \   00000276   0x7820             LDRB     R0,[R4, #+0]
   \   00000278   0x7861             LDRB     R1,[R4, #+1]
   \   0000027A   0x0609             LSLS     R1,R1,#+24
   \   0000027C   0x0C09             LSRS     R1,R1,#+16
   \   0000027E   0x4308             ORRS     R0,R0,R1
   \   00000280   0x7921             LDRB     R1,[R4, #+4]
   \   00000282   0x7962             LDRB     R2,[R4, #+5]
   \   00000284   0x0612             LSLS     R2,R2,#+24
   \   00000286   0x0C12             LSRS     R2,R2,#+16
   \   00000288   0x4311             ORRS     R1,R1,R2
   \   0000028A   0x4288             CMP      R0,R1
   \   0000028C   0x7920             LDRB     R0,[R4, #+4]
   \   0000028E   0x7961             LDRB     R1,[R4, #+5]
   \   00000290   0xD2EA             BCS      ??zclReportTimerFired_21
   \   00000292   0x0609             LSLS     R1,R1,#+24
   \   00000294   0x0C09             LSRS     R1,R1,#+16
   \   00000296   0x4308             ORRS     R0,R0,R1
   \   00000298   0x7821             LDRB     R1,[R4, #+0]
   \   0000029A   0x7862             LDRB     R2,[R4, #+1]
   \   0000029C   0x0612             LSLS     R2,R2,#+24
   \   0000029E   0x0C12             LSRS     R2,R2,#+16
   \   000002A0   0x4311             ORRS     R1,R1,R2
   \   000002A2   0x1A40             SUBS     R0,R0,R1
   \   000002A4   0x4287             CMP      R7,R0
   \   000002A6   0xD3D2             BCC      ??zclReportTimerFired_20
   \   000002A8   0x7920             LDRB     R0,[R4, #+4]
   \   000002AA   0x7961             LDRB     R1,[R4, #+5]
   \   000002AC   0xE7C6             B.N      ??zclReportTimerFired_19
   1208              }
   1209            }
   1210            if (~0ul != minTimeout)
   \                     ??zclReportTimerFired_1: (+1)
   \   000002AE   0x2000             MOVS     R0,#+0
   \   000002B0   0x43C0             MVNS     R0,R0            ;; #-1
   \   000002B2   0x4287             CMP      R7,R0
   \   000002B4   0xD00C             BEQ      ??zclReportTimerFired_22
   1211            {
   1212              SYS_InitTimer(&zclModuleMem.reportTimer, TIMER_ONE_SHOT_MODE, minTimeout * 1000, zclReportTimerFired);
   \   000002B6   0x....             LDR      R3,??DataTable16_1
   \   000002B8   0x20FA             MOVS     R0,#+250
   \   000002BA   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \   000002BC   0x4347             MULS     R7,R0,R7
   \   000002BE   0x003A             MOVS     R2,R7
   \   000002C0   0x2101             MOVS     R1,#+1
   \   000002C2   0x....             LDR      R0,??DataTable17
   \   000002C4   0x.... 0x....      BL       SYS_InitTimer
   1213              SYS_StartTimer(&zclModuleMem.reportTimer);
   \   000002C8   0x....             LDR      R0,??DataTable17
   \   000002CA   0x.... 0x....      BL       SYS_StartTimer
   \   000002CE   0xE002             B        ??zclReportTimerFired_23
   1214            }
   1215            else
   1216              SYS_StopTimer(&zclModuleMem.reportTimer);
   \                     ??zclReportTimerFired_22: (+1)
   \   000002D0   0x....             LDR      R0,??DataTable17
   \   000002D2   0x.... 0x....      BL       SYS_StopTimer
   1217          }
   \                     ??zclReportTimerFired_23: (+1)
   \   000002D6   0xB009             ADD      SP,SP,#+36
   \   000002D8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1218          
   1219          /**************************************************************************//**
   1220          \brief Add attribute to payload when generating periodic report
   1221          
   1222          \param[in, out] reportPayload - report payload buffer
   1223          \param[in] attr - attribute
   1224          \return length of added data
   1225          ******************************************************************************/
   1226          static uint8_t addToReportPayload(uint8_t *reportPayload, ZclAttribute_t *attr)
   1227          {
   1228            uint8_t len = SLICE_SIZE(ZclAttribute_t, id, type);
   1229            uint8_t valLen = ZCL_GetAttributeLength(attr->type, attr->value);
   1230            // Copy id and type
   1231            SYS_BYTE_MEMCPY(reportPayload, attr, len);
   1232            // Copy value
   1233            SYS_BYTE_MEMCPY(reportPayload + len, attr->value, valLen);
   1234            return len + valLen;
   1235          }
   1236          
   1237          /**************************************************************************//**
   1238            \brief Interface to pass ZCL request to APS
   1239          
   1240            APS_DataConf field in APS_DataReq must be an actual confirm handler pointer.
   1241          
   1242            \param[in] req The APS_DataReq_t primitive pointer.
   1243            \param[in] apsSecurity If true APS security is switched on.
   1244          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1245          void zclApsDataReq(APS_DataReq_t *req, bool apsSecurity)
   1246          {
   \                     zclApsDataReq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1247            req->txOptions.useNwkKey = 0;
   1248          
   1249          #ifdef _APS_FRAGMENTATION_
   1250            req->txOptions.fragmentationPermitted = 1;
   1251          #else
   1252            req->txOptions.fragmentationPermitted = 0;
   1253          #endif
   1254          #if (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
   1255            req->txOptions.securityEnabledTransmission = apsSecurity;
   \   00000002   0x2258             MOVS     R2,#+88
   \   00000004   0x5C82             LDRB     R2,[R0, R2]
   \   00000006   0x23FC             MOVS     R3,#+252
   \   00000008   0x4013             ANDS     R3,R3,R2
   \   0000000A   0x4319             ORRS     R1,R1,R3
   \   0000000C   0x2208             MOVS     R2,#+8
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x2158             MOVS     R1,#+88
   \   00000012   0x5442             STRB     R2,[R0, R1]
   1256          #else
   1257            req->txOptions.securityEnabledTransmission = 0;
   1258          #endif // (defined _LINK_SECURITY_) && (!defined _LIGHT_LINK_PROFILE_)
   1259            (void)apsSecurity;
   1260          
   1261          #if defined(ATMEL_APPLICATION_SUPPORT)
   1262            IN_AfDataRequest_DataRequest(req);
   1263          #else
   1264            APS_DataReq(req);
   \   00000014   0x.... 0x....      BL       APS_DataReq
   1265          #endif
   1266          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
   1267          
   1268          /***************************************************************************//**
   1269          \brief Checks whether ZCL is busy or not.
   1270          
   1271          \return true - if ZCL is busy, false - otherwise.
   1272          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1273          bool ZCL_IsBusy(void)
   1274          {
   \                     ZCL_IsBusy: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1275          #if APP_USE_OTAU == 1
   1276            #ifdef _SLEEP_WHEN_IDLE_
   1277              if (SYS_IsSleepWhenIdleEnabled())
   1278                return false;
   1279              else
   1280            #endif
   1281                return zclIsOtauBusy() || (NULL != zclMmGetNextOutputMemDescriptor(NULL));
   1282          #else
   1283            #ifdef _SLEEP_WHEN_IDLE_
   1284              if (SYS_IsSleepWhenIdleEnabled())
   \   00000002   0x.... 0x....      BL       SYS_IsSleepWhenIdleEnabled
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ      ??ZCL_IsBusy_0
   1285                return false;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}
   1286              else
   1287            #endif
   1288                return (NULL != zclMmGetNextOutputMemDescriptor(NULL));
   \                     ??ZCL_IsBusy_0: (+1)
   \   0000000E   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ      ??ZCL_IsBusy_1
   \   00000016   0x2001             MOVS     R0,#+1
   \                     ??ZCL_IsBusy_1: (+1)
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
   1289          #endif // APP_USE_OTAU == 1
   1290          }
   1291          
   1292          #if APP_USE_OTAU == 1
   1293          /***************************************************************************//**
   1294          \brief Checks whether ZCL OTAU is busy or not.
   1295          
   1296          \return true - if ZCL OTAU is busy, false - otherwise.
   1297          ******************************************************************************/
   1298          bool ZCL_IsOtauBusy(void)
   1299          {
   1300            return zclIsOtauBusy();
   1301          }
   1302          #endif // APP_USE_OTAU == 1
   1303          
   1304          /**************************************************************************//**
   1305          \brief Callback for ZCL repost task timer
   1306          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1307          static void zclRepostTaskTimerFired(void)
   1308          {
   \                     zclRepostTaskTimerFired: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1309            SYS_StopTimer(&zclModuleMem.repostTaskTimer);
   \   00000002   0x....             LDR      R0,??DataTable17_1
   \   00000004   0x.... 0x....      BL       SYS_StopTimer
   1310            zclPostTask(ZCL_SUBTASK_ID);
   \   00000008                      REQUIRE ?Subroutine1
   \   00000008                      ;; // Fall through to label ?Subroutine1
   1311          }
   1312          
   1313          /**************************************************************************//**
   1314            \brief Verifies order of received confirmation and response
   1315          
   1316            \param[in] conf - pointer to confirmation structure from APS layer
   1317          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1318          static void zclVerifyConfirmResponseOrder(APS_DataConf_t *conf)
   1319          {
   \                     zclVerifyConfirmResponseOrder: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1320            ZCL_Request_t *req;
   1321            ZclMmBufferDescriptor_t *descr = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   1322          
   1323            while ((descr = zclMmGetNextOutputMemDescriptor(descr)))
   1324            {
   1325              if (&descr->buf.primitive.apsDataReq.confirm == conf)
   1326              {
   1327                req = descr->link;
   1328                if (ZCL_REQ_RESP_RQRD != (req->service.statusflags & ZCL_REQ_RESP_RQRD_MASK))
   1329                { // delete data which have not been needed in responses anymore
   1330                  // free memory located by sent request
   1331                  zclMmFreeMem(&descr->buf);
   1332                  if (NULL == zclMmGetNextOutputMemDescriptor(NULL))
   1333                    zclStopResponseWaitTimer();
   1334                  return;
   1335                }
   1336          
   1337                if (ZCL_REQ_FLAG_RESP_RCVD == (req->service.statusflags & ZCL_REQ_RESP_CONF_MASK))
   1338                {
   1339                  req->service.statusflags |= ZCL_REQ_FLAG_CONF_RCVD;
   1340                  zclPostTask(ZCL_PARSER_TASK_ID);
   1341                  return;
   1342                }
   1343          
   1344                req->service.statusflags |= ZCL_REQ_FLAG_CONF_RCVD;
   \                     ??zclVerifyConfirmResponseOrder_0: (+1)
   \   00000006   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01D             BEQ      ??zclVerifyConfirmResponseOrder_1
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x3170             ADDS     R1,R1,#+112
   \   00000012   0x42A1             CMP      R1,R4
   \   00000014   0xD1F7             BNE      ??zclVerifyConfirmResponseOrder_0
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0x794B             LDRB     R3,[R1, #+5]
   \   0000001A   0x075A             LSLS     R2,R3,#+29
   \   0000001C   0xD40B             BMI      ??zclVerifyConfirmResponseOrder_2
   \   0000001E   0x3010             ADDS     R0,R0,#+16
   \   00000020   0x.... 0x....      BL       zclMmFreeMem
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10D             BNE      ??zclVerifyConfirmResponseOrder_1
   \   0000002E   0x....             LDR      R0,??DataTable17_2
   \   00000030   0x.... 0x....      BL       SYS_StopTimer
   \   00000034   0xBD10             POP      {R4,PC}
   \                     ??zclVerifyConfirmResponseOrder_2: (+1)
   \   00000036   0x2202             MOVS     R2,#+2
   \   00000038   0x431A             ORRS     R2,R2,R3
   \   0000003A   0x079B             LSLS     R3,R3,#+30
   \   0000003C   0x0F9B             LSRS     R3,R3,#+30
   \   0000003E   0x2B01             CMP      R3,#+1
   \   00000040   0x714A             STRB     R2,[R1, #+5]
   \   00000042   0xD1E0             BNE      ??zclVerifyConfirmResponseOrder_0
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      BL       zclPostTask
   1345              }
   1346            }
   1347          }
   \                     ??zclVerifyConfirmResponseOrder_1: (+1)
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
   1348          
   1349          #ifndef ZAPPSI_HOST
   1350          /**************************************************************************//**
   1351            \brief Processes BC_EVENT_BUSY_REQUEST request
   1352          
   1353            \param[in] eventId - id of raised event;
   1354            \param[in] data    - event's data
   1355           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1356          static void isZclBusyOrPollRequest(SYS_EventId_t eventId, SYS_EventData_t data)
   1357          {
   \                     isZclBusyOrPollRequest: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1358            bool *check = (bool *)data;
   \   00000002   0x000C             MOVS     R4,R1
   1359          
   1360            if (BC_EVENT_BUSY_REQUEST == eventId)
   \   00000004   0x2825             CMP      R0,#+37
   \   00000006   0xD107             BNE      ??isZclBusyOrPollRequest_0
   1361              *check &= !ZCL_IsBusy();
   \   00000008   0x.... 0x....      BL       ZCL_IsBusy
   \   0000000C   0x7821             LDRB     R1,[R4, #+0]
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4042             EORS     R2,R2,R0
   \   00000012   0x400A             ANDS     R2,R2,R1
   \   00000014   0x7022             STRB     R2,[R4, #+0]
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}
   1362          #if defined _ENDDEVICE_ && defined _SLEEP_WHEN_IDLE_
   1363            else if (BC_EVENT_POLL_REQUEST == eventId)
   \                     ??isZclBusyOrPollRequest_0: (+1)
   \   00000018   0x2838             CMP      R0,#+56
   \   0000001A   0xD117             BNE      ??isZclBusyOrPollRequest_1
   1364              *check |= zclIsPollRequired();
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??isZclBusyOrPollRequest_2: (+1)
   \   00000020   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00E             BEQ      ??isZclBusyOrPollRequest_3
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0x1D4A             ADDS     R2,R1,#+5
   \   0000002C   0x7813             LDRB     R3,[R2, #+0]
   \   0000002E   0x075B             LSLS     R3,R3,#+29
   \   00000030   0xD408             BMI      ??isZclBusyOrPollRequest_4
   \   00000032   0x314B             ADDS     R1,R1,#+75
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD1F2             BNE      ??isZclBusyOrPollRequest_2
   \   0000003A   0x7ED1             LDRB     R1,[R2, #+27]
   \   0000003C   0x2902             CMP      R1,#+2
   \   0000003E   0xD001             BEQ      ??isZclBusyOrPollRequest_4
   \   00000040   0x2901             CMP      R1,#+1
   \   00000042   0xD0ED             BEQ      ??isZclBusyOrPollRequest_2
   \                     ??isZclBusyOrPollRequest_4: (+1)
   \   00000044   0x2501             MOVS     R5,#+1
   \                     ??isZclBusyOrPollRequest_3: (+1)
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0x4305             ORRS     R5,R5,R0
   \   0000004A   0x7025             STRB     R5,[R4, #+0]
   1365          #endif
   1366          }
   \                     ??isZclBusyOrPollRequest_1: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1367          
   1368          /**************************************************************************//**
   1369            \brief Checks if polling is required
   1370          
   1371            \return 'true' if it is otherwise - 'false'
   1372           ******************************************************************************/
   1373          #if defined _ENDDEVICE_ && defined _SLEEP_WHEN_IDLE_
   1374          static bool zclIsPollRequired(void)
   1375          {
   1376            ZclMmBufferDescriptor_t *descr = NULL;
   1377            ZCL_Request_t           *req;
   1378          
   1379          #if APP_USE_OTAU == 1
   1380            if (zclIsOtauBusy())
   1381              return true;
   1382          #endif
   1383          
   1384            while ((descr = zclMmGetNextOutputMemDescriptor(descr)))
   1385            {
   1386              req = descr->link;
   1387              if (ZCL_REQ_RESP_RQRD == (req->service.statusflags & ZCL_REQ_RESP_RQRD_MASK))
   1388                return true;
   1389              else if (ZCL_FRAME_CONTROL_ENABLE_DEFAULT_RESPONSE == req->defaultResponse)
   1390              {
   1391                if ((APS_SHORT_ADDRESS == req->dstAddressing.addrMode &&
   1392                    !IS_BROADCAST_ADDR(req->dstAddressing.addr.shortAddress))
   1393          #ifdef _APS_MULTICAST_
   1394                    || !(APS_GROUP_ADDRESS == req->dstAddressing.addrMode)
   1395          #endif
   1396                )
   1397                  return true;
   1398              }
   1399            }
   1400          
   1401            return false;
   1402          }
   1403          
   1404          #endif // defined _ENDDEVICE_ && defined _SLEEP_WHEN_IDLE_
   1405          #endif // ZAPPSI_HOST
   1406          
   1407          /*************************************************************************//**
   1408            \brief Adjusts ZCL response wait timer's interval. Sets interval to the shortest
   1409              timeout among all timeouts.
   1410          
   1411            \param[in] timeout - new timeout, ms.
   1412           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1413          static void zclStartWaitResponseTimer(ZclMmBufferDescriptor_t *descriptor)
   1414          {
   \                     zclStartWaitResponseTimer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x2600             MOVS     R6,#+0
   1415            ZclMmBufferDescriptor_t *descr = NULL;
   1416            uint32_t minTimeout = ~0ul;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x43ED             MVNS     R5,R5            ;; #-1
   1417            uint32_t curTime    = halGetTimeOfAppTimer();
   \   0000000A   0x.... 0x....      BL       halGetTimeOfAppTimer
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   1418          
   1419            // the only active transaction
   1420            if (SYS_TIMER_STOPPED == zclModuleMem.waitTimer.state)
   \   00000010   0x....             LDR      R4,??DataTable17_3
   \   00000012   0x....             LDR      R0,??DataTable17_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD108             BNE      ??zclStartWaitResponseTimer_0
   1421            {
   1422              SYS_InitTimer(&zclModuleMem.waitTimer, TIMER_ONE_SHOT_MODE, descriptor->timeout, zclWaitTimerFired);
   \   0000001A   0x0023             MOVS     R3,R4
   \   0000001C   0x683A             LDR      R2,[R7, #+0]
   \   0000001E   0xE023             B        ??zclStartWaitResponseTimer_1
   1423              SYS_StartTimer(&zclModuleMem.waitTimer);
   1424              return;
   1425            }
   1426          
   1427            // look for the shortest timeout
   1428            while (NULL != (descr = zclMmGetNextOutputMemDescriptor(descr)))
   1429            {
   1430              ZCL_Request_t *req = descr->link;
   1431          
   1432              if(req->service.statusflags & ZCL_REQ_FLAG_CONF_RCVD)
   1433                // skip the request which caused timer restart
   1434                if (descr->timeout && (descr != descriptor))
   1435                {
   1436                  if (descr->timeout > (curTime - zclModuleMem.waitTimer.timer.service.sysTimeLabel))
   1437                    descr->timeout -= (curTime - zclModuleMem.waitTimer.timer.service.sysTimeLabel);
   1438                  else
   1439                    descr->timeout = 0;
   \                     ??zclStartWaitResponseTimer_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??zclStartWaitResponseTimer_3: (+1)
   \   00000022   0x6030             STR      R0,[R6, #+0]
   1440                  minTimeout = MIN(minTimeout, descr->timeout);
   \   00000024   0x6830             LDR      R0,[R6, #+0]
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD300             BCC      ??zclStartWaitResponseTimer_0
   \   0000002A   0x0005             MOVS     R5,R0
   \                     ??zclStartWaitResponseTimer_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       zclMmGetNextOutputMemDescriptor
   \   00000032   0x0006             MOVS     R6,R0
   \   00000034   0xD012             BEQ      ??zclStartWaitResponseTimer_4
   \   00000036   0x68B0             LDR      R0,[R6, #+8]
   \   00000038   0x7940             LDRB     R0,[R0, #+5]
   \   0000003A   0x0780             LSLS     R0,R0,#+30
   \   0000003C   0xD5F6             BPL      ??zclStartWaitResponseTimer_0
   \   0000003E   0x6830             LDR      R0,[R6, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD0F3             BEQ      ??zclStartWaitResponseTimer_0
   \   00000044   0x42BE             CMP      R6,R7
   \   00000046   0xD0F1             BEQ      ??zclStartWaitResponseTimer_0
   \   00000048   0x....             LDR      R1,??DataTable17_2
   \   0000004A   0x6889             LDR      R1,[R1, #+8]
   \   0000004C   0x9A00             LDR      R2,[SP, #+0]
   \   0000004E   0x1A52             SUBS     R2,R2,R1
   \   00000050   0x4282             CMP      R2,R0
   \   00000052   0xD2E5             BCS      ??zclStartWaitResponseTimer_2
   \   00000054   0x9A00             LDR      R2,[SP, #+0]
   \   00000056   0x1A80             SUBS     R0,R0,R2
   \   00000058   0x1840             ADDS     R0,R0,R1
   \   0000005A   0xE7E2             B        ??zclStartWaitResponseTimer_3
   1441                }
   1442            }
   1443            minTimeout = MIN(minTimeout, descriptor->timeout);
   \                     ??zclStartWaitResponseTimer_4: (+1)
   \   0000005C   0x6838             LDR      R0,[R7, #+0]
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD300             BCC      ??zclStartWaitResponseTimer_5
   \   00000062   0x0005             MOVS     R5,R0
   1444          
   1445            SYS_InitTimer(&zclModuleMem.waitTimer, TIMER_ONE_SHOT_MODE, minTimeout, zclWaitTimerFired);
   \                     ??zclStartWaitResponseTimer_5: (+1)
   \   00000064   0x0023             MOVS     R3,R4
   \   00000066   0x002A             MOVS     R2,R5
   \                     ??zclStartWaitResponseTimer_1: (+1)
   \   00000068                      REQUIRE ?Subroutine2
   \   00000068                      ;; // Fall through to label ?Subroutine2
   1446            SYS_StartTimer(&zclModuleMem.waitTimer);
   1447          }
   1448          
   1449          /*************************************************************************//**
   1450            \brief starts the report timer on recieving configure report cmd or
   1451              reportOnChange triggered due to change in attribute value
   1452           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1453          void zclStartReportTimer(void)
   1454          {
   \                     zclStartReportTimer: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9003             STR      R0,[SP, #+12]
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x43ED             MVNS     R5,R5            ;; #-1
   1455            ZCL_DeviceEndpoint_t *endpoint = NULL;
   1456            uint32_t  minTimeout = ~0ul;
   1457            uint32_t curTime     = halGetTimeOfAppTimer();
   \   0000000C   0x.... 0x....      BL       halGetTimeOfAppTimer
   \   00000010   0x9004             STR      R0,[SP, #+16]
   1458          
   1459            // look for the closest reporting time
   1460            // For all endpoints
   1461            while (NULL != (endpoint = zclNextEndpoint(endpoint)))
   \                     ??zclStartReportTimer_0: (+1)
   \   00000012   0x9803             LDR      R0,[SP, #+12]
   \   00000014   0x.... 0x....      BL       zclNextEndpoint
   \   00000018   0x9003             STR      R0,[SP, #+12]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD100             BNE      .+4
   \   0000001E   0xE097             B        ??zclStartReportTimer_1
   1462            {
   1463              ZCL_Cluster_t *cluster = ZCL_GetHeadCluster(endpoint, ZCL_CLUSTER_SIDE_SERVER);
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x.... 0x....      BL       ZCL_GetHeadCluster
   \   00000026   0x9002             STR      R0,[SP, #+8]
   1464          
   1465              // For all server side clusters
   1466              for (uint8_t clusterIndex = 0; clusterIndex < endpoint->simpleDescriptor.AppInClustersCount; clusterIndex++)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE006             B        ??zclStartReportTimer_2
   1467              {
   1468                ZclAttribute_t *attr = (ZclAttribute_t *)cluster->attributes;
   1469                uint8_t attrLength;
   1470                uint8_t *reportCounterPtr;
   1471                ZclReportableAttributeTail_t *tail;
   1472                // For all attributes
   1473                for (uint8_t attrIndex = 0; attrIndex < cluster->attributesAmount; attrIndex++)
   1474                {
   1475                  if ((attr->properties & ZCL_REPORTABLE_ATTRIBUTE) && isReportingPermitted(attr))
   1476                  {
   1477                    attrLength = ZCL_GetAttributeLength(attr->type, (uint8_t *)&attr->value);
   1478                    reportCounterPtr = (uint8_t *)attr + ATTRIBUTE_ID_SIZE + ATTRIBUTE_TYPE_SIZE +
   1479                                                sizeof(uint8_t) + attrLength; // properties + value
   1480                    tail = (ZclReportableAttributeTail_t *)reportCounterPtr;
   1481          
   1482                    if (0xFFFFu != tail->minReportInterval)
   1483                    {
   1484                      tail->reportCounter += (curTime - zclModuleMem.reportTimer.timer.service.sysTimeLabel) / 1000;
   1485                      if (attr->properties & ZCL_ON_CHANGE_REPORT)
   1486                        minTimeout = ((tail->reportCounter >= tail->minReportInterval) ? 0 : MIN(minTimeout,  (uint32_t)(tail->minReportInterval - tail->reportCounter)));
   1487                      else if (tail->maxReportInterval)
   1488                        minTimeout = ((tail->reportCounter >= tail->maxReportInterval) ? 0 : MIN(minTimeout,  (uint32_t)(tail->maxReportInterval - tail->reportCounter)));
   1489                    }
   1490                  }
   1491                  attr = jumpToNextAttribute(attr);
   1492                }
   1493                cluster = ZCL_GetNextCluster(cluster);
   \                     ??zclStartReportTimer_3: (+1)
   \   0000002C   0x9802             LDR      R0,[SP, #+8]
   \   0000002E   0x.... 0x....      BL       ZCL_GetNextCluster
   \   00000032   0x9002             STR      R0,[SP, #+8]
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x7900             LDRB     R0,[R0, #+4]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \                     ??zclStartReportTimer_2: (+1)
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7108             STRB     R0,[R1, #+4]
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x7900             LDRB     R0,[R0, #+4]
   \   00000042   0x9903             LDR      R1,[SP, #+12]
   \   00000044   0x7E89             LDRB     R1,[R1, #+26]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD2E3             BCS      ??zclStartReportTimer_0
   \   0000004A   0x9802             LDR      R0,[SP, #+8]
   \   0000004C   0x6844             LDR      R4,[R0, #+4]
   \   0000004E   0x2600             MOVS     R6,#+0
   \   00000050   0xE01C             B        ??zclStartReportTimer_4
   \                     ??zclStartReportTimer_5: (+1)
   \   00000052   0x7938             LDRB     R0,[R7, #+4]
   \   00000054   0x7979             LDRB     R1,[R7, #+5]
   \   00000056   0x0609             LSLS     R1,R1,#+24
   \   00000058   0x0C09             LSRS     R1,R1,#+16
   \   0000005A   0x4308             ORRS     R0,R0,R1
   \   0000005C   0x7839             LDRB     R1,[R7, #+0]
   \   0000005E   0x787A             LDRB     R2,[R7, #+1]
   \   00000060   0x0612             LSLS     R2,R2,#+24
   \   00000062   0x0C12             LSRS     R2,R2,#+16
   \   00000064   0x4311             ORRS     R1,R1,R2
   \   00000066   0x1A40             SUBS     R0,R0,R1
   \   00000068   0x4285             CMP      R5,R0
   \   0000006A   0xD30A             BCC      ??zclStartReportTimer_6
   \   0000006C   0x7938             LDRB     R0,[R7, #+4]
   \   0000006E   0x7979             LDRB     R1,[R7, #+5]
   \                     ??zclStartReportTimer_7: (+1)
   \   00000070   0x0609             LSLS     R1,R1,#+24
   \   00000072   0x0C09             LSRS     R1,R1,#+16
   \   00000074   0x4308             ORRS     R0,R0,R1
   \   00000076   0x7839             LDRB     R1,[R7, #+0]
   \   00000078   0x787A             LDRB     R2,[R7, #+1]
   \   0000007A   0x0612             LSLS     R2,R2,#+24
   \   0000007C   0x0C12             LSRS     R2,R2,#+16
   \   0000007E   0x4311             ORRS     R1,R1,R2
   \   00000080   0x1A45             SUBS     R5,R0,R1
   \                     ??zclStartReportTimer_6: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       jumpToNextAttribute
   \   00000088   0x0004             MOVS     R4,R0
   \   0000008A   0x1C76             ADDS     R6,R6,#+1
   \                     ??zclStartReportTimer_4: (+1)
   \   0000008C   0x9802             LDR      R0,[SP, #+8]
   \   0000008E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000090   0xB2F6             UXTB     R6,R6
   \   00000092   0x4286             CMP      R6,R0
   \   00000094   0xD2CA             BCS      ??zclStartReportTimer_3
   \   00000096   0x78E0             LDRB     R0,[R4, #+3]
   \   00000098   0x07C0             LSLS     R0,R0,#+31
   \   0000009A   0xD5F2             BPL      ??zclStartReportTimer_6
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       isReportingPermitted
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD0ED             BEQ      ??zclStartReportTimer_6
   \   000000A6   0x1D21             ADDS     R1,R4,#+4
   \   000000A8   0x78A0             LDRB     R0,[R4, #+2]
   \   000000AA   0x.... 0x....      BL       ZCL_GetAttributeLength
   \   000000AE   0xB2C0             UXTB     R0,R0
   \   000000B0   0x1827             ADDS     R7,R4,R0
   \   000000B2   0x1D3F             ADDS     R7,R7,#+4
   \   000000B4   0x78B8             LDRB     R0,[R7, #+2]
   \   000000B6   0x78F9             LDRB     R1,[R7, #+3]
   \   000000B8   0x0609             LSLS     R1,R1,#+24
   \   000000BA   0x0C09             LSRS     R1,R1,#+16
   \   000000BC   0x4308             ORRS     R0,R0,R1
   \   000000BE   0x....             LDR      R1,??DataTable17_4  ;; 0xffff
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD0DE             BEQ      ??zclStartReportTimer_6
   \   000000C4   0x7839             LDRB     R1,[R7, #+0]
   \   000000C6   0x7878             LDRB     R0,[R7, #+1]
   \   000000C8   0x0600             LSLS     R0,R0,#+24
   \   000000CA   0x0C00             LSRS     R0,R0,#+16
   \   000000CC   0x4301             ORRS     R1,R1,R0
   \   000000CE   0x9100             STR      R1,[SP, #+0]
   \   000000D0   0x9804             LDR      R0,[SP, #+16]
   \   000000D2   0x....             LDR      R1,??DataTable17_2
   \   000000D4   0x6A09             LDR      R1,[R1, #+32]
   \   000000D6   0x1A40             SUBS     R0,R0,R1
   \   000000D8   0x21FA             MOVS     R1,#+250
   \   000000DA   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   000000DC   0x.... 0x....      BL       __aeabi_uidiv
   \   000000E0   0x9900             LDR      R1,[SP, #+0]
   \   000000E2   0x1808             ADDS     R0,R1,R0
   \   000000E4   0x7038             STRB     R0,[R7, #+0]
   \   000000E6   0x0A00             LSRS     R0,R0,#+8
   \   000000E8   0x7078             STRB     R0,[R7, #+1]
   \   000000EA   0x78E0             LDRB     R0,[R4, #+3]
   \   000000EC   0x0700             LSLS     R0,R0,#+28
   \   000000EE   0xD51B             BPL      ??zclStartReportTimer_8
   \   000000F0   0x7838             LDRB     R0,[R7, #+0]
   \   000000F2   0x7879             LDRB     R1,[R7, #+1]
   \   000000F4   0x0609             LSLS     R1,R1,#+24
   \   000000F6   0x0C09             LSRS     R1,R1,#+16
   \   000000F8   0x4308             ORRS     R0,R0,R1
   \   000000FA   0x78B9             LDRB     R1,[R7, #+2]
   \   000000FC   0x78FA             LDRB     R2,[R7, #+3]
   \   000000FE   0x0612             LSLS     R2,R2,#+24
   \   00000100   0x0C12             LSRS     R2,R2,#+16
   \   00000102   0x4311             ORRS     R1,R1,R2
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD221             BCS      ??zclStartReportTimer_9
   \   00000108   0x78B8             LDRB     R0,[R7, #+2]
   \   0000010A   0x78F9             LDRB     R1,[R7, #+3]
   \   0000010C   0x0609             LSLS     R1,R1,#+24
   \   0000010E   0x0C09             LSRS     R1,R1,#+16
   \   00000110   0x4308             ORRS     R0,R0,R1
   \   00000112   0x7839             LDRB     R1,[R7, #+0]
   \   00000114   0x787A             LDRB     R2,[R7, #+1]
   \   00000116   0x0612             LSLS     R2,R2,#+24
   \   00000118   0x0C12             LSRS     R2,R2,#+16
   \   0000011A   0x4311             ORRS     R1,R1,R2
   \   0000011C   0x1A40             SUBS     R0,R0,R1
   \   0000011E   0x4285             CMP      R5,R0
   \   00000120   0xD3AF             BCC      ??zclStartReportTimer_6
   \   00000122   0x78B8             LDRB     R0,[R7, #+2]
   \   00000124   0x78F9             LDRB     R1,[R7, #+3]
   \   00000126   0xE7A3             B        ??zclStartReportTimer_7
   \                     ??zclStartReportTimer_8: (+1)
   \   00000128   0x7938             LDRB     R0,[R7, #+4]
   \   0000012A   0x7979             LDRB     R1,[R7, #+5]
   \   0000012C   0x0609             LSLS     R1,R1,#+24
   \   0000012E   0x0C09             LSRS     R1,R1,#+16
   \   00000130   0x4308             ORRS     R0,R0,R1
   \   00000132   0xD0A6             BEQ      ??zclStartReportTimer_6
   \   00000134   0x7838             LDRB     R0,[R7, #+0]
   \   00000136   0x7879             LDRB     R1,[R7, #+1]
   \   00000138   0x0609             LSLS     R1,R1,#+24
   \   0000013A   0x0C09             LSRS     R1,R1,#+16
   \   0000013C   0x4308             ORRS     R0,R0,R1
   \   0000013E   0x7939             LDRB     R1,[R7, #+4]
   \   00000140   0x797A             LDRB     R2,[R7, #+5]
   \   00000142   0x0612             LSLS     R2,R2,#+24
   \   00000144   0x0C12             LSRS     R2,R2,#+16
   \   00000146   0x4311             ORRS     R1,R1,R2
   \   00000148   0x4288             CMP      R0,R1
   \   0000014A   0xD382             BCC      ??zclStartReportTimer_5
   \                     ??zclStartReportTimer_9: (+1)
   \   0000014C   0x2500             MOVS     R5,#+0
   \   0000014E   0xE798             B        ??zclStartReportTimer_6
   1494              }
   1495            }
   1496            
   1497            if (minTimeout != 0xFFFFFFFFul)
   \                     ??zclStartReportTimer_1: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000154   0x4285             CMP      R5,R0
   \   00000156   0xD00B             BEQ      ??zclStartReportTimer_10
   1498            {
   1499            SYS_InitTimer(&zclModuleMem.reportTimer, TIMER_ONE_SHOT_MODE, minTimeout * 1000, zclReportTimerFired);
   \   00000158   0x....             LDR      R3,??DataTable17_5
   \   0000015A   0x20FA             MOVS     R0,#+250
   \   0000015C   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \   0000015E   0x4345             MULS     R5,R0,R5
   \   00000160   0x002A             MOVS     R2,R5
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x....             LDR      R0,??DataTable17
   \   00000166   0x.... 0x....      BL       SYS_InitTimer
   1500            SYS_StartTimer(&zclModuleMem.reportTimer);
   \   0000016A   0x....             LDR      R0,??DataTable17
   \   0000016C   0x.... 0x....      BL       SYS_StartTimer
   1501            }
   1502          }
   \                     ??zclStartReportTimer_10: (+1)
   \   00000170   0xB005             ADD      SP,SP,#+20
   \   00000172   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     zclMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     zclModuleMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     zclRepostTaskTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     zclDataInd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     zclModuleMem+0x48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     zclReportTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x0000C204         DC32     0xc204

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     gAssertDbgCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x0000C05E         DC32     0xc05e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     attributeConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     commandConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x0000FFF8         DC32     0xfff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x0000C302         DC32     0xc302

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     zclModuleMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     zclModuleMem+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     zclModuleMem+0x48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x0000FFF8         DC32     0xfff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     responseConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     configureReportingResponseConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     zclModuleMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     zclWaitTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     reportConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     zclReportTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     zclModuleMem+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     zclModuleMem+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     zclModuleMem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     zclWaitTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     zclReportTimerFired
   1503          
   1504          #endif // ZCL_SUPPORT == 1
   1505          //eof zcl.c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SYS_ByteMemcpy
       8   ZCL_AttributeReq
         8   -> ZCL_GetNextSeqNumber
         8   -> putQueueElem
         8   -> zclPostTask
       8   ZCL_CommandReq
         8   -> putQueueElem
         8   -> zclPostTask
       0   ZCL_GetNextSeqNumber
       8   ZCL_IsBusy
         8   -> SYS_IsSleepWhenIdleEnabled
         8   -> zclMmGetNextOutputMemDescriptor
       8   ZCL_RegisterEndpoint
         8   -> APS_RegisterEndpointReq
       8   ZCL_ResetReq
         8   -> SYS_InitTimer
         8   -> SYS_StopTimer
         8   -> SYS_SubscribeToEvent
         8   -> ZCL_ResetSecurity
         8   -> zclParserInit
      24   ZCL_StartReporting
        24   -> APS_NextBindingEntry
        24   -> SYS_InitTimer
        24   -> SYS_StartTimer
        24   -> ZCL_GetAttributeLength
        24   -> ZCL_GetCluster
        24   -> jumpToNextAttribute
        24   -> zclGetEndpoint
       8   ZCL_UnregisterEndpoint
         8   -> APS_UnregisterEndpointReq
      16   attributeConfirm
        16   -- Indirect call
        16   -> NWK_GetUnicastDeliveryTime
        16   -> SYS_StopTimer
        16   -> zclMmFreeMem
        16   -> zclMmGetNextOutputMemDescriptor
        16   -> zclStartWaitResponseTimer
        16   -> zclVerifyConfirmResponseOrder
      16   commandConfirm
        16   -- Indirect call
        16   -> NWK_GetUnicastDeliveryTime
        16   -> SYS_StopTimer
        16   -> zclMmFreeMem
        16   -> zclMmGetNextOutputMemDescriptor
        16   -> zclStartWaitResponseTimer
        16   -> zclVerifyConfirmResponseOrder
       8   configureReportingResponseConfirm
         8   -> zclMmFreeMem
         8   -> zclStartReportTimer
       0   getDstClusterSideByIncommingCommandDirection
      16   isZclBusyOrPollRequest
        16   -> ZCL_IsBusy
        16   -> zclMmGetNextOutputMemDescriptor
       8   reportConfirm
         8   -> ZCL_GetCluster
         8   -> zclMmFreeMem
       8   responseConfirm
         8   -> zclMmFreeMem
       8   zclApsDataReq
         8   -> APS_DataReq
      72   zclAttributeEventInd
        72   -- Indirect call
        72   -> ZCL_GetCluster
        72   -> __aeabi_memcpy4
        72   -> getDstClusterSideByIncommingCommandDirection
      72   zclCommandInd
        72   -- Indirect call
        72   -> __aeabi_memcpy4
        72   -> getDstClusterSideByIncommingCommandDirection
        72   -> zclGetCommand
        72   -> zclIsResponseRequiredByPayload
      72   zclConfigureReportingHandler
        72   -> SYS_ByteMemcpy
        72   -> ZCL_GetDataTypeDescriptor
        72   -> getDstClusterSideByIncommingCommandDirection
        72   -> zclApsDataReq
        72   -> zclAttributeEventInd
        72   -> zclFormRequest
        72   -> zclGetAttribute
        72   -> zclMmFreeMem
        72   -> zclMmGetMem
      40   zclExecuteRequest
        40   -> SYS_ByteMemcpy
        40   -> SYS_DefAssertCallbackError
        40   -> ZCL_GetCluster
        40   -> __aeabi_memcpy4
        40   -> zclApsDataReq
        40   -> zclFormRequest
        40   -> zclGetCommandByCluster
        40   -> zclIsResponseRequiredByAddrMode
        40   -> zclIsResponseRequiredByPayload
      72   zclReadReportingConfigurationHandler
        72   -> SYS_ByteMemcpy
        72   -> ZCL_GetDataTypeDescriptor
        72   -> zclApsDataReq
        72   -> zclFormRequest
        72   -> zclGetAttribute
        72   -> zclMmFreeMem
        72   -> zclMmGetMem
      64   zclReportInd
        64   -- Indirect call
        64   -> ZCL_GetCluster
        64   -> __aeabi_memcpy4
        64   -> getDstClusterSideByIncommingCommandDirection
      56   zclReportTimerFired
        56   -> SYS_ByteMemcpy
        56   -> SYS_InitTimer
        56   -> SYS_StartTimer
        56   -> SYS_StopTimer
        56   -> ZCL_GetAttributeLength
        56   -> ZCL_GetHeadCluster
        56   -> ZCL_GetNextCluster
        56   -> ZCL_GetNextSeqNumber
        56   -> __aeabi_memcpy
        56   -> isReportingPermitted
        56   -> zclApsDataReq
        56   -> zclFormRequest
        56   -> zclGetCommandByCluster
        56   -> zclMmGetMem
        56   -> zclNextEndpoint
        56 __aeabi_uidiv
       8   zclRepostTaskTimerFired
         8   -> SYS_StopTimer
         8   -> zclPostTask
      64   zclResponseInd
        64   -- Indirect call
        64   -> __aeabi_memcpy4
        64   -> getDstClusterSideByIncommingCommandDirection
      40   zclStartReportTimer
        40   -> SYS_InitTimer
        40   -> SYS_StartTimer
        40   -> ZCL_GetAttributeLength
        40   -> ZCL_GetHeadCluster
        40   -> ZCL_GetNextCluster
        40   -> halGetTimeOfAppTimer
        40   -> isReportingPermitted
        40   -> jumpToNextAttribute
        40   -> zclNextEndpoint
        40 __aeabi_uidiv
      24   zclStartWaitResponseTimer
        24   -> SYS_InitTimer
        24   -> SYS_StartTimer
        24   -> halGetTimeOfAppTimer
        24   -> zclMmGetNextOutputMemDescriptor
       8   zclStopResponseWaitTimer
         8   -> SYS_StopTimer
      24   zclTaskHandler
        24   -- Indirect call
        24   -> SYS_DefAssertCallbackFatal
        24   -> SYS_StartTimer
        24   -> deleteQueueElem
        24   -> zclExecuteRequest
        24   -> zclMmFreeMem
        24   -> zclMmGetMem
       8   zclVerifyConfirmResponseOrder
         8   -> SYS_StopTimer
         8   -> zclMmFreeMem
         8   -> zclMmGetNextOutputMemDescriptor
         8   -> zclPostTask
      24   zclWaitTimerFired
        24   -- Indirect call
        24   -> SYS_InitTimer
        24   -> SYS_StartTimer
        24   -> SYS_StopTimer
        24   -> zclMmFreeMem
        24   -> zclMmGetNextOutputMemDescriptor


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       6  ??Subroutine3_0
       8  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
      24  SYS_ByteMemcpy
      32  ZCL_AttributeReq
      18  ZCL_CommandReq
      10  ZCL_GetNextSeqNumber
      26  ZCL_IsBusy
      18  ZCL_RegisterEndpoint
      74  ZCL_ResetReq
     184  ZCL_StartReporting
      12  ZCL_UnregisterEndpoint
     122  attributeConfirm
     100  commandConfirm
      16  configureReportingResponseConfirm
       8  getDstClusterSideByIncommingCommandDirection
      78  isZclBusyOrPollRequest
      28  reportConfirm
      10  responseConfirm
      26  zclApsDataReq
     112  zclAttributeEventInd
     218  zclCommandInd
     614  zclConfigureReportingHandler
     468  zclExecuteRequest
       8  zclMem
      92  zclModuleMem
          zdoBusyPollCheck
     516  zclReadReportingConfigurationHandler
     118  zclReportInd
     730  zclReportTimerFired
       8  zclRepostTaskTimerFired
     170  zclResponseInd
     372  zclStartReportTimer
     104  zclStartWaitResponseTimer
      10  zclStopResponseWaitTimer
     126  zclTaskHandler
      76  zclVerifyConfirmResponseOrder
      96  zclWaitTimerFired

 
     8 bytes in section .bss
    92 bytes in section .data
 4 676 bytes in section .text
 
 4 676 bytes of CODE memory
   100 bytes of DATA memory

Errors: none
Warnings: none
