###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:40:48
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\SystemEnvironment\src\sysDuplicateTable.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\SystemEnvironment\src\sysDuplicateTable.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\sysDuplicateTable.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\sysDuplicateTable.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\SystemEnvironment\src\sysDuplicateTable.c
      1          /**************************************************************************//**
      2            \file sysDuplicateTable.c
      3          
      4            \brief Implementation of common part of a duplicate rejection table.
      5          
      6            \author
      7              Atmel Corporation: http://www.atmel.com \n
      8              Support email: avr@atmel.com
      9          
     10            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     11            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     12          
     13            \internal
     14             History:
     15              2009-11-209 I.Vagulin - Created
     16              2010-07-15 V.Preobrazhenskiy - Refactored.
     17              2013-02-11 Max Gekk - duplicate bit mask is extended up to 32 bits.
     18             Last change:
     19              $Id: sysDuplicateTable.c 24479 2013-02-11 12:08:31Z mgekk $
     20           ******************************************************************************/
     21          /******************************************************************************
     22                                       Includes section
     23           ******************************************************************************/
     24          #include <sysDuplicateTable.h>
     25          #include <appTimer.h>
     26          #include <sysDbg.h>
     27          #include <sysUtils.h>
     28          #include <sysAssert.h>
     29          
     30          /******************************************************************************
     31                                Local functions prototypes section
     32           ******************************************************************************/
     33          static void sysDuplicateTableUpdate(SYS_DuplicateTable_t *table);
     34          
     35          /******************************************************************************
     36                                    Implementations section
     37           ******************************************************************************/
     38          /**************************************************************************//**
     39            \brief Prepare duplicate table to real work.
     40          
     41            \param[in] table - pointer to allocated table
     42            \param[out] entries - pointer to array of entries
     43            \param[in] tableSize - count of entries in table
     44            \param[in] agingPeriod - aging period ms
     45            \param[in] maxTTL - initial value of TTL.
     46            \param[in] removeOldest - change behaviour on full table
     47          
     48            \return None.
     49           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     50          void SYS_DuplicateTableReset(SYS_DuplicateTable_t *table, SYS_DuplicateTableEntry_t *entries,
     51               uint8_t size, uint16_t agingPeriod, uint8_t maxTTL, bool removeOldest,uint8_t maskSize)
     52          {
   \                     SYS_DuplicateTableReset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     53            SYS_DuplicateTableEntry_t *it;
     54          
     55            table->entries = entries;
   \   00000002   0x6041             STR      R1,[R0, #+4]
     56            /* Only 7 bits are allocated for size. */
     57            if (size >= INT8_MAX)
   \   00000004   0x2A7F             CMP      R2,#+127
   \   00000006   0xDB05             BLT      ??SYS_DuplicateTableReset_0
     58            {
     59              SYS_E_ASSERT_ERROR(false, SYS_ASSERT_ID_DRT_SIZE_TOO_BIG);
   \   00000008   0x....             LDR      R0,??DataTable0  ;; 0x8001
   \   0000000A   0x....             LDR      R1,??DataTable0_1
   \   0000000C   0x8008             STRH     R0,[R1, #+0]
   \   0000000E   0x.... 0x....      BL       SYS_DefAssertCallbackError
     60              return;
   \   00000012   0xBD01             POP      {R0,PC}
     61            }
     62            /* if size >= INT8_MAX, exit from here */
     63          
     64            table->size = MIN(size, INT8_MAX);
   \                     ??SYS_DuplicateTableReset_0: (+1)
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0x0849             LSRS     R1,R1,#+1
   \   00000018   0x4152             ADCS     R2,R2,R2
   \   0000001A   0x7002             STRB     R2,[R0, #+0]
     65            table->maxTTL = maxTTL;
   \   0000001C   0x9902             LDR      R1,[SP, #+8]
   \   0000001E   0x7401             STRB     R1,[R0, #+16]
     66            table->removeOldest = removeOldest;
   \   00000020   0x21FE             MOVS     R1,#+254
   \   00000022   0x4011             ANDS     R1,R1,R2
   \   00000024   0x9A03             LDR      R2,[SP, #+12]
   \   00000026   0x430A             ORRS     R2,R2,R1
   \   00000028   0x7002             STRB     R2,[R0, #+0]
     67            table->agingPeriod = agingPeriod;
   \   0000002A   0x8103             STRH     R3,[R0, #+8]
     68          #ifdef _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
     69            table->maskSize = MIN(maskSize, sizeof(SYS_DuplicateMask_t) * 8U);
     70          #endif // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
     71            (void)maskSize;
     72          
     73            for(it = table->entries; it < table->entries + table->size; it++)
   \   0000002C   0x6841             LDR      R1,[R0, #+4]
   \   0000002E   0xE002             B        ??SYS_DuplicateTableReset_1
     74              it->ttl = 0;
   \                     ??SYS_DuplicateTableReset_2: (+1)
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x70CA             STRB     R2,[R1, #+3]
   \   00000034   0x1D09             ADDS     R1,R1,#+4
   \                     ??SYS_DuplicateTableReset_1: (+1)
   \   00000036   0x6842             LDR      R2,[R0, #+4]
   \   00000038   0x7803             LDRB     R3,[R0, #+0]
   \   0000003A   0x085B             LSRS     R3,R3,#+1
   \   0000003C   0x009B             LSLS     R3,R3,#+2
   \   0000003E   0x18D2             ADDS     R2,R2,R3
   \   00000040   0x4291             CMP      R1,R2
   \   00000042   0xD3F5             BCC      ??SYS_DuplicateTableReset_2
     75          }
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
     76          
     77          /**************************************************************************//**
     78            \brief Check for record existence in table, returns status
     79          
     80            \param[in] table - pointer to allocated table
     81            \param[in] address, seqNumber - record to search for or to add if not found
     82          
     83            \return true  - Record exists
     84                    false - Record doesnt exist
     85           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     86          bool SYS_DuplicateTableEntryExists(SYS_DuplicateTable_t *table,
     87              uint16_t address, uint8_t seqNumber)
     88          {
   \                     SYS_DuplicateTableEntryExists: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     89          #ifdef _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
     90            bool entryExists = false;
     91            SYS_DuplicateTableEntry_t *iter;
     92          
     93            sysDuplicateTableUpdate(table);
     94            for (iter = table->entries; iter < table->entries + table->size; ++iter)
     95            {
     96              if ((iter->ttl) && (iter->address == address))
     97              {
     98                /* Excess of stored Counter over received one */
     99                const uint8_t excess = (int16_t)iter->seqNumber - seqNumber;
    100                /* If excess less than packet mask length, we assume received packet is older
    101                 * than last remembered and we can check if this packet was already been received */
    102                if (excess < table->maskSize)
    103                {
    104                  if (iter->mask & (1UL << excess))
    105                    entryExists = true;
    106                }
    107                break;
    108              }
    109            }
    110            return entryExists;
    111          #else // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    112            SYS_DuplicateTableEntry_t *iter;
    113          
    114            for (iter = table->entries; iter < table->entries + table->size; ++iter)
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0x001C             MOVS     R4,R3
   \   00000006   0xE000             B        ??SYS_DuplicateTableEntryExists_0
   \                     ??SYS_DuplicateTableEntryExists_1: (+1)
   \   00000008   0x1D24             ADDS     R4,R4,#+4
   \                     ??SYS_DuplicateTableEntryExists_0: (+1)
   \   0000000A   0x7805             LDRB     R5,[R0, #+0]
   \   0000000C   0x086D             LSRS     R5,R5,#+1
   \   0000000E   0x00AD             LSLS     R5,R5,#+2
   \   00000010   0x195D             ADDS     R5,R3,R5
   \   00000012   0x42AC             CMP      R4,R5
   \   00000014   0xD20A             BCS      ??SYS_DuplicateTableEntryExists_2
    115            {
    116              if (iter->ttl && (iter->address == address) && (iter->seqNumber == seqNumber))
   \   00000016   0x78E5             LDRB     R5,[R4, #+3]
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD0F5             BEQ      ??SYS_DuplicateTableEntryExists_1
   \   0000001C   0x8825             LDRH     R5,[R4, #+0]
   \   0000001E   0x428D             CMP      R5,R1
   \   00000020   0xD1F2             BNE      ??SYS_DuplicateTableEntryExists_1
   \   00000022   0x78A5             LDRB     R5,[R4, #+2]
   \   00000024   0x4295             CMP      R5,R2
   \   00000026   0xD1EF             BNE      ??SYS_DuplicateTableEntryExists_1
    117                return true;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBD30             POP      {R4,R5,PC}
    118            }
    119          
    120            return false;
   \                     ??SYS_DuplicateTableEntryExists_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
    121          #endif // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    122          }
    123          /**************************************************************************//**
    124            \brief Search for record in table, add if not found.
    125          
    126            \param[in] table - pointer to allocated table
    127            \param[in] address, seqNumber - record to search for or to add if not found
    128          
    129            \return SYS_DUPLICATE_TABLE_ANSWER_FOUND - if duplicate packet is received
    130                    SYS_DUPLICATE_TABLE_ANSWER_ADDED - new packet is received and
    131                                                       information about the packet is added
    132                                                       to the table.
    133                    SYS_DUPLICATE_TABLE_ANSWER_FULL - there is no enough space in the table.
    134           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          SysDuplicateTableAnswer_t SYS_DuplicateTableCheck(SYS_DuplicateTable_t *table,
    136              uint16_t address, uint8_t seqNumber)
    137          {
   \                     SYS_DuplicateTableCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    138          
    139            SYS_DuplicateTableEntry_t *iter, *updatePosition = NULL;
   \   00000008   0x2400             MOVS     R4,#+0
    140          
    141          #ifdef _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    142          
    143            sysDuplicateTableUpdate(table);
    144          
    145            for (iter = table->entries; iter < table->entries + table->size; ++iter)
    146            {
    147              /* We have only one record in duplicate table per shortAdress */
    148              if (iter->ttl && iter->address == address)
    149              {
    150                /* Excess of stored apsCounter over received one */
    151                const uint8_t excess = (int16_t)iter->seqNumber - seqNumber;
    152                /* If excess less than packet mask length, we assume received packet is older
    153                 * than last remembered and we can check if this packet was already been received */
    154                if (excess < table->maskSize)
    155                {
    156                  if (iter->mask & (1UL << excess))
    157                    return SYS_DUPLICATE_TABLE_ANSWER_FOUND;
    158                  else
    159                  {
    160                    iter->mask |= 1UL << excess;
    161                    return SYS_DUPLICATE_TABLE_ANSWER_ADDED;
    162                  }
    163                }
    164                /* If excess more than mask length we shift our bit map forward to new packet */
    165                else
    166                {
    167                  const uint8_t shiftLen = (int16_t)-excess;
    168                  iter->seqNumber = seqNumber;
    169                  iter->mask = (shiftLen < table->maskSize) ? (iter->mask << shiftLen) : 0UL ;
    170                  iter->mask |= 1UL;
    171                  iter->ttl = table->maxTTL;
    172                  return SYS_DUPLICATE_TABLE_ANSWER_ADDED;
    173                }
    174              }
    175              /* Search for oldest record in table. */
    176              if (!updatePosition || iter->ttl < updatePosition->ttl)
    177                updatePosition = iter;
    178            }
    179          
    180            if (!table->removeOldest && (!updatePosition || updatePosition->ttl))
    181                return SYS_DUPLICATE_TABLE_ANSWER_FULL;
    182          
    183            /* If apsDuplicateRejectionTableSize is zero updatePosition can be NULL */
    184            if (updatePosition)
    185            {
    186              /* Add or update record. */
    187              updatePosition->address = address;
    188              updatePosition->seqNumber = seqNumber;
    189              updatePosition->ttl = table->maxTTL;
    190              updatePosition->mask = 1UL;
    191            }
    192          
    193            return SYS_DUPLICATE_TABLE_ANSWER_ADDED;
    194          #else // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    195          
    196            sysDuplicateTableUpdate(table);
   \   0000000A   0x.... 0x....      BL       HAL_GetSystemTime
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x68E9             LDR      R1,[R5, #+12]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014   0x8929             LDRH     R1,[R5, #+8]
   \   00000016   0x.... 0x....      BL       __aeabi_uidiv
   \   0000001A   0x28FF             CMP      R0,#+255
   \   0000001C   0xD203             BCS      ??SYS_DuplicateTableCheck_0
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE      ??SYS_DuplicateTableCheck_1
   \   00000024   0xE013             B        ??SYS_DuplicateTableCheck_2
   \                     ??SYS_DuplicateTableCheck_0: (+1)
   \   00000026   0x20FF             MOVS     R0,#+255
   \                     ??SYS_DuplicateTableCheck_1: (+1)
   \   00000028   0x6869             LDR      R1,[R5, #+4]
   \   0000002A   0xE007             B        ??SYS_DuplicateTableCheck_3
   \                     ??SYS_DuplicateTableCheck_4: (+1)
   \   0000002C   0x78CB             LDRB     R3,[R1, #+3]
   \   0000002E   0x0002             MOVS     R2,R0
   \   00000030   0x4298             CMP      R0,R3
   \   00000032   0xDD00             BLE      ??SYS_DuplicateTableCheck_5
   \   00000034   0x001A             MOVS     R2,R3
   \                     ??SYS_DuplicateTableCheck_5: (+1)
   \   00000036   0x1A9A             SUBS     R2,R3,R2
   \   00000038   0x70CA             STRB     R2,[R1, #+3]
   \   0000003A   0x1D09             ADDS     R1,R1,#+4
   \                     ??SYS_DuplicateTableCheck_3: (+1)
   \   0000003C   0x686A             LDR      R2,[R5, #+4]
   \   0000003E   0x782B             LDRB     R3,[R5, #+0]
   \   00000040   0x085B             LSRS     R3,R3,#+1
   \   00000042   0x009B             LSLS     R3,R3,#+2
   \   00000044   0x18D2             ADDS     R2,R2,R3
   \   00000046   0x4291             CMP      R1,R2
   \   00000048   0xD3F0             BCC      ??SYS_DuplicateTableCheck_4
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x60E8             STR      R0,[R5, #+12]
    197          
    198            for (iter = table->entries; iter < table->entries + table->size; ++iter)
   \                     ??SYS_DuplicateTableCheck_2: (+1)
   \   0000004E   0x6868             LDR      R0,[R5, #+4]
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0xE006             B        ??SYS_DuplicateTableCheck_6
    199            {
    200              if (iter->ttl && (iter->address == address) && (iter->seqNumber == seqNumber))
    201                return SYS_DUPLICATE_TABLE_ANSWER_FOUND;
    202              /* Search for oldest record in table. */
    203              if (!updatePosition || iter->ttl < updatePosition->ttl)
   \                     ??SYS_DuplicateTableCheck_7: (+1)
   \   00000054   0x2C00             CMP      R4,#+0
   \   00000056   0xD002             BEQ      ??SYS_DuplicateTableCheck_8
   \   00000058   0x78E3             LDRB     R3,[R4, #+3]
   \   0000005A   0x429A             CMP      R2,R3
   \   0000005C   0xD200             BCS      ??SYS_DuplicateTableCheck_9
    204                updatePosition = iter;
   \                     ??SYS_DuplicateTableCheck_8: (+1)
   \   0000005E   0x000C             MOVS     R4,R1
   \                     ??SYS_DuplicateTableCheck_9: (+1)
   \   00000060   0x1D09             ADDS     R1,R1,#+4
   \                     ??SYS_DuplicateTableCheck_6: (+1)
   \   00000062   0x782A             LDRB     R2,[R5, #+0]
   \   00000064   0x0853             LSRS     R3,R2,#+1
   \   00000066   0x009B             LSLS     R3,R3,#+2
   \   00000068   0x18C3             ADDS     R3,R0,R3
   \   0000006A   0x4299             CMP      R1,R3
   \   0000006C   0xD20A             BCS      ??SYS_DuplicateTableCheck_10
   \   0000006E   0x78CA             LDRB     R2,[R1, #+3]
   \   00000070   0x2A00             CMP      R2,#+0
   \   00000072   0xD0EF             BEQ      ??SYS_DuplicateTableCheck_7
   \   00000074   0x880B             LDRH     R3,[R1, #+0]
   \   00000076   0x42BB             CMP      R3,R7
   \   00000078   0xD1EC             BNE      ??SYS_DuplicateTableCheck_7
   \   0000007A   0x788B             LDRB     R3,[R1, #+2]
   \   0000007C   0x42B3             CMP      R3,R6
   \   0000007E   0xD1E9             BNE      ??SYS_DuplicateTableCheck_7
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBDF2             POP      {R1,R4-R7,PC}
    205            }
    206          
    207            if (!table->removeOldest && (!updatePosition || updatePosition->ttl))
   \                     ??SYS_DuplicateTableCheck_10: (+1)
   \   00000084   0x07D0             LSLS     R0,R2,#+31
   \   00000086   0xD406             BMI      ??SYS_DuplicateTableCheck_11
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD002             BEQ      ??SYS_DuplicateTableCheck_12
   \   0000008C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD003             BEQ      ??SYS_DuplicateTableCheck_13
    208              return SYS_DUPLICATE_TABLE_ANSWER_FULL;
   \                     ??SYS_DuplicateTableCheck_12: (+1)
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}
    209          
    210            if (updatePosition)
   \                     ??SYS_DuplicateTableCheck_11: (+1)
   \   00000096   0x2C00             CMP      R4,#+0
   \   00000098   0xD003             BEQ      ??SYS_DuplicateTableCheck_14
    211            {
    212              updatePosition->address   = address;
   \                     ??SYS_DuplicateTableCheck_13: (+1)
   \   0000009A   0x8027             STRH     R7,[R4, #+0]
    213              updatePosition->seqNumber = seqNumber;
   \   0000009C   0x70A6             STRB     R6,[R4, #+2]
    214              updatePosition->ttl       = table->maxTTL;
   \   0000009E   0x7C28             LDRB     R0,[R5, #+16]
   \   000000A0   0x70E0             STRB     R0,[R4, #+3]
    215            }
    216          
    217            return SYS_DUPLICATE_TABLE_ANSWER_ADDED;
   \                     ??SYS_DuplicateTableCheck_14: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    218          
    219          #endif // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    220          }
    221          
    222          /**************************************************************************//**
    223            \brief Clear info about given transaction from the rejection table.
    224          
    225            \param[in] table - pointer to allocated table
    226            \param[in] address, seqNumber - record to search for or to add if not found
    227          
    228            \return None.
    229           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    230          void SYS_DuplicateTableClear(SYS_DuplicateTable_t *table, uint16_t address,
    231            uint8_t seqNumber)
    232          {
   \                     SYS_DuplicateTableClear: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    233          #ifdef _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    234            SYS_DuplicateTableEntry_t *iter;
    235          
    236            for (iter = table->entries; iter < table->entries + table->size; ++iter)
    237            {
    238              if (iter->ttl && iter->address == address)
    239              {
    240                const uint8_t excess = (int16_t)iter->seqNumber - seqNumber;
    241          
    242                if (excess < table->maskSize)
    243                {
    244                  iter->mask &= ~(1UL << excess);
    245                  if (!iter->mask)
    246                    iter->ttl = 0U;
    247                }
    248              }
    249            }
    250          #else // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    251            SYS_DuplicateTableEntry_t *iter;
    252          
    253            for (iter = table->entries; iter < table->entries + table->size; ++iter)
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0xE00B             B        ??SYS_DuplicateTableClear_0
    254            {
    255              if (iter->ttl && (iter->address == address) && (iter->seqNumber == seqNumber))
   \                     ??SYS_DuplicateTableClear_1: (+1)
   \   00000006   0x78DC             LDRB     R4,[R3, #+3]
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ      ??SYS_DuplicateTableClear_2
   \   0000000C   0x881C             LDRH     R4,[R3, #+0]
   \   0000000E   0x428C             CMP      R4,R1
   \   00000010   0xD104             BNE      ??SYS_DuplicateTableClear_2
   \   00000012   0x789C             LDRB     R4,[R3, #+2]
   \   00000014   0x4294             CMP      R4,R2
   \   00000016   0xD101             BNE      ??SYS_DuplicateTableClear_2
    256                iter->ttl = 0U;
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0x70DC             STRB     R4,[R3, #+3]
    257            }
   \                     ??SYS_DuplicateTableClear_2: (+1)
   \   0000001C   0x1D1B             ADDS     R3,R3,#+4
   \                     ??SYS_DuplicateTableClear_0: (+1)
   \   0000001E   0x6844             LDR      R4,[R0, #+4]
   \   00000020   0x7805             LDRB     R5,[R0, #+0]
   \   00000022   0x086D             LSRS     R5,R5,#+1
   \   00000024   0x00AD             LSLS     R5,R5,#+2
   \   00000026   0x1964             ADDS     R4,R4,R5
   \   00000028   0x42A3             CMP      R3,R4
   \   0000002A   0xD3EC             BCC      ??SYS_DuplicateTableClear_1
    258          #endif // _DUPLICATE_REJECTION_TABLE_BIT_MASK_ENABLE_
    259          }
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x00008001         DC32     0x8001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     gAssertDbgCode
    260          
    261          /**************************************************************************//**
    262            \brief Update entries ttl.
    263          
    264            \param[in] table - able - table to work on.
    265            \return None.
    266           ******************************************************************************/
    267          static void sysDuplicateTableUpdate(SYS_DuplicateTable_t *table)
    268          {
    269            SYS_DuplicateTableEntry_t *it;
    270            uint32_t time = HAL_GetSystemTime();
    271            uint8_t diff = (uint8_t)MIN(((time - table->lastStamp)/ table->agingPeriod), UINT8_MAX);
    272          
    273            if(diff == 0)
    274              return;
    275          
    276            for(it = table->entries; it < table->entries + table->size; it++)
    277              it->ttl -= MIN(diff, it->ttl);
    278          
    279            table->lastStamp = time;
    280          }
    281          
    282          /** eof sysDuplicateTable.c */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SYS_DuplicateTableCheck
        24   -> HAL_GetSystemTime
        24 __aeabi_uidiv
      12   SYS_DuplicateTableClear
      12   SYS_DuplicateTableEntryExists
       8   SYS_DuplicateTableReset
         8   -> SYS_DefAssertCallbackError


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
     166  SYS_DuplicateTableCheck
      46  SYS_DuplicateTableClear
      48  SYS_DuplicateTableEntryExists
      70  SYS_DuplicateTableReset

 
 338 bytes in section .text
 
 338 bytes of CODE memory

Errors: none
Warnings: none
