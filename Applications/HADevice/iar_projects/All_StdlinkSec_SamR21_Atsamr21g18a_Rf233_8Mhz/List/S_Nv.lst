###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:40:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZLLPlatform\ZLL\S_Nv\src\S_Nv.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZLLPlatform\ZLL\S_Nv\src\S_Nv.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\S_Nv.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\S_Nv.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ZLLPlatform\ZLL\S_Nv\src\S_Nv.c
      1          /**************************************************************************//**
      2            \file S_Nv.c
      3          
      4            \brief NV component.
      5          
      6            \author
      7              Atmel Corporation: http://www.atmel.com \n
      8              Support email: avr@atmel.com
      9          
     10            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     11            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     12          
     13            \internal
     14              History:
     15              03.10.12 A. Razinkov - created
     16          ******************************************************************************/
     17          
     18          #if PDS_ENABLE_WEAR_LEVELING == 1
     19          #ifdef _ENABLE_PERSISTENT_SERVER_
     20          #ifndef PDS_USE_EXTERNAL_FLASH
     21          /***************************************************************************************************
     22          * LOCAL INCLUDE FILES
     23          ***************************************************************************************************/
     24          
     25          #include "S_Nv_Bindings.h"
     26          #include "S_Nv_Init.h"
     27          #include "S_Nv.h"
     28          #include "pdsDataServer.h"
     29          
     30          /***************************************************************************************************
     31          * EXTERNAL INCLUDE FILES
     32          ***************************************************************************************************/
     33          
     34          #include "D_Nv.h"
     35          #include "N_ErrH.h"
     36          #include "N_Log.h"
     37          #include "N_Util.h"
     38          #include "N_Task.h"
     39          #include "N_Timer.h"
     40          #include "N_Types.h"
     41          #include "wlPdsMemIds.h"
     42          #include <sysTimer.h>
     43          
     44          //#include "S_Nv_Platform_Ids.h" // layering violation!
     45          
     46          /***************************************************************************************************
     47          * LOCAL MACROS AND CONSTANTS
     48          ***************************************************************************************************/
     49          
     50          #if defined __IAR_SYSTEMS_ICC__
     51          //#define S_XNV_LOGGING
     52          #endif
     53          
     54          #define COMPID "S_Nv"
     55          
     56          #if !defined(MAX_ITEM_COUNT)
     57          /** The maxumum number of items. */
     58          #define MAX_ITEM_COUNT 128u
     59          #endif
     60          
     61          /** The maxumum length of an item. */
     62          #define MAX_ITEM_LENGTH 1024u
     63          
     64          /** Timer event used to erase a sector. */
     65          #define EVENT_ERASE_SECTOR   0u
     66          #define EVENT_COMPACT_SECTOR 1u
     67          #define EVENT_COMPACT_ITEM   2u
     68          
     69          /** Delay before erasing a sector. */
     70          #define ERASE_SECTOR_DELAY_MS 7000u
     71          
     72          /** Delay before performing a preemptive compact operation. */
     73          #define COMPACT_SECTOR_DELAY_MS 10000u
     74          
     75          /** Delay before performing a compact item operation. */
     76          #define COMPACT_ITEM_DELAY_MS 3000u
     77          
     78          /** Perform a compact item operation if the number of partial writes is larger than this. */
     79          #define COMPACT_ITEM_THRESHOLD 100u
     80          
     81          /** Perform a compact sector operation with a delay if the sector has less free space than this. */
     82          #define PREEMPTIVE_COMPACT_SECTOR_THRESHOLD  (MAX_ITEM_LENGTH + BLOCK_HEADER_SIZE)
     83          
     84          #define SECTOR_SIZE   D_NV_SECTOR_SIZE
     85          #define FIRST_SECTOR  D_NV_FIRST_SECTOR
     86          #define SECTOR_COUNT  D_NV_SECTOR_COUNT
     87          
     88          /** The size of the sector header. */
     89          #define SECTOR_HEADER_SIZE ((uint16_t) sizeof(SectorHeader_t))
     90          /** The size of the block header. */
     91          #define BLOCK_HEADER_SIZE ((uint16_t) sizeof(BlockHeader_t))
     92          
     93          /** The sequence number to use for the initial sector. */
     94          #define INITIAL_SECTOR_SEQUENCE_NUMBER 0xFFFFFFFEuL
     95          
     96          /***************************************************************************************************
     97          * LOCAL TYPES
     98          ***************************************************************************************************/
     99          
    100          // make sure that the flash structures are packed
    101          #if defined(__ICC8051__)
    102          // the IAR compiler for 8051 does not supports "#pragma pack", but does not need it either...
    103          #else
    104          // ...assume that all other compilers do support it
    105          #pragma pack(1)
    106          #endif
    107          
    108          /** 16 byte sector header used in flash located at the start of the active sector. */
    109          typedef struct SectorHeader_t
    110          {
    111              /** Is this sector active. Written with 0x0000 at the end of the compact operation. */
    112              uint16_t isActive;
    113              /** Signature to detect valid sectors. Must have the value "S_Nv2". */
    114              uint8_t signature[6];
    115              /** Counter, decreased each time a new sector becomes the active sector. */
    116              uint32_t sequenceNumber;
    117              /** Parity bits for the sequenceNumber field = sequenceNumber ^ 0xFFFFFFFFuL. */
    118              uint32_t sequenceParity;
    119          } SectorHeader_t;
    120          
    121          typedef struct BlockHeader_t
    122          {
    123              /** Is this block active. Written with 0x0000 at the end of the write operation. */
    124              uint16_t isActive;
    125              /** Item identifier for this block. 0x0000 for a meta block. */
    126              uint16_t id;
    127              /** Offset of this block within the item. */
    128              uint16_t blockOffset;
    129              /** Length of this block. */
    130              uint16_t blockLength;
    131              /** Length of the complete item. */
    132              uint16_t itemLength;
    133              /** Pointer to the previous block for this item. */
    134              uint16_t previousBlock;
    135              /** Number of partial writes to the item since the last complete write of the item. */
    136              uint16_t writeCount;
    137              /** CRC of the header, not including the isActive and headerCrc fields. */
    138              uint16_t headerCrc;
    139          } BlockHeader_t;
    140          
    141          /** Structure used to store where to find an item. */
    142          typedef struct Item_t
    143          {
    144              /** Item identifier. */
    145              uint16_t id;
    146              /** Pointer to the last written block for this item. */
    147              uint16_t lastBlock;
    148          } Item_t;
    149          
    150          // back to the default packing
    151          #if defined(__ICC8051__)
    152          // the IAR compiler for 8051 does not supports "#pragma pack", but does not need it either...
    153          #else
    154          // ...assume that all other compilers do support it (only tested with visual studio)
    155          #pragma pack()
    156          #endif
    157          
    158          /***************************************************************************************************
    159          * LOCAL VARIABLES
    160          ***************************************************************************************************/
    161          

   \                                 In section .rodata, align 4, keep-with-next
    162          static const uint16_t s_persistentItems[] = { PERSISTENT_NV_ITEMS_PLATFORM, PERSISTENT_NV_ITEMS_APPLICATION };
   \                     s_persistentItems:
   \   00000000   0x0006 0x0FFF      DC16 6, 4095
    163          
    164          /** The active sector. */
    165          static uint8_t s_sector;
    166          /** Location of the first unprogrammed byte in the active sector. */
    167          static uint16_t s_sectorHead;
    168          
    169          /** The number of read, and thus cached, items */
    170          static uint8_t s_itemCount = 0u;

   \                                 In section .bss, align 4
    171          static Item_t s_itemCache[MAX_ITEM_COUNT];
   \                     s_itemCache:
   \   00000000                      DS8 512
    172          
    173          /** The sector to erase in the EVENT_ERASE_SECTOR handler. */
    174          static uint8_t s_sectorToErase = 0xFFu;
    175          
    176          /** The item to perform a compact operation on and the length of this item. */
    177          static uint16_t s_compactItemId = 0x0000u;
    178          static uint16_t s_compactItemLength = 0x0000u;
    179          
    180          /** Callback function called before changing flash contents. */

   \                                 In section .bss, align 4
    181          static S_Nv_PowerSupplyCheckingFunction_t s_powerSupplyCheckingFunction = NULL;
   \                     s_powerSupplyCheckingFunction:
   \   00000000                      DS8 4
    182          
    183          static HAL_AppTimer_t eraseSectorTimer;
    184          static SYS_Timer_t compactSectorTimer;

   \                                 In section .bss, align 4
    185          static SYS_Timer_t compactItemTimer;
   \                     compactItemTimer:
   \   00000000                      DS8 24

   \                                 In section .data, align 4
   \                     eraseSectorTimer:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00               DC8 0
   \   00000015   0x00               DC8 0
   \   00000016   0xFF               DC8 255
   \   00000017   0x00               DC8 0
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000030   0x00 0x00          DC8 0, 0
   \   00000032   0x0000             DC16 0
   \   00000034   0x0000             DC16 0
    186          
    187          /** Check if the early init function is called already. */
    188          static bool s_earlyInitDone = FALSE;
    189          
    190          /***************************************************************************************************
    191          * LOCAL FUNCTION DECLARATIONS
    192          ***************************************************************************************************/
    193          static void eraseSectorTimerFired(void);
    194          static void compactSectorTimerFired(void);
    195          static void compactItemTimerFired(void);
    196          static bool PowerSupplyTooLow(void);
    197          static bool CompactSector(void);
    198          static S_Nv_ReturnValue_t CompactItem(void);
    199          
    200          /***************************************************************************************************
    201          * LOCAL FUNCTIONS
    202          ***************************************************************************************************/
    203          /** Erase sector timer callback.
    204          */

   \                                 In section .text, align 2, keep-with-next
    205          static void eraseSectorTimerFired(void)
    206          {
   \                     eraseSectorTimerFired: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    207              if (!PowerSupplyTooLow())
   \   00000002   0x.... 0x....      BL       PowerSupplyTooLow
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??eraseSectorTimerFired_0
    208                  D_Nv_EraseSector(s_sectorToErase);
   \   0000000A   0x....             LDR      R0,??DataTable13
   \   0000000C   0x7D80             LDRB     R0,[R0, #+22]
   \   0000000E   0x.... 0x....      BL       D_Nv_EraseSector_Impl
    209          }
   \                     ??eraseSectorTimerFired_0: (+1)
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    210          
    211          /** Compact sector timer callback.
    212          */

   \                                 In section .text, align 2, keep-with-next
    213          static void compactSectorTimerFired(void)
    214          {
   \                     compactSectorTimerFired: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    215              if (!PowerSupplyTooLow())
   \   00000002   0x.... 0x....      BL       PowerSupplyTooLow
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD107             BNE      ??compactSectorTimerFired_0
    216                  if (!CompactSector())
   \   0000000A   0x.... 0x....      BL       CompactSector
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE      ??compactSectorTimerFired_0
    217                      N_ERRH_FATAL();
   \   00000012   0x21D9             MOVS     R1,#+217
   \   00000014   0x....             LDR      R0,??DataTable14
   \   00000016   0x.... 0x....      BL       N_ErrH_Fatal
    218          }
   \                     ??compactSectorTimerFired_0: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    219          
    220          /** Compact item timer callback.
    221          */

   \                                 In section .text, align 2, keep-with-next
    222          static void compactItemTimerFired(void)
    223          {
   \                     compactItemTimerFired: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    224              (void)CompactItem();
   \   00000002   0x.... 0x....      BL       CompactItem
    225          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    226          
    227          /** Check the power supply.
    228              \returns TRUE if the power supply is too low, FALSE when the the power
    229                       supply is OK or when there is no callback installed.
    230          */

   \                                 In section .text, align 2, keep-with-next
    231          static bool PowerSupplyTooLow()
    232          {
   \                     PowerSupplyTooLow: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    233              bool result = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    234              if ( s_powerSupplyCheckingFunction != NULL )
   \   00000004   0x....             LDR      R0,??DataTable14_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD003             BEQ      ??PowerSupplyTooLow_0
    235              {
    236                  if ( !s_powerSupplyCheckingFunction() )
   \   0000000C   0x4780             BLX      R0
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE      ??PowerSupplyTooLow_0
    237                  {
    238                      result = TRUE;
   \   00000012   0x2401             MOVS     R4,#+1
    239                  }
    240              }
    241              return result;
   \                     ??PowerSupplyTooLow_0: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    242          }
    243          
    244          static bool IsPersistent(uint16_t id)
    245          {
    246              for ( uint8_t i = 0u; i < N_UTIL_ARRAY_SIZE(s_persistentItems); i++ )
    247              {
    248                  if ( id == s_persistentItems[i] )
    249                  {
    250                      return TRUE;
    251                  }
    252              }
    253              return FALSE;
    254          }
    255          
    256          /** Check if the RAM buffer contains all 0xFF values (flash erased)
    257              \param pData The buffer to check
    258              \param length The length of the buffer
    259              \returns TRUE if the buffer contains all 0xFF, FALSE otherwise
    260          */
    261          static bool IsEmpty(uint8_t* pData, uint16_t length)
    262          {
    263              for ( uint16_t i = 0u; i < length; i++ )
    264              {
    265                  if ( pData[i] != 0xFFu )
    266                  {
    267                      return FALSE;
    268                  }
    269              }
    270          
    271              return TRUE;
    272          }
    273          

   \                                 In section .text, align 2, keep-with-next
    274          static void UpdateSectorHead(uint16_t increment)
    275          {
    276              // make sure that the sector head is aligned to 16 bytes
    277              s_sectorHead = (s_sectorHead + increment + 0x000Fu) & 0xFFF0u;
   \                     UpdateSectorHead: (+1)
   \   00000000   0x....             LDR      R1,??DataTable13
   \   00000002   0x8E0A             LDRH     R2,[R1, #+48]
   \   00000004   0x1810             ADDS     R0,R2,R0
   \   00000006   0x300F             ADDS     R0,R0,#+15
   \   00000008   0x....             LDR      R2,??DataTable14_2  ;; 0xfff0
   \   0000000A   0x4002             ANDS     R2,R2,R0
   \   0000000C   0x860A             STRH     R2,[R1, #+48]
    278          }
   \   0000000E   0x4770             BX       LR               ;; return
    279          
    280          /** Return a pointer to the cache for the item.
    281              \param id The id to find
    282              \returns A pointer to the cache for the ID, or NULL if it was not found
    283          */

   \                                 In section .text, align 2, keep-with-next
    284          static Item_t *FindItemCache(uint16_t id)
    285          {
   \                     FindItemCache: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    286              for ( uint8_t cacheIndex = 0u; cacheIndex < s_itemCount; cacheIndex++ )
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x....             LDR      R1,??DataTable14_3
   \   00000006   0x....             LDR      R2,??DataTable13
   \   00000008   0xE000             B        ??FindItemCache_0
   \                     ??FindItemCache_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??FindItemCache_0: (+1)
   \   0000000C   0x7D54             LDRB     R4,[R2, #+21]
   \   0000000E   0xB2DB             UXTB     R3,R3
   \   00000010   0x42A3             CMP      R3,R4
   \   00000012   0xD215             BCS      ??FindItemCache_2
    287              {
    288                  Item_t *cache = &s_itemCache[cacheIndex];
   \   00000014   0x009C             LSLS     R4,R3,#+2
   \   00000016   0x190C             ADDS     R4,R1,R4
    289                  if ( cache->id == id )
   \   00000018   0x7825             LDRB     R5,[R4, #+0]
   \   0000001A   0x7866             LDRB     R6,[R4, #+1]
   \   0000001C   0x0636             LSLS     R6,R6,#+24
   \   0000001E   0x0C36             LSRS     R6,R6,#+16
   \   00000020   0x4335             ORRS     R5,R5,R6
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xD1F1             BNE      ??FindItemCache_1
    290                  {
    291                      N_ERRH_ASSERT_FATAL(cache->lastBlock != 0x0000);
   \   00000026   0x78A0             LDRB     R0,[R4, #+2]
   \   00000028   0x78E1             LDRB     R1,[R4, #+3]
   \   0000002A   0x0609             LSLS     R1,R1,#+24
   \   0000002C   0x0C09             LSRS     R1,R1,#+16
   \   0000002E   0x4308             ORRS     R0,R0,R1
   \   00000030   0xD104             BNE      ??FindItemCache_3
   \   00000032   0x21FF             MOVS     R1,#+255
   \   00000034   0x3124             ADDS     R1,R1,#+36       ;; #+291
   \   00000036   0x....             LDR      R0,??DataTable14
   \   00000038   0x.... 0x....      BL       N_ErrH_Fatal
    292                      return cache;
   \                     ??FindItemCache_3: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xBD70             POP      {R4-R6,PC}
    293                  }
    294              }
    295              return NULL;
   \                     ??FindItemCache_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    296          }
    297          
    298          /** Return a pointer to a cache for a new item.
    299              \param id The id to create cache for
    300              \returns A pointer to the cache for the ID
    301          */

   \                                 In section .text, align 2, keep-with-next
    302          static Item_t *CreateItemCache(uint16_t id)
    303          {
   \                     CreateItemCache: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    304              N_ERRH_ASSERT_FATAL(FindItemCache(id) == NULL);
   \   00000004   0x....             LDR      R4,??DataTable14
   \   00000006   0x.... 0x....      BL       FindItemCache
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ      ??CreateItemCache_0
   \   0000000E   0x2198             MOVS     R1,#+152
   \   00000010   0x0049             LSLS     R1,R1,#+1        ;; #+304
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       N_ErrH_Fatal
    305              N_ERRH_ASSERT_FATAL(s_itemCount < MAX_ITEM_COUNT);
   \                     ??CreateItemCache_0: (+1)
   \   00000018   0x....             LDR      R5,??DataTable13
   \   0000001A   0x7D68             LDRB     R0,[R5, #+21]
   \   0000001C   0x2880             CMP      R0,#+128
   \   0000001E   0xD304             BCC      ??CreateItemCache_1
   \   00000020   0x21FF             MOVS     R1,#+255
   \   00000022   0x3132             ADDS     R1,R1,#+50       ;; #+305
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       N_ErrH_Fatal
    306          
    307              Item_t *cache = &s_itemCache[s_itemCount++];
   \                     ??CreateItemCache_1: (+1)
   \   0000002A   0x7D69             LDRB     R1,[R5, #+21]
   \   0000002C   0x....             LDR      R0,??DataTable14_3
   \   0000002E   0x008A             LSLS     R2,R1,#+2
   \   00000030   0x1880             ADDS     R0,R0,R2
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0x7569             STRB     R1,[R5, #+21]
    308              cache->id = id;
   \   00000036   0x7006             STRB     R6,[R0, #+0]
   \   00000038   0x0A36             LSRS     R6,R6,#+8
   \   0000003A   0x7046             STRB     R6,[R0, #+1]
    309          
    310              return cache;
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    311          }
    312          
    313          /** Removes the specified item from the cache array.
    314              \param id The id to delete the cache for
    315          */

   \                                 In section .text, align 2, keep-with-next
    316          static void DeleteItemCache(uint16_t id)
    317          {
   \                     DeleteItemCache: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    318              N_ERRH_ASSERT_FATAL(FindItemCache(id) != NULL);
   \   00000004   0x.... 0x....      BL       FindItemCache
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE      ??DeleteItemCache_0
   \   0000000C   0x219F             MOVS     R1,#+159
   \   0000000E   0x0049             LSLS     R1,R1,#+1        ;; #+318
   \   00000010   0x....             LDR      R0,??DataTable14
   \   00000012   0x.... 0x....      BL       N_ErrH_Fatal
    319          
    320              // Overwrite specified item cache with the last one
    321              Item_t *cache = FindItemCache(id);
   \                     ??DeleteItemCache_0: (+1)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       FindItemCache
    322              *cache = s_itemCache[--s_itemCount];
   \   0000001C   0x....             LDR      R1,??DataTable13
   \   0000001E   0x7D4A             LDRB     R2,[R1, #+21]
   \   00000020   0x1E52             SUBS     R2,R2,#+1
   \   00000022   0x754A             STRB     R2,[R1, #+21]
   \   00000024   0x....             LDR      R1,??DataTable14_3
   \   00000026   0x0612             LSLS     R2,R2,#+24
   \   00000028   0x0D92             LSRS     R2,R2,#+22
   \   0000002A   0x1889             ADDS     R1,R1,R2
   \   0000002C   0x2204             MOVS     R2,#+4
   \   0000002E   0x.... 0x....      BL       __aeabi_memcpy
    323          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    324          
    325          /** Return a pointer to the last written block for the item.
    326              \param id The id to find
    327              \returns A pointer to the last written block, or 0x0000u if the item was not found
    328          */

   \                                 In section .text, align 2, keep-with-next
    329          static uint16_t FindItem(uint16_t id)
    330          {
   \                     FindItem: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    331              Item_t *cache = FindItemCache(id);
   \   00000002   0x.... 0x....      BL       FindItemCache
   \   00000006   0x0001             MOVS     R1,R0
    332          
    333              if (cache)
   \   00000008   0xD005             BEQ      ??FindItem_0
    334              {
    335                  return cache->lastBlock;
   \   0000000A   0x7888             LDRB     R0,[R1, #+2]
   \   0000000C   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000E   0x0612             LSLS     R2,R2,#+24
   \   00000010   0x0C12             LSRS     R2,R2,#+16
   \   00000012   0x4310             ORRS     R0,R0,R2
   \   00000014   0xBD02             POP      {R1,PC}
    336              }
    337          
    338              // item not found
    339              return 0x0000u;
   \                     ??FindItem_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    340          }
    341          
    342          static uint16_t ComputeCrc(uint8_t* pData, uint16_t length)
    343          {
    344              uint16_t crc = 0xFFFFu;
    345          
    346              for ( /* empty */ ; length != 0u; length-- )
    347              {
    348                  uint8_t x;
    349                  x = (uint8_t) ((crc >> 8) ^ *pData);
    350                  x = x ^ (x >> 4);
    351                  crc = (crc << 8) ^ ((uint16_t) x << 12) ^ ((uint16_t) x << 5) ^ (uint16_t) x;
    352          
    353                  pData++;
    354              }
    355          
    356              return crc;
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          static uint16_t ComputeHeaderCrc(BlockHeader_t* pBlockHeader)
    360          {
   \                     ComputeHeaderCrc: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    361              return ComputeCrc(((uint8_t*) pBlockHeader) + 2u, 12u); // skip isActive and headerCrc
   \   00000002   0x1C81             ADDS     R1,R0,#+2
   \   00000004   0x....             LDR      R0,??DataTable15  ;; 0xffff
   \   00000006   0x220C             MOVS     R2,#+12
   \                     ??ComputeHeaderCrc_0: (+1)
   \   00000008   0x0A04             LSRS     R4,R0,#+8
   \   0000000A   0x780B             LDRB     R3,[R1, #+0]
   \   0000000C   0x4063             EORS     R3,R3,R4
   \   0000000E   0x001C             MOVS     R4,R3
   \   00000010   0x091B             LSRS     R3,R3,#+4
   \   00000012   0x4063             EORS     R3,R3,R4
   \   00000014   0x001C             MOVS     R4,R3
   \   00000016   0x0200             LSLS     R0,R0,#+8
   \   00000018   0x031B             LSLS     R3,R3,#+12
   \   0000001A   0x4043             EORS     R3,R3,R0
   \   0000001C   0x0165             LSLS     R5,R4,#+5
   \   0000001E   0x405D             EORS     R5,R5,R3
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x4068             EORS     R0,R0,R5
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0x1E52             SUBS     R2,R2,#+1
   \   0000002A   0xD1ED             BNE      ??ComputeHeaderCrc_0
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return
    362          }
    363          

   \                                 In section .text, align 2, keep-with-next
    364          static bool WriteAndCheck(uint16_t offset, uint8_t* pData, uint16_t length)
    365          {
   \                     WriteAndCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    366              D_Nv_Write(s_sector, offset, pData, length);
   \   00000008   0x....             LDR      R4,??DataTable13
   \   0000000A   0x002B             MOVS     R3,R5
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0039             MOVS     R1,R7
   \   00000010   0x7D20             LDRB     R0,[R4, #+20]
   \   00000012   0x.... 0x....      BL       D_Nv_Write_Impl
    367              return D_Nv_IsEqual(s_sector, offset, pData, length);
   \   00000016   0x002B             MOVS     R3,R5
   \   00000018   0x0032             MOVS     R2,R6
   \   0000001A   0x0039             MOVS     R1,R7
   \   0000001C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000001E   0x.... 0x....      BL       D_Nv_IsEqual_Impl
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    368          }
    369          

   \                                 In section .text, align 2, keep-with-next
    370          static bool WriteBlockHeader(BlockHeader_t* pBlockHeader)
    371          {
   \                     WriteBlockHeader: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    372              pBlockHeader->isActive = 0xFFFFu;
   \   00000004   0x....             LDR      R0,??DataTable15  ;; 0xffff
   \   00000006   0x7028             STRB     R0,[R5, #+0]
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0x7068             STRB     R0,[R5, #+1]
    373              pBlockHeader->headerCrc = ComputeHeaderCrc(pBlockHeader);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       ComputeHeaderCrc
   \   00000012   0x73A8             STRB     R0,[R5, #+14]
   \   00000014   0x0A00             LSRS     R0,R0,#+8
   \   00000016   0x73E8             STRB     R0,[R5, #+15]
    374          
    375              if ( !WriteAndCheck(s_sectorHead, (uint8_t*) pBlockHeader, BLOCK_HEADER_SIZE) )
   \   00000018   0x....             LDR      R4,??DataTable13
   \   0000001A   0x2210             MOVS     R2,#+16
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x8E20             LDRH     R0,[R4, #+48]
   \   00000020   0x.... 0x....      BL       WriteAndCheck
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD10B             BNE      ??WriteBlockHeader_0
    376              {
    377                  // failed to write header to flash.
    378                  // check if any bits were programmed
    379                  if ( !D_Nv_IsEmpty(s_sector, s_sectorHead, BLOCK_HEADER_SIZE) )
   \   00000028   0x2210             MOVS     R2,#+16
   \   0000002A   0x8E21             LDRH     R1,[R4, #+48]
   \   0000002C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000002E   0x.... 0x....      BL       D_Nv_IsEmpty_Impl
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE      ??WriteBlockHeader_1
    380                  {
    381                      // the next write should skip this failed header as some bits have been programmed
    382                      UpdateSectorHead(BLOCK_HEADER_SIZE);
   \   00000036   0x2010             MOVS     R0,#+16
   \   00000038   0x.... 0x....      BL       UpdateSectorHead
    383                      return FALSE;
    384                  }
    385                  else
    386                  {
    387                      // no bits were programmed (everything still is 0xFF).
    388                      // the init function sees this as the start of the empty space
    389                      // in the sector, so the next write should should attempt to
    390                      // write to the same address
    391                      return FALSE;
   \                     ??WriteBlockHeader_1: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}
    392                  }
    393              }
    394              else
    395              {
    396                  UpdateSectorHead(BLOCK_HEADER_SIZE);
   \                     ??WriteBlockHeader_0: (+1)
   \   00000040   0x2010             MOVS     R0,#+16
   \   00000042   0x.... 0x....      BL       UpdateSectorHead
    397                  return TRUE;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    398              }
    399          }
    400          

   \                                 In section .text, align 2, keep-with-next
    401          static bool ActivateBlock(uint16_t blockPointer)
    402          {
   \                     ActivateBlock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    403              uint16_t isActive = 0x0000u;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0x8011             STRH     R1,[R2, #+0]
    404              if ( !WriteAndCheck(blockPointer, (uint8_t*) &isActive, sizeof(uint16_t)) )
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             B.N      ?Subroutine0
    405              {
    406                  // failed to activate the block
    407                  return FALSE;
    408              }
    409              else
    410              {
    411                  return TRUE;
    412              }
    413          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       WriteAndCheck
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD000             BEQ      ??Subroutine0_0
   \   00000008   0x2001             MOVS     R0,#+1
   \                     ??Subroutine0_0: (+1)
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    414          

   \                                 In section .text, align 2, keep-with-next
    415          static bool WriteDataBlock(BlockHeader_t* pBlockHeader, uint8_t* pData)
    416          {
   \                     WriteDataBlock: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    417              uint16_t blockPointer = s_sectorHead;
   \   00000006   0x....             LDR      R5,??DataTable13
   \   00000008   0x8E2F             LDRH     R7,[R5, #+48]
    418          
    419              if ( !WriteBlockHeader(pBlockHeader) )
   \   0000000A   0x.... 0x....      BL       WriteBlockHeader
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD022             BEQ      ??WriteDataBlock_0
    420              {
    421                  return FALSE;
    422              }
    423          
    424              if ( pData != NULL )
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD013             BEQ      ??WriteDataBlock_1
    425              {
    426                  if ( !WriteAndCheck(s_sectorHead, pData, pBlockHeader->blockLength) )
   \   00000016   0x79A2             LDRB     R2,[R4, #+6]
   \   00000018   0x79E0             LDRB     R0,[R4, #+7]
   \   0000001A   0x0600             LSLS     R0,R0,#+24
   \   0000001C   0x0C00             LSRS     R0,R0,#+16
   \   0000001E   0x4302             ORRS     R2,R2,R0
   \   00000020   0x0031             MOVS     R1,R6
   \   00000022   0x8E28             LDRH     R0,[R5, #+48]
   \   00000024   0x.... 0x....      BL       WriteAndCheck
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD108             BNE      ??WriteDataBlock_1
    427                  {
    428                      // failed to write data to flash.
    429                      // skip the invalid data for the next write (even if everything still is 0xFF)
    430                      UpdateSectorHead(pBlockHeader->blockLength);
   \   0000002C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000002E   0x79E1             LDRB     R1,[R4, #+7]
   \   00000030   0x0609             LSLS     R1,R1,#+24
   \   00000032   0x0C09             LSRS     R1,R1,#+16
   \   00000034   0x4308             ORRS     R0,R0,R1
   \   00000036   0x.... 0x....      BL       UpdateSectorHead
    431                      return FALSE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}
    432                  }
    433              }
    434              UpdateSectorHead(pBlockHeader->blockLength);
   \                     ??WriteDataBlock_1: (+1)
   \   0000003E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000040   0x79E1             LDRB     R1,[R4, #+7]
   \   00000042   0x0609             LSLS     R1,R1,#+24
   \   00000044   0x0C09             LSRS     R1,R1,#+16
   \   00000046   0x4308             ORRS     R0,R0,R1
   \   00000048   0x.... 0x....      BL       UpdateSectorHead
    435          
    436              if ( !ActivateBlock(blockPointer) )
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0x.... 0x....      BL       ActivateBlock
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD000             BEQ      ??WriteDataBlock_0
    437              {
    438                  // failed to activate the block
    439                  return FALSE;
    440              }
    441          
    442              return TRUE;
   \   00000056   0x2001             MOVS     R0,#+1
   \                     ??WriteDataBlock_0: (+1)
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    443          }
    444          
    445          /** Gather data from an item for a read or compact operation.
    446              \param sourceSector
    447              \param lastBlockPointer Pointer to the last block written for the item
    448              \param offset The start of the range of bytes to copy from the item
    449              \param length The size of the range of bytes to copy from the item
    450              \param pData Pointer to destination buffer in RAM for a read operation. NULL for a compact operation.
    451          
    452              This function is used by both the read and the compact operation.
    453               - For a read operation, the pBuffer parameter points to a buffer in RAM.
    454               - For a compact operation, pBuffer parameter is NULL and the data will
    455                 be copied to the flash memory \ref s_sectorHead in sector \ref s_sector.
    456          
    457          */

   \                                 In section .text, align 2, keep-with-next
    458          static bool GatherData(uint8_t sourceSector, uint16_t lastBlockPointer, uint16_t offset, uint16_t length, void* pData)
    459          {
   \                     GatherData: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9003             STR      R0,[SP, #+12]
    460              // pointer to end of destination in RAM
    461              uint8_t* pDestination = NULL;
    462              // pointer to end of destination in flash
    463              uint16_t destinationPointer = 0u;
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0x9814             LDR      R0,[SP, #+80]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ      ??GatherData_0
    464          
    465              // prepare the correct pointer
    466              if ( pData != NULL )
    467              {
    468                  pDestination = (uint8_t*) pData + length;
   \   00000010   0x18C0             ADDS     R0,R0,R3
   \   00000012   0x9003             STR      R0,[SP, #+12]
   \   00000014   0xE002             B        ??GatherData_1
    469              }
    470              else
    471              {
    472                  destinationPointer = s_sectorHead + length;
   \                     ??GatherData_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable17
   \   00000018   0x8E00             LDRH     R0,[R0, #+48]
   \   0000001A   0x18C7             ADDS     R7,R0,R3
    473              }
    474          
    475              BlockHeader_t blockHeader;
    476              uint16_t blockStart;
    477              uint16_t blockEnd;
    478              uint16_t count;
    479          
    480              // start with the last written block
    481              uint16_t currentBlockPointer = lastBlockPointer;
   \                     ??GatherData_1: (+1)
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x8E80             LDRH     R0,[R0, #+52]
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x8108             STRH     R0,[R1, #+8]
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x8F00             LDRH     R0,[R0, #+56]
   \   00000028   0x9001             STR      R0,[SP, #+4]
    482          
    483              // [readStart, readEnd> is the range of data that can be read during the current
    484              // pass over the blocks (the range includes readStart, but not readEnd).
    485              // it is initialized with the requested range
    486              uint16_t readStart = offset;
    487              uint16_t readEnd = offset + length;
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x8F00             LDRH     R0,[R0, #+56]
   \   0000002E   0x18C0             ADDS     R0,R0,R3
   \   00000030   0xB280             UXTH     R0,R0
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0xE00B             B        ??GatherData_2
    488          
    489              // continue until we have all the data that was requested
    490              while ( readStart != readEnd )
    491              {
    492                  // find the block that contains the **last byte** that we want to read.
    493                  for ( ;; )
    494                  {
    495                      if ( currentBlockPointer == 0x0000u )
    496                      {
    497                          // reached first block without finding the data.
    498                          // either the flash is corrupt, or this is a read beyond the item length
    499                          return FALSE;
    500                      }
    501          
    502                      // get the header of the current block
    503                      D_Nv_Read(sourceSector, currentBlockPointer, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
    504          
    505                      // [blockStart, blockEnd> is the range of bytes in this block
    506                      blockStart = blockHeader.blockOffset;
    507                      blockEnd = blockHeader.blockOffset + blockHeader.blockLength;
    508          
    509                      if ( (readEnd <= blockStart) || (readStart >= blockEnd) )
    510                      {
    511                          // this block does not contain any bytes that we want to read.
    512                          // continue with previous written block...
    513                      }
    514                      else if ( readEnd > blockEnd )
    515                      {
    516                          // this block contains some bytes that we want to read, but not the last byte.
    517                          // adjust the read range to prevent reading an older version of these bytes
    518                          readStart = blockEnd;
    519                          // continue with previous written block...
    520                      }
    521                      else
    522                      {
    523                          // this block contains the last byte that we want to read.
    524                          // read all data that we can from this block...
    525                          break;
    526                      }
    527          
    528                      // ...continue with previous written block
    529                      currentBlockPointer = blockHeader.previousBlock;
    530                  }
    531          
    532                  // ...read all data that we can from this block
    533          
    534                  // pointer to the last byte that we want to read
    535                  uint16_t sourcePointer = (currentBlockPointer + BLOCK_HEADER_SIZE) + (readEnd - blockStart);
    536          
    537                  // check how many of the bytes that we want are in this block
    538                  if ( readStart < blockStart )
    539                  {
    540                      // the block does not contain all data we want to read this pass
    541                      count = readEnd - blockStart;
    542          
    543                      // continue with the current pass after reading this block
    544                      currentBlockPointer = blockHeader.previousBlock;
    545                  }
    546                  else
    547                  {
    548                      // the block contains all data we want to read this pass
    549                      count = readEnd - readStart;
    550          
    551                      // start with a new pass after reading this block (unless we have all requested data)
    552                      currentBlockPointer = lastBlockPointer;
    553                      readStart = offset;
    554                  }
    555                  readEnd -= count;
    556          
    557                  // read the data that we want from the source sector
    558                  if ( pDestination != NULL )
    559                  {
    560                      // this is for a read operation, so copy to buffer in RAM
    561                      sourcePointer -= count;
    562                      pDestination -= count;
   \                     ??GatherData_3: (+1)
   \   00000036   0x9803             LDR      R0,[SP, #+12]
   \   00000038   0xB2A4             UXTH     R4,R4
   \   0000003A   0x1B00             SUBS     R0,R0,R4
   \   0000003C   0x9003             STR      R0,[SP, #+12]
    563                      D_Nv_Read(s_sector, sourcePointer, pDestination, count);
   \   0000003E   0x0023             MOVS     R3,R4
   \   00000040   0x9A03             LDR      R2,[SP, #+12]
   \   00000042   0x1B29             SUBS     R1,R5,R4
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0x....             LDR      R0,??DataTable17
   \   00000048   0x7D00             LDRB     R0,[R0, #+20]
   \   0000004A   0x.... 0x....      BL       D_Nv_Read_Impl
    564                  }
   \                     ??GatherData_2: (+1)
   \   0000004E   0x9801             LDR      R0,[SP, #+4]
   \   00000050   0x9900             LDR      R1,[SP, #+0]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD107             BNE      ??GatherData_4
    565                  else
    566                  {
    567                      // this is for a compact operation, so copy to the destination sector in flash
    568                      while ( count > 0u )
    569                      {
    570                          uint8_t buffer[16];
    571                          uint16_t c;
    572                          if ( count > sizeof(buffer) )
    573                          {
    574                              c = sizeof(buffer);
    575                              count -= (uint16_t) sizeof(buffer);
    576                          }
    577                          else
    578                          {
    579                              c = count;
    580                              count = 0u;
    581                          }
    582          
    583                          destinationPointer -= c;
    584                          sourcePointer -= c;
    585                          D_Nv_Read(sourceSector, sourcePointer, buffer, c);
    586                          if ( !WriteAndCheck(destinationPointer, buffer, c) )
    587                          {
    588                              return FALSE;
    589                          }
    590                      }
    591                  }
    592              }
    593          
    594              return TRUE;
   \   00000056   0x2001             MOVS     R0,#+1
   \                     ??GatherData_5: (+1)
   \   00000058   0xB00F             ADD      SP,SP,#+60
   \   0000005A   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??GatherData_6: (+1)
   \   0000005C   0x9101             STR      R1,[SP, #+4]
   \                     ??GatherData_7: (+1)
   \   0000005E   0xA804             ADD      R0,SP,#+16
   \   00000060   0x8940             LDRH     R0,[R0, #+10]
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x8108             STRH     R0,[R1, #+8]
   \                     ??GatherData_4: (+1)
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x8900             LDRH     R0,[R0, #+8]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD04A             BEQ      ??GatherData_8
   \   0000006E   0x2310             MOVS     R3,#+16
   \   00000070   0xAA04             ADD      R2,SP,#+16
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x8901             LDRH     R1,[R0, #+8]
   \   00000076   0xA80C             ADD      R0,SP,#+48
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x.... 0x....      BL       D_Nv_Read_Impl
   \   0000007E   0xA804             ADD      R0,SP,#+16
   \   00000080   0x8880             LDRH     R0,[R0, #+4]
   \   00000082   0xA904             ADD      R1,SP,#+16
   \   00000084   0x88C9             LDRH     R1,[R1, #+6]
   \   00000086   0x1841             ADDS     R1,R0,R1
   \   00000088   0x9A00             LDR      R2,[SP, #+0]
   \   0000008A   0x4290             CMP      R0,R2
   \   0000008C   0xDAE7             BGE      ??GatherData_7
   \   0000008E   0xB289             UXTH     R1,R1
   \   00000090   0x9B01             LDR      R3,[SP, #+4]
   \   00000092   0x428B             CMP      R3,R1
   \   00000094   0xDAE3             BGE      ??GatherData_7
   \   00000096   0x4291             CMP      R1,R2
   \   00000098   0xDBE0             BLT      ??GatherData_6
   \   0000009A   0x4669             MOV      R1,SP
   \   0000009C   0x8909             LDRH     R1,[R1, #+8]
   \   0000009E   0x1889             ADDS     R1,R1,R2
   \   000000A0   0x3110             ADDS     R1,R1,#+16
   \   000000A2   0x1A0D             SUBS     R5,R1,R0
   \   000000A4   0x4283             CMP      R3,R0
   \   000000A6   0xDA05             BGE      ??GatherData_9
   \   000000A8   0x1A14             SUBS     R4,R2,R0
   \   000000AA   0xA804             ADD      R0,SP,#+16
   \   000000AC   0x8940             LDRH     R0,[R0, #+10]
   \   000000AE   0x4669             MOV      R1,SP
   \   000000B0   0x8108             STRH     R0,[R1, #+8]
   \   000000B2   0xE007             B        ??GatherData_10
   \                     ??GatherData_9: (+1)
   \   000000B4   0x1AD4             SUBS     R4,R2,R3
   \   000000B6   0x4668             MOV      R0,SP
   \   000000B8   0x8E80             LDRH     R0,[R0, #+52]
   \   000000BA   0x4669             MOV      R1,SP
   \   000000BC   0x8108             STRH     R0,[R1, #+8]
   \   000000BE   0x4668             MOV      R0,SP
   \   000000C0   0x8F00             LDRH     R0,[R0, #+56]
   \   000000C2   0x9001             STR      R0,[SP, #+4]
   \                     ??GatherData_10: (+1)
   \   000000C4   0x1B10             SUBS     R0,R2,R4
   \   000000C6   0xB280             UXTH     R0,R0
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x9803             LDR      R0,[SP, #+12]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD1B2             BNE      ??GatherData_3
   \                     ??GatherData_11: (+1)
   \   000000D0   0xB2A4             UXTH     R4,R4
   \   000000D2   0x2C00             CMP      R4,#+0
   \   000000D4   0xD0BB             BEQ      ??GatherData_2
   \   000000D6   0x2C11             CMP      R4,#+17
   \   000000D8   0xD302             BCC      ??GatherData_12
   \   000000DA   0x2610             MOVS     R6,#+16
   \   000000DC   0x3C10             SUBS     R4,R4,#+16
   \   000000DE   0xE001             B        ??GatherData_13
   \                     ??GatherData_12: (+1)
   \   000000E0   0x0026             MOVS     R6,R4
   \   000000E2   0x2400             MOVS     R4,#+0
   \                     ??GatherData_13: (+1)
   \   000000E4   0x1BBF             SUBS     R7,R7,R6
   \   000000E6   0x1BAD             SUBS     R5,R5,R6
   \   000000E8   0x0033             MOVS     R3,R6
   \   000000EA   0xAA08             ADD      R2,SP,#+32
   \   000000EC   0xB2A9             UXTH     R1,R5
   \   000000EE   0xA80C             ADD      R0,SP,#+48
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x.... 0x....      BL       D_Nv_Read_Impl
   \   000000F6   0x0032             MOVS     R2,R6
   \   000000F8   0xA908             ADD      R1,SP,#+32
   \   000000FA   0xB2B8             UXTH     R0,R7
   \   000000FC   0x.... 0x....      BL       WriteAndCheck
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD1E5             BNE      ??GatherData_11
   \                     ??GatherData_8: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xE7A7             B        ??GatherData_5
    595          }
    596          

   \                                 In section .text, align 2, keep-with-next
    597          static bool InitSector(uint32_t sequenceNumber)
    598          {
   \                     InitSector: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
    599              // make sure the sector is completely erased
    600              if ( !D_Nv_IsEmpty(s_sector, 0u, SECTOR_SIZE) )
   \   00000004   0x....             LDR      R4,??DataTable17
   \   00000006   0x2680             MOVS     R6,#+128
   \   00000008   0x01B6             LSLS     R6,R6,#+6        ;; #+8192
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000010   0x.... 0x....      BL       D_Nv_IsEmpty_Impl
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD109             BNE      ??InitSector_0
    601              {
    602                  D_Nv_EraseSector(s_sector);
   \   00000018   0x7D20             LDRB     R0,[R4, #+20]
   \   0000001A   0x.... 0x....      BL       D_Nv_EraseSector_Impl
    603                  // check if the erase succeeded
    604                  if ( !D_Nv_IsEmpty(s_sector, 0u, SECTOR_SIZE) )
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7D20             LDRB     R0,[R4, #+20]
   \   00000024   0x.... 0x....      BL       D_Nv_IsEmpty_Impl
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD01D             BEQ      ??InitSector_1
    605                  {
    606                      return FALSE;
    607                  }
    608              }
    609          
    610              // write sector header
    611              SectorHeader_t sectorHeader;
    612              sectorHeader.isActive = 0xFFFFu;
   \                     ??InitSector_0: (+1)
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x....             LDR      R1,??DataTable15  ;; 0xffff
   \   00000030   0x8001             STRH     R1,[R0, #+0]
    613              sectorHeader.signature[0] = (uint8_t) 'A';
   \   00000032   0x2141             MOVS     R1,#+65
   \   00000034   0x7081             STRB     R1,[R0, #+2]
    614              sectorHeader.signature[1] = (uint8_t) 'T';
   \   00000036   0x2154             MOVS     R1,#+84
   \   00000038   0x70C1             STRB     R1,[R0, #+3]
    615              sectorHeader.signature[2] = (uint8_t) 'S';
   \   0000003A   0x2153             MOVS     R1,#+83
   \   0000003C   0x7101             STRB     R1,[R0, #+4]
    616              sectorHeader.signature[3] = (uint8_t) 'N';
   \   0000003E   0x214E             MOVS     R1,#+78
   \   00000040   0x7141             STRB     R1,[R0, #+5]
    617              sectorHeader.signature[4] = (uint8_t) 'v';
   \   00000042   0x2176             MOVS     R1,#+118
   \   00000044   0x7181             STRB     R1,[R0, #+6]
    618              sectorHeader.signature[5] = (uint8_t) '1';
   \   00000046   0x2131             MOVS     R1,#+49
   \   00000048   0x71C1             STRB     R1,[R0, #+7]
    619              sectorHeader.sequenceNumber = sequenceNumber;
   \   0000004A   0x9502             STR      R5,[SP, #+8]
    620              sectorHeader.sequenceParity = sequenceNumber ^ 0xFFFFFFFFuL;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000050   0x4068             EORS     R0,R0,R5
   \   00000052   0x9003             STR      R0,[SP, #+12]
    621              if ( !WriteAndCheck(0u, (uint8_t*) &sectorHeader, SECTOR_HEADER_SIZE) )
   \   00000054   0x2210             MOVS     R2,#+16
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       WriteAndCheck
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD002             BEQ      ??InitSector_1
    622              {
    623                  return FALSE;
    624              }
    625          
    626              s_sectorHead = SECTOR_HEADER_SIZE;
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0x8620             STRH     R0,[R4, #+48]
    627          
    628              return TRUE;
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??InitSector_1: (+1)
   \   00000068   0xB004             ADD      SP,SP,#+16
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
    629          }
    630          

   \                                 In section .text, align 2, keep-with-next
    631          static bool ActivateSector(void)
    632          {
   \                     ActivateSector: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    633              // activate sector header
    634              uint16_t isActive = 0x0000u;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    635              if ( !WriteAndCheck(0u, (uint8_t*) &isActive, sizeof(uint16_t)) )
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A                      REQUIRE ?Subroutine0
   \   0000000A                      ;; // Fall through to label ?Subroutine0
    636              {
    637                  return FALSE;
    638              }
    639              else
    640              {
    641                  return TRUE;
    642              }
    643          }
    644          
    645          static void LoadSector(void)
    646          {
    647              // start after the sector header
    648              s_sectorHead = SECTOR_HEADER_SIZE;
    649          
    650              // Done when sectorhead reaches end of sector
    651              while ( s_sectorHead < SECTOR_SIZE )
    652              {
    653                  BlockHeader_t blockHeader;
    654                  D_Nv_Read(s_sector, s_sectorHead, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
    655          
    656                  if ( IsEmpty((uint8_t*) &blockHeader, BLOCK_HEADER_SIZE) )
    657                  {
    658                      // no header. done
    659                      break;
    660                  }
    661                  else if ( blockHeader.headerCrc != ComputeHeaderCrc(&blockHeader) )
    662                  {
    663                      // invalid header. skip header
    664                      UpdateSectorHead(BLOCK_HEADER_SIZE);
    665                  }
    666                  else if ( blockHeader.isActive != 0x0000u )
    667                  {
    668                      // inactive header. skip header and data
    669                      UpdateSectorHead(BLOCK_HEADER_SIZE + blockHeader.blockLength);
    670                  }
    671                  else
    672                  {
    673                      // Try to find cache for current ID -- if none found, it's a new item!
    674                      uint16_t id = blockHeader.id;
    675                      Item_t *cache = FindItemCache(id);
    676          
    677                      if (cache == NULL)
    678                      {
    679                          cache = CreateItemCache(id);
    680                      }
    681          
    682                      cache->lastBlock = s_sectorHead;
    683          
    684                      // If item length is zero, the item had been deleted -- remove the cache
    685                      if ( blockHeader.itemLength == 0u )
    686                      {
    687                          DeleteItemCache(id);
    688                      }
    689          
    690                      UpdateSectorHead(BLOCK_HEADER_SIZE + blockHeader.blockLength);
    691                  }
    692              }
    693          }
    694          
    695          /* Important: if CompactSector fails, the only fix is to reinitialize!
    696           * This is because the itemCache, sector head and sector selector will
    697           * be messed up.
    698           */

   \                                 In section .text, align 2, keep-with-next
    699          static bool CompactSector(void)
    700          {
   \                     CompactSector: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    701          #if defined(ENABLE_NV_COMPACT_LOGGING)
    702              N_LOG_ALWAYS(("CompactSector(s=%hu)", s_sector));
    703          #endif
    704              // stop timer for preemptive compact sector as this will not be needed any more
    705              SYS_StopTimer(&compactSectorTimer);
   \   00000004   0x....             LDR      R5,??DataTable17
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x3018             ADDS     R0,R0,#+24
   \   0000000A   0x.... 0x....      BL       SYS_StopTimer
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x8668             STRH     R0,[R5, #+50]
    706          
    707              // stop the compact item as a compact sector will compact all items
    708              s_compactItemId = 0u;
    709              s_compactItemLength = 0u;
   \   00000012   0x86A8             STRH     R0,[R5, #+52]
    710          
    711              uint8_t sourceSector = s_sector;
   \   00000014   0x7D28             LDRB     R0,[R5, #+20]
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x7108             STRB     R0,[R1, #+4]
    712          
    713              // get the sector header for the source sector
    714              SectorHeader_t sectorHeader;
    715              D_Nv_Read(sourceSector, 0u, (uint8_t*) &sectorHeader, SECTOR_HEADER_SIZE);
   \   0000001A   0x2310             MOVS     R3,#+16
   \   0000001C   0xAA06             ADD      R2,SP,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x7900             LDRB     R0,[R0, #+4]
   \   00000024   0x.... 0x....      BL       D_Nv_Read_Impl
    716          
    717              uint32_t nextSequenceNumber = sectorHeader.sequenceNumber - 1uL;
   \   00000028   0x9E08             LDR      R6,[SP, #+32]
   \   0000002A   0x1E76             SUBS     R6,R6,#+1
   \   0000002C   0x....             LDR      R4,??DataTable18
    718          
    719              // find and prepare a destination sector
    720              do
    721              {
    722                  s_sector++;
   \                     ??CompactSector_0: (+1)
   \   0000002E   0x7D28             LDRB     R0,[R5, #+20]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
    723                  if ( s_sector >= (FIRST_SECTOR + SECTOR_COUNT) )
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xDB00             BLT      ??CompactSector_1
    724                  {
    725                      s_sector = FIRST_SECTOR;
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??CompactSector_1: (+1)
   \   0000003A   0x7528             STRB     R0,[R5, #+20]
    726                  }
    727          
    728                  if ( s_sector == sourceSector )
   \   0000003C   0x7D28             LDRB     R0,[R5, #+20]
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x7909             LDRB     R1,[R1, #+4]
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD103             BNE      ??CompactSector_2
    729                  {
    730                      // all sector failed to initialize
    731                      N_ERRH_FATAL();
   \   00000046   0x....             LDR      R1,??DataTable18_1  ;; 0x2db
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       N_ErrH_Fatal
    732                  }
    733              }
    734              while ( !InitSector(nextSequenceNumber) );
   \                     ??CompactSector_2: (+1)
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       InitSector
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0EA             BEQ      ??CompactSector_0
    735          
    736              // Traverse the item cache, writing all items to the new sector
    737              for (uint8_t cacheIndex = 0; cacheIndex < s_itemCount; cacheIndex++) {
   \   00000058   0x2600             MOVS     R6,#+0
   \   0000005A   0xAF02             ADD      R7,SP,#+8
   \   0000005C   0xE005             B        ??CompactSector_3
    738                  Item_t *cache = &s_itemCache[cacheIndex];
    739          
    740                  // Start by reading out header of last block
    741                  BlockHeader_t blockHeader;
    742                  D_Nv_Read(sourceSector, cache->lastBlock, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
    743          
    744                  // Construct header for a single block with contiguous data
    745                  blockHeader.blockOffset = 0x0000u;
    746                  blockHeader.blockLength = blockHeader.itemLength;
    747                  blockHeader.previousBlock = 0x0000u;
    748                  blockHeader.writeCount = 0u;
    749          
    750                  uint16_t blockPointer = s_sectorHead;
    751          
    752                  // Now write the data block header, move its data and activate
    753                  if ( !WriteBlockHeader(&blockHeader) )
    754                  {
    755                      return FALSE;
    756                  }
    757          
    758                  if ( !GatherData(sourceSector, cache->lastBlock, 0u, blockHeader.itemLength, NULL) )
    759                  {
    760                      return FALSE;
    761                  }
    762          
    763                  UpdateSectorHead(blockHeader.blockLength);
    764          
    765                  if ( !ActivateBlock(blockPointer) )
    766                  {
    767                      return FALSE;
    768                  }
    769          
    770                  cache->lastBlock = blockPointer;
   \                     ??CompactSector_4: (+1)
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x88C0             LDRH     R0,[R0, #+6]
   \   00000062   0x70A0             STRB     R0,[R4, #+2]
   \   00000064   0x0A00             LSRS     R0,R0,#+8
   \   00000066   0x70E0             STRB     R0,[R4, #+3]
   \   00000068   0x1C76             ADDS     R6,R6,#+1
   \                     ??CompactSector_3: (+1)
   \   0000006A   0x7D68             LDRB     R0,[R5, #+21]
   \   0000006C   0xB2F6             UXTB     R6,R6
   \   0000006E   0x4286             CMP      R6,R0
   \   00000070   0xD235             BCS      ??CompactSector_5
   \   00000072   0x....             LDR      R0,??DataTable18_2
   \   00000074   0x00B1             LSLS     R1,R6,#+2
   \   00000076   0x1844             ADDS     R4,R0,R1
   \   00000078   0x78A1             LDRB     R1,[R4, #+2]
   \   0000007A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000007C   0x0600             LSLS     R0,R0,#+24
   \   0000007E   0x0C00             LSRS     R0,R0,#+16
   \   00000080   0x4301             ORRS     R1,R1,R0
   \   00000082   0x2310             MOVS     R3,#+16
   \   00000084   0xAA02             ADD      R2,SP,#+8
   \   00000086   0x4668             MOV      R0,SP
   \   00000088   0x7900             LDRB     R0,[R0, #+4]
   \   0000008A   0x.... 0x....      BL       D_Nv_Read_Impl
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x80B8             STRH     R0,[R7, #+4]
   \   00000092   0x8938             LDRH     R0,[R7, #+8]
   \   00000094   0x80F8             STRH     R0,[R7, #+6]
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x8178             STRH     R0,[R7, #+10]
   \   0000009A   0x81B8             STRH     R0,[R7, #+12]
   \   0000009C   0x8E28             LDRH     R0,[R5, #+48]
   \   0000009E   0x4669             MOV      R1,SP
   \   000000A0   0x80C8             STRH     R0,[R1, #+6]
   \   000000A2   0xA802             ADD      R0,SP,#+8
   \   000000A4   0x.... 0x....      BL       WriteBlockHeader
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD026             BEQ      ??CompactSector_6
   \   000000AC   0x78A1             LDRB     R1,[R4, #+2]
   \   000000AE   0x78E0             LDRB     R0,[R4, #+3]
   \   000000B0   0x0600             LSLS     R0,R0,#+24
   \   000000B2   0x0C00             LSRS     R0,R0,#+16
   \   000000B4   0x4301             ORRS     R1,R1,R0
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x9000             STR      R0,[SP, #+0]
   \   000000BA   0x893B             LDRH     R3,[R7, #+8]
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x4668             MOV      R0,SP
   \   000000C0   0x7900             LDRB     R0,[R0, #+4]
   \   000000C2   0x.... 0x....      BL       GatherData
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD017             BEQ      ??CompactSector_6
   \   000000CA   0x88F8             LDRH     R0,[R7, #+6]
   \   000000CC   0x.... 0x....      BL       UpdateSectorHead
   \   000000D0   0x4668             MOV      R0,SP
   \   000000D2   0x88C0             LDRH     R0,[R0, #+6]
   \   000000D4   0x.... 0x....      BL       ActivateBlock
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD1C0             BNE      ??CompactSector_4
   \   000000DC   0xE00D             B        ??CompactSector_6
    771              }
    772          
    773              // All items moved, so now we just need to activate the sector
    774              if ( !ActivateSector() )
   \                     ??CompactSector_5: (+1)
   \   000000DE   0x.... 0x....      BL       ActivateSector
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD009             BEQ      ??CompactSector_6
    775              {
    776                  return FALSE;
    777              }
    778          
    779              // schedule an erase of the source sector,Restart the timer if it is already running.
    780              s_sectorToErase = sourceSector;
   \   000000E6   0x4668             MOV      R0,SP
   \   000000E8   0x7900             LDRB     R0,[R0, #+4]
   \   000000EA   0x75A8             STRB     R0,[R5, #+22]
    781              HAL_StopAppTimer(&eraseSectorTimer);
   \   000000EC   0x0028             MOVS     R0,R5
   \   000000EE   0x.... 0x....      BL       HAL_StopAppTimer
    782              HAL_StartAppTimer(&eraseSectorTimer);
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0x.... 0x....      BL       HAL_StartAppTimer
    783          
    784              return TRUE;
   \   000000F8   0x2001             MOVS     R0,#+1
   \                     ??CompactSector_6: (+1)
   \   000000FA   0xB00B             ADD      SP,SP,#+44
   \   000000FC   0xBDF0             POP      {R4-R7,PC}       ;; return
    785          }
    786          

   \                                 In section .text, align 2, keep-with-next
    787          static void CompactSectorIfNeeded(uint16_t immediateThreshold)
    788          {
   \                     CompactSectorIfNeeded: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    789              uint16_t freeSpace = SECTOR_SIZE - s_sectorHead;
   \   00000004   0x....             LDR      R0,??DataTable17
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0192             LSLS     R2,R2,#+6        ;; #+8192
   \   0000000A   0x8E03             LDRH     R3,[R0, #+48]
   \   0000000C   0x1AD2             SUBS     R2,R2,R3
   \   0000000E   0xB292             UXTH     R2,R2
    790          
    791              if ( freeSpace < immediateThreshold )
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xDA08             BGE      ??CompactSectorIfNeeded_0
    792              {
    793                  if ( !CompactSector() )
   \   00000014   0x.... 0x....      BL       CompactSector
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD111             BNE      ??CompactSectorIfNeeded_1
    794                  {
    795                      N_ERRH_FATAL();
   \   0000001C   0x....             LDR      R1,??DataTable20  ;; 0x31b
   \   0000001E   0x....             LDR      R0,??DataTable18
   \   00000020   0x.... 0x....      BL       N_ErrH_Fatal
    796                  }
    797                  return;
   \   00000024   0xBD01             POP      {R0,PC}
    798              }
    799              if ( freeSpace < PREEMPTIVE_COMPACT_SECTOR_THRESHOLD )
   \                     ??CompactSectorIfNeeded_0: (+1)
   \   00000026   0x2182             MOVS     R1,#+130
   \   00000028   0x00C9             LSLS     R1,R1,#+3        ;; #+1040
   \   0000002A   0x428A             CMP      R2,R1
   \   0000002C   0xD208             BCS      ??CompactSectorIfNeeded_1
    800              {
    801                  if (SYS_TIMER_STOPPED == compactSectorTimer.state)
   \   0000002E   0x7E01             LDRB     R1,[R0, #+24]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD105             BNE      ??CompactSectorIfNeeded_1
    802                      SYS_InitTimer(&compactSectorTimer, TIMER_ONE_SHOT_MODE, COMPACT_SECTOR_DELAY_MS, compactSectorTimerFired);
   \   00000034   0x....             LDR      R3,??DataTable20_1
   \   00000036   0x....             LDR      R2,??DataTable20_2  ;; 0x2710
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x3018             ADDS     R0,R0,#+24
   \   0000003C   0x.... 0x....      BL       SYS_InitTimer
    803              }
    804          }
   \                     ??CompactSectorIfNeeded_1: (+1)
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    805          

   \                                 In section .text, align 4, keep-with-next
    806          static S_Nv_ReturnValue_t CompactItem(void)
    807          {
   \                     CompactItem: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    808          #if defined(ENABLE_NV_COMPACT_LOGGING)
    809              N_LOG_ALWAYS(("CompactItem(id=%Xh)", s_compactItemId));
    810          #endif
    811          
    812              if ( PowerSupplyTooLow() )
   \   00000004   0x.... 0x....      BL       PowerSupplyTooLow
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ      ??CompactItem_0
    813              {
    814                  return S_Nv_ReturnValue_PowerSupplyTooLow;
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0xE082             B        ??CompactItem_1
    815              }
    816          
    817              if ( (s_compactItemLength == 0u) && ( s_compactItemId == 0u ) )
   \                     ??CompactItem_0: (+1)
   \   00000010   0x....             LDR      R5,??DataTable18_3
   \   00000012   0x8EA8             LDRH     R0,[R5, #+52]
   \   00000014   0x8E69             LDRH     R1,[R5, #+50]
   \   00000016   0x4301             ORRS     R1,R1,R0
   \   00000018   0xD07C             BEQ      ??CompactItem_2
    818              {
    819                  // compact sector was performed since the compact item was
    820                  // scheduled, so there is no need for another compact item unless
    821                  // a resize of an item is needed.
    822                  return S_Nv_ReturnValue_Ok;
    823              }
    824          
    825              if (s_compactItemLength != 0)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ      ??CompactItem_3
    826                  CompactSectorIfNeeded(s_compactItemLength + BLOCK_HEADER_SIZE);
   \   0000001E   0x3010             ADDS     R0,R0,#+16
   \   00000020   0xB280             UXTH     R0,R0
   \   00000022   0x.... 0x....      BL       CompactSectorIfNeeded
    827          
    828              Item_t *cache = FindItemCache(s_compactItemId);
   \                     ??CompactItem_3: (+1)
   \   00000026   0x8E68             LDRH     R0,[R5, #+50]
   \   00000028   0x.... 0x....      BL       FindItemCache
   \   0000002C   0x0004             MOVS     R4,R0
    829              if ( cache == NULL )
   \   0000002E   0xD071             BEQ      ??CompactItem_2
    830              {
    831                  // trying to compact a non-existing item (item may have been deleted)
    832                  return S_Nv_ReturnValue_Ok;
    833              }
    834          
    835              uint16_t blockPointer = cache->lastBlock;
   \                     ??CompactItem_4: (+1)
   \   00000030   0x78A0             LDRB     R0,[R4, #+2]
   \   00000032   0x78E1             LDRB     R1,[R4, #+3]
   \   00000034   0x0609             LSLS     R1,R1,#+24
   \   00000036   0x0C09             LSRS     R1,R1,#+16
   \   00000038   0x4308             ORRS     R0,R0,R1
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x8088             STRH     R0,[R1, #+4]
    836          
    837              BlockHeader_t blockHeader;
    838              // read last written item block header
    839              D_Nv_Read(s_sector, blockPointer, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
   \   0000003E   0x2310             MOVS     R3,#+16
   \   00000040   0xAA03             ADD      R2,SP,#+12
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x8881             LDRH     R1,[R0, #+4]
   \   00000046   0x7D28             LDRB     R0,[R5, #+20]
   \   00000048   0x.... 0x....      BL       D_Nv_Read_Impl
    840          
    841              if (s_compactItemLength == 0)
   \   0000004C   0x....             LDR      R7,??DataTable18
   \   0000004E   0xAE03             ADD      R6,SP,#+12
   \   00000050   0x8EA8             LDRH     R0,[R5, #+52]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD11B             BNE      ??CompactItem_5
    842              {
    843                  CompactSectorIfNeeded(blockHeader.itemLength + BLOCK_HEADER_SIZE);
   \   00000056   0x8930             LDRH     R0,[R6, #+8]
   \   00000058   0x3010             ADDS     R0,R0,#+16
   \   0000005A   0xB280             UXTH     R0,R0
   \   0000005C   0x.... 0x....      BL       CompactSectorIfNeeded
    844          
    845                  cache = FindItemCache(s_compactItemId);
   \   00000060   0x8E68             LDRH     R0,[R5, #+50]
   \   00000062   0x.... 0x....      BL       FindItemCache
   \   00000066   0x0004             MOVS     R4,R0
    846                  N_ERRH_ASSERT_FATAL(cache != NULL);
   \   00000068   0xD103             BNE      ??CompactItem_6
   \   0000006A   0x....             LDR      R1,??DataTable21  ;; 0x34e
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       N_ErrH_Fatal
    847                  blockPointer = cache->lastBlock;
   \                     ??CompactItem_6: (+1)
   \   00000072   0x78A0             LDRB     R0,[R4, #+2]
   \   00000074   0x78E1             LDRB     R1,[R4, #+3]
   \   00000076   0x0609             LSLS     R1,R1,#+24
   \   00000078   0x0C09             LSRS     R1,R1,#+16
   \   0000007A   0x4308             ORRS     R0,R0,R1
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0x8088             STRH     R0,[R1, #+4]
    848                  // read last written item block header
    849                  D_Nv_Read(s_sector, blockPointer, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
   \   00000080   0x2310             MOVS     R3,#+16
   \   00000082   0xAA03             ADD      R2,SP,#+12
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x8881             LDRH     R1,[R0, #+4]
   \   00000088   0x7D28             LDRB     R0,[R5, #+20]
   \   0000008A   0x.... 0x....      BL       D_Nv_Read_Impl
    850              }
    851          
    852              uint16_t lastBlock = s_sectorHead;
   \                     ??CompactItem_5: (+1)
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x8E29             LDRH     R1,[R5, #+48]
   \   00000092   0x8101             STRH     R1,[R0, #+8]
    853          
    854              // write the block header to the destination sector. all data will be merged into one block
    855              uint16_t bytesToGather = blockHeader.itemLength;
   \   00000094   0x8931             LDRH     R1,[R6, #+8]
   \   00000096   0x80C1             STRH     R1,[R0, #+6]
    856              if ( s_compactItemLength != 0u )
   \   00000098   0x8EA8             LDRH     R0,[R5, #+52]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD013             BEQ      ??CompactItem_7
    857              {
    858                  N_LOG_ALWAYS(("Resizing NV item (id=%hu) from %hu to %hu", s_compactItemId, blockHeader.itemLength, s_compactItemLength));
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x2104             MOVS     R1,#+4
   \   000000A2   0x0038             MOVS     R0,R7
   \   000000A4   0x.... 0x....      BL       N_Log_Prepare
   \   000000A8   0x8EAB             LDRH     R3,[R5, #+52]
   \   000000AA   0x8932             LDRH     R2,[R6, #+8]
   \   000000AC   0x8E69             LDRH     R1,[R5, #+50]
   \   000000AE   0xBF00             Nop      
   \   000000B0   0x....             ADR.N    R0,?_1
   \   000000B2   0x.... 0x....      BL       N_Log_Trace
    859          
    860                  // Change the length of the item
    861                  blockHeader.itemLength = s_compactItemLength;
   \   000000B6   0x8EA8             LDRH     R0,[R5, #+52]
   \   000000B8   0x8130             STRH     R0,[R6, #+8]
    862          
    863                  if ( bytesToGather > blockHeader.itemLength )
   \   000000BA   0x4669             MOV      R1,SP
   \   000000BC   0x88C9             LDRH     R1,[R1, #+6]
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xD201             BCS      ??CompactItem_7
    864                  {
    865                      // Item will be truncated as the new length is smaller than the original length.
    866                      bytesToGather = blockHeader.itemLength;
   \   000000C2   0x4669             MOV      R1,SP
   \   000000C4   0x80C8             STRH     R0,[R1, #+6]
    867                  }
    868              }
    869          
    870              blockHeader.blockOffset = 0u;
   \                     ??CompactItem_7: (+1)
   \   000000C6   0x2700             MOVS     R7,#+0
   \   000000C8   0x80B7             STRH     R7,[R6, #+4]
    871              blockHeader.blockLength = blockHeader.itemLength;
   \   000000CA   0x8930             LDRH     R0,[R6, #+8]
   \   000000CC   0x80F0             STRH     R0,[R6, #+6]
    872              blockHeader.previousBlock = 0x0000u;
   \   000000CE   0x8177             STRH     R7,[R6, #+10]
    873              blockHeader.writeCount = 0u;
   \   000000D0   0x81B7             STRH     R7,[R6, #+12]
    874              if ( !WriteBlockHeader(&blockHeader) )
   \   000000D2   0xA803             ADD      R0,SP,#+12
   \   000000D4   0x.... 0x....      BL       WriteBlockHeader
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD012             BEQ      ??CompactItem_8
    875              {
    876                  N_LOG_NONFATAL();
    877                  return S_Nv_ReturnValue_Failure;
    878              }
    879          
    880              // gather all data of the item and copy it to a new block
    881              if ( !GatherData(s_sector, blockPointer, 0u, bytesToGather, NULL) )
   \   000000DC   0x9700             STR      R7,[SP, #+0]
   \   000000DE   0x4668             MOV      R0,SP
   \   000000E0   0x88C3             LDRH     R3,[R0, #+6]
   \   000000E2   0x2200             MOVS     R2,#+0
   \   000000E4   0x8881             LDRH     R1,[R0, #+4]
   \   000000E6   0x7D28             LDRB     R0,[R5, #+20]
   \   000000E8   0x.... 0x....      BL       GatherData
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD008             BEQ      ??CompactItem_8
    882              {
    883                  N_LOG_NONFATAL();
    884                  return S_Nv_ReturnValue_Failure;
    885              }
    886              UpdateSectorHead(blockHeader.blockLength);
   \   000000F0   0x88F0             LDRH     R0,[R6, #+6]
   \   000000F2   0x.... 0x....      BL       UpdateSectorHead
    887          
    888              // activate the block
    889              if ( !ActivateBlock(lastBlock) )
   \   000000F6   0x4668             MOV      R0,SP
   \   000000F8   0x8900             LDRH     R0,[R0, #+8]
   \   000000FA   0x.... 0x....      BL       ActivateBlock
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD101             BNE      ??CompactItem_9
    890              {
    891                  N_LOG_NONFATAL();
    892                  return S_Nv_ReturnValue_Failure;
   \                     ??CompactItem_8: (+1)
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0xE007             B        ??CompactItem_1
    893              }
    894          
    895              s_compactItemId = 0u;
   \                     ??CompactItem_9: (+1)
   \   00000106   0x866F             STRH     R7,[R5, #+50]
    896              s_compactItemLength = 0u;
   \   00000108   0x86AF             STRH     R7,[R5, #+52]
    897          
    898              cache->lastBlock = lastBlock;
   \   0000010A   0x4668             MOV      R0,SP
   \   0000010C   0x8900             LDRH     R0,[R0, #+8]
   \   0000010E   0x70A0             STRB     R0,[R4, #+2]
   \   00000110   0x0A00             LSRS     R0,R0,#+8
   \   00000112   0x70E0             STRB     R0,[R4, #+3]
    899          
    900              return S_Nv_ReturnValue_Ok;
   \                     ??CompactItem_2: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??CompactItem_1: (+1)
   \   00000116   0xB007             ADD      SP,SP,#+28
   \   00000118   0xBDF0             POP      {R4-R7,PC}       ;; return
    901          }
    902          
    903          /***************************************************************************************************
    904          * EXPORTED FUNCTIONS
    905          ***************************************************************************************************/
    906          

   \                                 In section .text, align 2, keep-with-next
    907          void S_Nv_EarlyInit(void)
    908          {
   \                     S_Nv_EarlyInit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x....             LDR      R4,??DataTable21_1
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7560             STRB     R0,[R4, #+21]
    909              s_itemCount = 0u;
    910          
    911              SectorHeader_t sectorHeader;
    912          
    913              uint8_t lastSector = 0xFFu;
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0x43F6             MVNS     R6,R6            ;; #-1
    914              uint32_t lastSectorSequence = 0xFFFFFFFFuL;
    915          
    916              for ( uint8_t sector = FIRST_SECTOR; sector < (FIRST_SECTOR + SECTOR_COUNT); sector++ )
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xAF05             ADD      R7,SP,#+20
    917              {
    918                  D_Nv_Read(sector, 0u, (uint8_t*) &sectorHeader, SECTOR_HEADER_SIZE);
   \                     ??S_Nv_EarlyInit_0: (+1)
   \   00000018   0x2310             MOVS     R3,#+16
   \   0000001A   0xAA05             ADD      R2,SP,#+20
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       D_Nv_Read_Impl
    919                  if ( (sectorHeader.isActive == 0x0000u) &&
    920                       (sectorHeader.signature[0] == (uint8_t) 'A') &&
    921                       (sectorHeader.signature[1] == (uint8_t) 'T') &&
    922                       (sectorHeader.signature[2] == (uint8_t) 'S') &&
    923                       (sectorHeader.signature[3] == (uint8_t) 'N') &&
    924                       (sectorHeader.signature[4] == (uint8_t) 'v') &&
    925                       (sectorHeader.signature[5] == (uint8_t) '1') &&
    926                       ((sectorHeader.sequenceNumber ^ sectorHeader.sequenceParity) == 0xFFFFFFFFuL) )
   \   00000024   0x8838             LDRH     R0,[R7, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD11D             BNE      ??S_Nv_EarlyInit_1
   \   0000002A   0x78B8             LDRB     R0,[R7, #+2]
   \   0000002C   0x2841             CMP      R0,#+65
   \   0000002E   0xD11A             BNE      ??S_Nv_EarlyInit_1
   \   00000030   0x78F8             LDRB     R0,[R7, #+3]
   \   00000032   0x2854             CMP      R0,#+84
   \   00000034   0xD117             BNE      ??S_Nv_EarlyInit_1
   \   00000036   0x7938             LDRB     R0,[R7, #+4]
   \   00000038   0x2853             CMP      R0,#+83
   \   0000003A   0xD114             BNE      ??S_Nv_EarlyInit_1
   \   0000003C   0x7978             LDRB     R0,[R7, #+5]
   \   0000003E   0x284E             CMP      R0,#+78
   \   00000040   0xD111             BNE      ??S_Nv_EarlyInit_1
   \   00000042   0x79B8             LDRB     R0,[R7, #+6]
   \   00000044   0x2876             CMP      R0,#+118
   \   00000046   0xD10E             BNE      ??S_Nv_EarlyInit_1
   \   00000048   0x79F8             LDRB     R0,[R7, #+7]
   \   0000004A   0x2831             CMP      R0,#+49
   \   0000004C   0xD10B             BNE      ??S_Nv_EarlyInit_1
   \   0000004E   0x9807             LDR      R0,[SP, #+28]
   \   00000050   0x9908             LDR      R1,[SP, #+32]
   \   00000052   0x4041             EORS     R1,R1,R0
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x43D2             MVNS     R2,R2            ;; #-1
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xD104             BNE      ??S_Nv_EarlyInit_1
    927                  {
    928                      // active sector
    929                      if ( sectorHeader.sequenceNumber < lastSectorSequence )
   \   0000005C   0x42B0             CMP      R0,R6
   \   0000005E   0xD202             BCS      ??S_Nv_EarlyInit_1
    930                      {
    931                          lastSector = sector;
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x700D             STRB     R5,[R1, #+0]
    932                          lastSectorSequence = sectorHeader.sequenceNumber;
   \   00000064   0x0006             MOVS     R6,R0
    933                      }
    934                  }
    935              }
   \                     ??S_Nv_EarlyInit_1: (+1)
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
   \   00000068   0x2D02             CMP      R5,#+2
   \   0000006A   0xDBD5             BLT      ??S_Nv_EarlyInit_0
    936          
    937              if ( lastSector == 0xFFu )
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x28FF             CMP      R0,#+255
   \   00000072   0xD11B             BNE      ??S_Nv_EarlyInit_2
    938              {
    939                  // no active sector. initialize one
    940                  s_sector = FIRST_SECTOR;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x7520             STRB     R0,[R4, #+20]
   \   00000078   0x....             LDR      R5,??DataTable24
   \   0000007A   0xE00A             B        ??S_Nv_EarlyInit_3
    941          
    942                  for ( ;; )
    943                  {
    944                      if ( InitSector(INITIAL_SECTOR_SEQUENCE_NUMBER) )
    945                      {
    946                          if ( ActivateSector() )
    947                          {
    948                              break;
    949                          }
    950                      }
    951          
    952                      s_sector++;
   \                     ??S_Nv_EarlyInit_4: (+1)
   \   0000007C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x7520             STRB     R0,[R4, #+20]
    953                      if ( s_sector >= (FIRST_SECTOR + SECTOR_COUNT) )
   \   00000082   0xB2C0             UXTB     R0,R0
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xDB04             BLT      ??S_Nv_EarlyInit_3
    954                      {
    955                          // all sectors failed to initialize
    956                          N_ERRH_FATAL();
   \   00000088   0x21EF             MOVS     R1,#+239
   \   0000008A   0x0089             LSLS     R1,R1,#+2        ;; #+956
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0x.... 0x....      BL       N_ErrH_Fatal
    957                      }
   \                     ??S_Nv_EarlyInit_3: (+1)
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x43C0             MVNS     R0,R0            ;; #-2
   \   00000096   0x.... 0x....      BL       InitSector
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD0EE             BEQ      ??S_Nv_EarlyInit_4
   \   0000009E   0x.... 0x....      BL       ActivateSector
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD0EA             BEQ      ??S_Nv_EarlyInit_4
    958                  }
    959          
    960                  s_itemCount = 0u;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7560             STRB     R0,[R4, #+21]
   \   000000AA   0xE03C             B        ??S_Nv_EarlyInit_5
    961              }
    962              else
    963              {
    964                  // load active sector
    965                  s_sector = lastSector;
   \                     ??S_Nv_EarlyInit_2: (+1)
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x7520             STRB     R0,[R4, #+20]
    966          
    967                  LoadSector();
   \   000000B2   0x2010             MOVS     R0,#+16
   \   000000B4   0x8620             STRH     R0,[R4, #+48]
   \   000000B6   0xAD01             ADD      R5,SP,#+4
   \                     ??S_Nv_EarlyInit_6: (+1)
   \   000000B8   0x2310             MOVS     R3,#+16
   \   000000BA   0xAA01             ADD      R2,SP,#+4
   \   000000BC   0x8E21             LDRH     R1,[R4, #+48]
   \   000000BE   0x7D20             LDRB     R0,[R4, #+20]
   \   000000C0   0x.... 0x....      BL       D_Nv_Read_Impl
   \   000000C4   0x2000             MOVS     R0,#+0
   \                     ??S_Nv_EarlyInit_7: (+1)
   \   000000C6   0x5C29             LDRB     R1,[R5, R0]
   \   000000C8   0x29FF             CMP      R1,#+255
   \   000000CA   0xD104             BNE      ??S_Nv_EarlyInit_8
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0xB280             UXTH     R0,R0
   \   000000D0   0x2810             CMP      R0,#+16
   \   000000D2   0xD228             BCS      ??S_Nv_EarlyInit_5
   \   000000D4   0xE7F7             B        ??S_Nv_EarlyInit_7
   \                     ??S_Nv_EarlyInit_8: (+1)
   \   000000D6   0xA801             ADD      R0,SP,#+4
   \   000000D8   0x.... 0x....      BL       ComputeHeaderCrc
   \   000000DC   0x89E9             LDRH     R1,[R5, #+14]
   \   000000DE   0x4281             CMP      R1,R0
   \   000000E0   0xD001             BEQ      ??S_Nv_EarlyInit_9
   \   000000E2   0x2010             MOVS     R0,#+16
   \   000000E4   0xE018             B        ??S_Nv_EarlyInit_10
   \                     ??S_Nv_EarlyInit_9: (+1)
   \   000000E6   0x8828             LDRH     R0,[R5, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD112             BNE      ??S_Nv_EarlyInit_11
   \   000000EC   0x886E             LDRH     R6,[R5, #+2]
   \   000000EE   0x0030             MOVS     R0,R6
   \   000000F0   0x.... 0x....      BL       FindItemCache
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD102             BNE      ??S_Nv_EarlyInit_12
   \   000000F8   0x0030             MOVS     R0,R6
   \   000000FA   0x.... 0x....      BL       CreateItemCache
   \                     ??S_Nv_EarlyInit_12: (+1)
   \   000000FE   0x8E21             LDRH     R1,[R4, #+48]
   \   00000100   0x7081             STRB     R1,[R0, #+2]
   \   00000102   0x0A09             LSRS     R1,R1,#+8
   \   00000104   0x70C1             STRB     R1,[R0, #+3]
   \   00000106   0x8928             LDRH     R0,[R5, #+8]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD102             BNE      ??S_Nv_EarlyInit_11
   \   0000010C   0x0030             MOVS     R0,R6
   \   0000010E   0x.... 0x....      BL       DeleteItemCache
   \                     ??S_Nv_EarlyInit_11: (+1)
   \   00000112   0x88E8             LDRH     R0,[R5, #+6]
   \   00000114   0x3010             ADDS     R0,R0,#+16
   \   00000116   0xB280             UXTH     R0,R0
   \                     ??S_Nv_EarlyInit_10: (+1)
   \   00000118   0x.... 0x....      BL       UpdateSectorHead
   \   0000011C   0x8E20             LDRH     R0,[R4, #+48]
   \   0000011E   0x2180             MOVS     R1,#+128
   \   00000120   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD3C8             BCC      ??S_Nv_EarlyInit_6
    968              }
    969              s_earlyInitDone = TRUE;
   \                     ??S_Nv_EarlyInit_5: (+1)
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0x75E0             STRB     R0,[R4, #+23]
    970          }
   \   0000012A   0xB009             ADD      SP,SP,#+36
   \   0000012C   0xBDF0             POP      {R4-R7,PC}       ;; return
    971          

   \                                 In section .text, align 2, keep-with-next
    972          void S_Nv_Init(void)
    973          {
   \                     S_Nv_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    974              if (!s_earlyInitDone)
   \   00000002   0x....             LDR      R4,??DataTable21_1
   \   00000004   0x7DE0             LDRB     R0,[R4, #+23]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??S_Nv_Init_0
    975              {
    976                  S_Nv_EarlyInit();
   \   0000000A   0x.... 0x....      BL       S_Nv_EarlyInit
    977              }
    978          
    979              eraseSectorTimer.mode     = TIMER_ONE_SHOT_MODE;
   \                     ??S_Nv_Init_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7320             STRB     R0,[R4, #+12]
    980              eraseSectorTimer.callback = eraseSectorTimerFired;
   \   00000012   0x....             LDR      R0,??DataTable25
   \   00000014   0x6120             STR      R0,[R4, #+16]
    981              eraseSectorTimer.interval = ERASE_SECTOR_DELAY_MS;
   \   00000016   0x....             LDR      R0,??DataTable25_1  ;; 0x1b58
   \   00000018   0x60A0             STR      R0,[R4, #+8]
    982          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    983          
    984          /** Interface function, see \ref S_Nv_ItemInit. */
    985          #if defined(S_XNV_LOGGING)
    986          static S_Nv_ReturnValue_t S_Nv_ItemInit_Original(S_Nv_ItemId_t id, uint16_t itemLength, void* pDefaultData)
    987          #else

   \                                 In section .text, align 2, keep-with-next
    988          S_Nv_ReturnValue_t S_Nv_ItemInit_Impl(S_Nv_ItemId_t id, uint16_t itemLength, void* pDefaultData)
    989          #endif
    990          {
   \                     S_Nv_ItemInit_Impl: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
    991              N_ERRH_ASSERT_FATAL((id != 0u) && (id < 0xF000u) && (itemLength <= MAX_ITEM_LENGTH));
   \   00000008   0x....             LDR      R7,??DataTable24
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD006             BEQ      ??S_Nv_ItemInit_Impl_0
   \   0000000E   0x20F0             MOVS     R0,#+240
   \   00000010   0x0200             LSLS     R0,R0,#+8        ;; #+61440
   \   00000012   0x4286             CMP      R6,R0
   \   00000014   0xD202             BCS      ??S_Nv_ItemInit_Impl_0
   \   00000016   0x....             LDR      R0,??DataTable25_2  ;; 0x401
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD303             BCC      ??S_Nv_ItemInit_Impl_1
   \                     ??S_Nv_ItemInit_Impl_0: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable25_3  ;; 0x3df
   \   0000001E   0x0038             MOVS     R0,R7
   \   00000020   0x.... 0x....      BL       N_ErrH_Fatal
    992          
    993              if ( FindItem(id) != 0x0000u )
   \                     ??S_Nv_ItemInit_Impl_1: (+1)
   \   00000024   0x....             LDR      R5,??DataTable21_1
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       FindItem
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD014             BEQ      ??S_Nv_ItemInit_Impl_2
    994              {
    995          #if (!defined(DISABLE_NV_RESIZE))
    996                  // Item is already initialized. Check if the item length has been changed.
    997                  uint16_t oldItemLength = S_Nv_ItemLength(id);
    998                  if ( oldItemLength != itemLength )
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0x.... 0x....      BL       S_Nv_ItemLength_Impl
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xD005             BEQ      ??S_Nv_ItemInit_Impl_3
    999                  {
   1000                      // Resize this item to the new length
   1001                      s_compactItemId = id;
   \   0000003A   0x866E             STRH     R6,[R5, #+50]
   1002                      s_compactItemLength = itemLength;
   \   0000003C   0x86AC             STRH     R4,[R5, #+52]
   1003          
   1004                      S_Nv_ReturnValue_t resizeResult = CompactItem();
   \   0000003E   0x.... 0x....      BL       CompactItem
   1005                      if ( resizeResult != S_Nv_ReturnValue_Ok )
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD132             BNE      ??S_Nv_ItemInit_Impl_4
   1006                      {
   1007                          return resizeResult;
   1008                      }
   1009                  }
   1010          #endif
   1011                  if (pDefaultData != NULL)
   \                     ??S_Nv_ItemInit_Impl_3: (+1)
   \   00000046   0x9804             LDR      R0,[SP, #+16]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD02F             BEQ      ??S_Nv_ItemInit_Impl_4
   1012                  {
   1013                      return S_Nv_Read(id, 0u, itemLength, pDefaultData);
   \   0000004C   0x4603             MOV      R3,R0
   \   0000004E   0x0022             MOVS     R2,R4
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x.... 0x....      BL       S_Nv_Read_Impl
   \   00000058   0xE028             B        ??S_Nv_ItemInit_Impl_4
   1014                  }
   1015                  else
   1016                  {
   1017                      return S_Nv_ReturnValue_Ok;
   1018                  }
   1019              }
   1020          
   1021              if ( PowerSupplyTooLow() )
   \                     ??S_Nv_ItemInit_Impl_2: (+1)
   \   0000005A   0x.... 0x....      BL       PowerSupplyTooLow
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ      ??S_Nv_ItemInit_Impl_5
   1022              {
   1023                  return S_Nv_ReturnValue_PowerSupplyTooLow;
   \   00000062   0x2005             MOVS     R0,#+5
   \   00000064   0xE022             B        ??S_Nv_ItemInit_Impl_4
   1024              }
   1025          
   1026              CompactSectorIfNeeded(BLOCK_HEADER_SIZE + itemLength);
   \                     ??S_Nv_ItemInit_Impl_5: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x3010             ADDS     R0,R0,#+16
   \   0000006A   0xB280             UXTH     R0,R0
   \   0000006C   0x.... 0x....      BL       CompactSectorIfNeeded
   1027          
   1028              BlockHeader_t blockHeader;
   1029          
   1030              // need to add a new item. check if possible
   1031              N_ERRH_ASSERT_FATAL(s_itemCount < MAX_ITEM_COUNT);
   \   00000070   0x7D68             LDRB     R0,[R5, #+21]
   \   00000072   0x2880             CMP      R0,#+128
   \   00000074   0xD303             BCC      ??S_Nv_ItemInit_Impl_6
   \   00000076   0x....             LDR      R1,??DataTable27  ;; 0x407
   \   00000078   0x0038             MOVS     R0,R7
   \   0000007A   0x.... 0x....      BL       N_ErrH_Fatal
   1032          
   1033              uint16_t newItemId = id;
   1034              uint16_t newItemPointer = s_sectorHead;
   \                     ??S_Nv_ItemInit_Impl_6: (+1)
   \   0000007E   0x8E2D             LDRH     R5,[R5, #+48]
   1035          
   1036              blockHeader.id = newItemId;
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x8046             STRH     R6,[R0, #+2]
   1037              blockHeader.blockOffset = 0x0000u;
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x8081             STRH     R1,[R0, #+4]
   1038              blockHeader.blockLength = itemLength;
   \   00000088   0x80C4             STRH     R4,[R0, #+6]
   1039              blockHeader.itemLength = itemLength;
   \   0000008A   0x8104             STRH     R4,[R0, #+8]
   1040              blockHeader.previousBlock = 0x0000u;
   \   0000008C   0x8141             STRH     R1,[R0, #+10]
   1041              blockHeader.writeCount = 0u;
   \   0000008E   0x8181             STRH     R1,[R0, #+12]
   1042              if ( !WriteDataBlock(&blockHeader, (uint8_t*) pDefaultData) )
   \   00000090   0x9904             LDR      R1,[SP, #+16]
   \   00000092   0x.... 0x....      BL       WriteDataBlock
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD101             BNE      ??S_Nv_ItemInit_Impl_7
   1043              {
   1044                  return S_Nv_ReturnValue_Failure;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xE006             B        ??S_Nv_ItemInit_Impl_4
   1045              }
   1046          
   1047              // After successful write, create the cache
   1048              Item_t *newItemCache = CreateItemCache(newItemId);
   \                     ??S_Nv_ItemInit_Impl_7: (+1)
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       CreateItemCache
   1049              newItemCache->lastBlock = newItemPointer;
   \   000000A4   0x7085             STRB     R5,[R0, #+2]
   \   000000A6   0x0A2D             LSRS     R5,R5,#+8
   \   000000A8   0x70C5             STRB     R5,[R0, #+3]
   1050          
   1051              return S_Nv_ReturnValue_DidNotExist;
   \   000000AA   0x2002             MOVS     R0,#+2
   \                     ??S_Nv_ItemInit_Impl_4: (+1)
   \   000000AC   0xB005             ADD      SP,SP,#+20
   \   000000AE   0xBDF0             POP      {R4-R7,PC}       ;; return
   1052          }
   1053          
   1054          /** Interface function, see \ref S_Nv_Write. */
   1055          #if defined(S_XNV_LOGGING)
   1056          static S_Nv_ReturnValue_t S_Nv_Write_Original(S_Nv_ItemId_t id, uint16_t offset, uint16_t dataLength, void* pData)
   1057          #else

   \                                 In section .text, align 4, keep-with-next
   1058          S_Nv_ReturnValue_t S_Nv_Write_Impl(S_Nv_ItemId_t id, uint16_t offset, uint16_t dataLength, void* pData)
   1059          #endif
   1060          {
   \                     S_Nv_Write_Impl: (+1)
   \   00000000   0xB5FA             PUSH     {R1,R3-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   1061              N_ERRH_ASSERT_FATAL((id != 0u) && (pData != NULL));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD001             BEQ      ??S_Nv_Write_Impl_0
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD104             BNE      ??S_Nv_Write_Impl_1
   \                     ??S_Nv_Write_Impl_0: (+1)
   \   00000010   0x....             LDR      R1,??DataTable27_1  ;; 0x425
   \   00000012   0xBF00             Nop      
   \   00000014   0x....             ADR.N    R0,?_0
   \   00000016   0x.... 0x....      BL       N_ErrH_Fatal
   1062          
   1063              if ( PowerSupplyTooLow() )
   \                     ??S_Nv_Write_Impl_1: (+1)
   \   0000001A   0x.... 0x....      BL       PowerSupplyTooLow
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ      ??S_Nv_Write_Impl_2
   1064              {
   1065                  return S_Nv_ReturnValue_PowerSupplyTooLow;
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0xE053             B        ??S_Nv_Write_Impl_3
   1066              }
   1067          
   1068              CompactSectorIfNeeded(BLOCK_HEADER_SIZE + dataLength);
   \                     ??S_Nv_Write_Impl_2: (+1)
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x3010             ADDS     R0,R0,#+16
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       CompactSectorIfNeeded
   1069          
   1070              Item_t *cache = FindItemCache(id);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       FindItemCache
   \   00000036   0x0006             MOVS     R6,R0
   1071          
   1072              // Caches will not exist for deleted or uninitialized items
   1073              if ( cache == NULL )
   \   00000038   0xD101             BNE      ??S_Nv_Write_Impl_4
   1074              {
   1075                  return S_Nv_ReturnValue_DoesNotExist;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xE047             B        ??S_Nv_Write_Impl_3
   1076              }
   1077          
   1078              uint16_t blockPointer = cache->lastBlock;
   \                     ??S_Nv_Write_Impl_4: (+1)
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x78B2             LDRB     R2,[R6, #+2]
   \   00000042   0x78F1             LDRB     R1,[R6, #+3]
   \   00000044   0x0609             LSLS     R1,R1,#+24
   \   00000046   0x0C09             LSRS     R1,R1,#+16
   \   00000048   0x430A             ORRS     R2,R2,R1
   \   0000004A   0x8002             STRH     R2,[R0, #+0]
   1079          
   1080              BlockHeader_t blockHeader;
   1081          
   1082              // read last written item block header
   1083              D_Nv_Read(s_sector, blockPointer, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
   \   0000004C   0x....             LDR      R7,??DataTable27_2
   \   0000004E   0x2310             MOVS     R3,#+16
   \   00000050   0xAA01             ADD      R2,SP,#+4
   \   00000052   0x8801             LDRH     R1,[R0, #+0]
   \   00000054   0x7D38             LDRB     R0,[R7, #+20]
   \   00000056   0x.... 0x....      BL       D_Nv_Read_Impl
   1084          
   1085              // check that we do not write beyond the length of the item
   1086              if ( ((uint32_t) offset + (uint32_t) dataLength) > (uint32_t) blockHeader.itemLength )
   \   0000005A   0xAC01             ADD      R4,SP,#+4
   \   0000005C   0x8920             LDRH     R0,[R4, #+8]
   \   0000005E   0x4669             MOV      R1,SP
   \   00000060   0x8A89             LDRH     R1,[R1, #+20]
   \   00000062   0x1949             ADDS     R1,R1,R5
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD201             BCS      ??S_Nv_Write_Impl_5
   1087              {
   1088                  return S_Nv_ReturnValue_BeyondEnd;
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0xE030             B        ??S_Nv_Write_Impl_3
   1089              }
   1090          
   1091              // write item block
   1092              blockHeader.blockOffset = offset;
   \                     ??S_Nv_Write_Impl_5: (+1)
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x8A80             LDRH     R0,[R0, #+20]
   \   00000070   0x80A0             STRH     R0,[R4, #+4]
   1093              blockHeader.blockLength = dataLength;
   \   00000072   0x80E5             STRH     R5,[R4, #+6]
   1094              blockHeader.previousBlock = blockPointer;
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x8800             LDRH     R0,[R0, #+0]
   \   00000078   0x8160             STRH     R0,[R4, #+10]
   1095              if ( blockHeader.blockLength == blockHeader.itemLength )
   \   0000007A   0x2500             MOVS     R5,#+0
   \   0000007C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000007E   0x8921             LDRH     R1,[R4, #+8]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD101             BNE      ??S_Nv_Write_Impl_6
   1096              {
   1097                  // complete write. reset counter
   1098                  blockHeader.writeCount = 0u;
   \   00000084   0x81A5             STRH     R5,[R4, #+12]
   \   00000086   0xE002             B        ??S_Nv_Write_Impl_7
   1099              }
   1100              else
   1101              {
   1102                  // partial write. increment counter
   1103                  blockHeader.writeCount++;
   \                     ??S_Nv_Write_Impl_6: (+1)
   \   00000088   0x89A0             LDRH     R0,[R4, #+12]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x81A0             STRH     R0,[R4, #+12]
   1104              }
   1105          
   1106              // Need current sector head to update cache after write
   1107              uint16_t newBlockPointer = s_sectorHead;
   \                     ??S_Nv_Write_Impl_7: (+1)
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x8E39             LDRH     R1,[R7, #+48]
   \   00000092   0x8001             STRH     R1,[R0, #+0]
   1108          
   1109              if ( !WriteDataBlock(&blockHeader, (uint8_t*) pData) )
   \   00000094   0x9906             LDR      R1,[SP, #+24]
   \   00000096   0xA801             ADD      R0,SP,#+4
   \   00000098   0x.... 0x....      BL       WriteDataBlock
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD101             BNE      ??S_Nv_Write_Impl_8
   1110              {
   1111                  return S_Nv_ReturnValue_Failure;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE014             B        ??S_Nv_Write_Impl_3
   1112              }
   1113          
   1114              // Write succeeded, so update the cache
   1115              cache->lastBlock = newBlockPointer;
   \                     ??S_Nv_Write_Impl_8: (+1)
   \   000000A4   0x4668             MOV      R0,SP
   \   000000A6   0x8800             LDRH     R0,[R0, #+0]
   \   000000A8   0x70B0             STRB     R0,[R6, #+2]
   \   000000AA   0x0A00             LSRS     R0,R0,#+8
   \   000000AC   0x70F0             STRB     R0,[R6, #+3]
   1116          
   1117              if ( blockHeader.writeCount > COMPACT_ITEM_THRESHOLD )
   \   000000AE   0x89A0             LDRH     R0,[R4, #+12]
   \   000000B0   0x2865             CMP      R0,#+101
   \   000000B2   0xD30B             BCC      ??S_Nv_Write_Impl_9
   1118              {
   1119                  // schedule a compact item operation for this item.
   1120                  // this reads the complete item and writes a new block containing
   1121                  // the complete item. this limits the worst case read and compact
   1122                  // sector time.
   1123                  s_compactItemId = blockHeader.id;
   \   000000B4   0x8860             LDRH     R0,[R4, #+2]
   \   000000B6   0x8678             STRH     R0,[R7, #+50]
   1124                  s_compactItemLength = 0u;           // no need to resize this item here
   \   000000B8   0x86BD             STRH     R5,[R7, #+52]
   1125          
   1126                  // ignore the error if a timer cannot be started: the operation
   1127                  // is not required for a correct operation of the component
   1128                  if (SYS_TIMER_STOPPED == compactItemTimer.state)
   \   000000BA   0x....             LDR      R0,??DataTable27_3
   \   000000BC   0x7801             LDRB     R1,[R0, #+0]
   \   000000BE   0x2900             CMP      R1,#+0
   \   000000C0   0xD104             BNE      ??S_Nv_Write_Impl_9
   1129                      SYS_InitTimer(&compactItemTimer, TIMER_ONE_SHOT_MODE, COMPACT_ITEM_DELAY_MS, compactItemTimerFired);
   \   000000C2   0x....             LDR      R3,??DataTable27_4
   \   000000C4   0x....             LDR      R2,??DataTable27_5  ;; 0xbb8
   \   000000C6   0x2101             MOVS     R1,#+1
   \   000000C8   0x.... 0x....      BL       SYS_InitTimer
   1130              }
   1131          
   1132              return S_Nv_ReturnValue_Ok;
   \                     ??S_Nv_Write_Impl_9: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \                     ??S_Nv_Write_Impl_3: (+1)
   \   000000CE   0xB007             ADD      SP,SP,#+28
   \   000000D0   0xBDF0             POP      {R4-R7,PC}       ;; return
   1133          }
   1134          
   1135          /** Interface function, see \ref S_Nv_Read. */
   1136          #if defined(S_XNV_LOGGING)
   1137          static S_Nv_ReturnValue_t S_Nv_Read_Original(S_Nv_ItemId_t id, uint16_t offset, uint16_t dataLength, void* pData)
   1138          #else

   \                                 In section .text, align 4, keep-with-next
   1139          S_Nv_ReturnValue_t S_Nv_Read_Impl(S_Nv_ItemId_t id, uint16_t offset, uint16_t dataLength, void* pData)
   1140          #endif
   1141          {
   \                     S_Nv_Read_Impl: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001E             MOVS     R6,R3
   1142              N_ERRH_ASSERT_FATAL((id != 0u) && (pData != NULL));
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD001             BEQ      ??S_Nv_Read_Impl_0
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD103             BNE      ??S_Nv_Read_Impl_1
   \                     ??S_Nv_Read_Impl_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable27_6  ;; 0x476
   \   00000014   0x....             ADR.N    R0,?_0
   \   00000016   0x.... 0x....      BL       N_ErrH_Fatal
   1143          
   1144              // get the pointer to the last written block for the item
   1145              uint16_t lastBlockPointer = FindItem(id);
   \                     ??S_Nv_Read_Impl_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       FindItem
   1146              if ( lastBlockPointer == 0x0000u )
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE      ??S_Nv_Read_Impl_2
   1147              {
   1148                  // item does not exist
   1149                  return S_Nv_ReturnValue_DoesNotExist;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}
   1150              }
   1151          
   1152              // prevent overflow when calculating the range of bytes to read
   1153              if ( ((uint32_t) offset + (uint32_t) dataLength) >= 0x10000uL )
   \                     ??S_Nv_Read_Impl_2: (+1)
   \   00000028   0x19E1             ADDS     R1,R4,R7
   \   0000002A   0x2280             MOVS     R2,#+128
   \   0000002C   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD209             BCS      ??S_Nv_Read_Impl_3
   1154              {
   1155                  return S_Nv_ReturnValue_BeyondEnd;
   1156              }
   1157          
   1158              // gather the data into the destination buffer
   1159              if ( !GatherData(s_sector, lastBlockPointer, offset, dataLength, pData) )
   \   00000032   0x9600             STR      R6,[SP, #+0]
   \   00000034   0x003B             MOVS     R3,R7
   \   00000036   0x0022             MOVS     R2,R4
   \   00000038   0x0001             MOVS     R1,R0
   \   0000003A   0x....             LDR      R0,??DataTable27_2
   \   0000003C   0x7D00             LDRB     R0,[R0, #+20]
   \   0000003E   0x.... 0x....      BL       GatherData
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD101             BNE      ??S_Nv_Read_Impl_4
   1160              {
   1161                  return S_Nv_ReturnValue_BeyondEnd;
   \                     ??S_Nv_Read_Impl_3: (+1)
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}
   1162              }
   1163          
   1164              return S_Nv_ReturnValue_Ok;
   \                     ??S_Nv_Read_Impl_4: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1165          }
   1166          
   1167          /** Interface function, see \ref S_Nv_ItemLength. */

   \                                 In section .text, align 4, keep-with-next
   1168          uint16_t S_Nv_ItemLength_Impl(S_Nv_ItemId_t id)
   1169          {
   \                     S_Nv_ItemLength_Impl: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1170              N_ERRH_ASSERT_FATAL(id != 0u);
   \   00000004   0xD103             BNE      ??S_Nv_ItemLength_Impl_0
   \   00000006   0x....             LDR      R1,??DataTable27_7  ;; 0x492
   \   00000008   0x....             ADR.N    R0,?_0
   \   0000000A   0x.... 0x....      BL       N_ErrH_Fatal
   1171          
   1172              uint16_t blockPointer = FindItem(id);
   \                     ??S_Nv_ItemLength_Impl_0: (+1)
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       FindItem
   1173              if ( blockPointer == 0x0000u )
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD008             BEQ      ??S_Nv_ItemLength_Impl_1
   1174              {
   1175                  // item does not exist
   1176                  return 0u;
   1177              }
   1178          
   1179              // read last written item block header
   1180              BlockHeader_t blockHeader;
   1181              D_Nv_Read(s_sector, blockPointer, (uint8_t*) &blockHeader, BLOCK_HEADER_SIZE);
   \   00000018   0x2310             MOVS     R3,#+16
   \   0000001A   0x466A             MOV      R2,SP
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0x....             LDR      R0,??DataTable27_2
   \   00000020   0x7D00             LDRB     R0,[R0, #+20]
   \   00000022   0x.... 0x....      BL       D_Nv_Read_Impl
   1182              return blockHeader.itemLength;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x8900             LDRH     R0,[R0, #+8]
   \                     ??S_Nv_ItemLength_Impl_1: (+1)
   \   0000002A   0xB004             ADD      SP,SP,#+16
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1183          }
   1184          
   1185          /** Interface function, see \ref S_Nv_Delete. */

   \                                 In section .text, align 4, keep-with-next
   1186          S_Nv_ReturnValue_t S_Nv_Delete_Impl(S_Nv_ItemId_t id)
   1187          {
   \                     S_Nv_Delete_Impl: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   1188              N_ERRH_ASSERT_FATAL(id != 0u);
   \   00000006   0xD104             BNE      ??S_Nv_Delete_Impl_0
   \   00000008   0x....             LDR      R1,??DataTable27_8  ;; 0x4a4
   \   0000000A   0xBF00             Nop      
   \   0000000C   0x....             ADR.N    R0,?_0
   \   0000000E   0x.... 0x....      BL       N_ErrH_Fatal
   1189          
   1190              if ( FindItem(id) == 0x0000u )
   \                     ??S_Nv_Delete_Impl_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       FindItem
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE      ??S_Nv_Delete_Impl_1
   1191              {
   1192                  return S_Nv_ReturnValue_DoesNotExist;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE020             B        ??S_Nv_Delete_Impl_2
   1193              }
   1194          
   1195              if ( PowerSupplyTooLow() )
   \                     ??S_Nv_Delete_Impl_1: (+1)
   \   00000020   0x.... 0x....      BL       PowerSupplyTooLow
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ      ??S_Nv_Delete_Impl_3
   1196              {
   1197                  return S_Nv_ReturnValue_PowerSupplyTooLow;
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0xE01A             B        ??S_Nv_Delete_Impl_2
   1198              }
   1199          
   1200              CompactSectorIfNeeded(BLOCK_HEADER_SIZE);
   \                     ??S_Nv_Delete_Impl_3: (+1)
   \   0000002C   0x2010             MOVS     R0,#+16
   \   0000002E   0x.... 0x....      BL       CompactSectorIfNeeded
   1201          
   1202              // Delete item by writing a new header for it, stating 0 length
   1203              BlockHeader_t blockHeader;
   1204          
   1205              blockHeader.id = id;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x8044             STRH     R4,[R0, #+2]
   1206              blockHeader.blockOffset = 0x0000u;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6041             STR      R1,[R0, #+4]
   1207              blockHeader.blockLength = 0;
   1208              blockHeader.itemLength = 0u;
   \   0000003A   0x6081             STR      R1,[R0, #+8]
   1209              blockHeader.previousBlock = 0x0000u;
   1210              blockHeader.writeCount = 0u;
   \   0000003C   0x8181             STRH     R1,[R0, #+12]
   1211          
   1212              uint16_t blockPointer = s_sectorHead;
   \   0000003E   0x....             LDR      R0,??DataTable27_2
   \   00000040   0x8E05             LDRH     R5,[R0, #+48]
   1213          
   1214              if ( !WriteBlockHeader(&blockHeader) )
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x.... 0x....      BL       WriteBlockHeader
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD004             BEQ      ??S_Nv_Delete_Impl_4
   1215              {
   1216                  return S_Nv_ReturnValue_Failure;
   1217              }
   1218          
   1219              if ( !ActivateBlock(blockPointer) )
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       ActivateBlock
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD101             BNE      ??S_Nv_Delete_Impl_5
   1220              {
   1221                  // failed to activate the block
   1222                  return S_Nv_ReturnValue_Failure;
   \                     ??S_Nv_Delete_Impl_4: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xE003             B        ??S_Nv_Delete_Impl_2
   1223              }
   1224          
   1225              DeleteItemCache(id);
   \                     ??S_Nv_Delete_Impl_5: (+1)
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       DeleteItemCache
   1226          
   1227              return S_Nv_ReturnValue_Ok;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??S_Nv_Delete_Impl_2: (+1)
   \   00000062   0xB005             ADD      SP,SP,#+20
   \   00000064   0xBD30             POP      {R4,R5,PC}       ;; return
   1228          }
   1229          
   1230          /** Interface function, see \ref S_Nv_EraseAll.
   1231           *
   1232           * Important: EraseAll leaves the file system in a non-working state if
   1233           * persistent items are also deleted. This is because all sectors are
   1234           * deleted without initializing a new one or even clearing the cache,
   1235           * so reinitialization of the driver is needed.
   1236           */

   \                                 In section .text, align 4, keep-with-next
   1237          S_Nv_ReturnValue_t S_Nv_EraseAll_Impl(bool includingPersistentItems)
   1238          {
   \                     S_Nv_EraseAll_Impl: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1239              PDS_EraseSecureItems();
   \   00000004   0x.... 0x....      BL       PDS_EraseSecureItems
   1240          
   1241              if ( PowerSupplyTooLow() )
   \   00000008   0x.... 0x....      BL       PowerSupplyTooLow
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ      ??S_Nv_EraseAll_Impl_0
   1242              {
   1243                  return S_Nv_ReturnValue_PowerSupplyTooLow;
   \   00000010   0x2005             MOVS     R0,#+5
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
   1244              }
   1245          
   1246              if ( includingPersistentItems )
   \                     ??S_Nv_EraseAll_Impl_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD005             BEQ      ??S_Nv_EraseAll_Impl_1
   1247              {
   1248                  for ( uint8_t sector = FIRST_SECTOR; sector < (FIRST_SECTOR + SECTOR_COUNT); sector++ )
   1249                  {
   1250                      D_Nv_EraseSector(sector);
   \   00000018   0x.... 0x....      BL       D_Nv_EraseSector_Impl
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       D_Nv_EraseSector_Impl
   1251                  }
   \   00000022   0xE01C             B        ??S_Nv_EraseAll_Impl_2
   1252              }
   1253              else
   1254              {
   1255                  uint8_t deletedItems = 0;
   1256                  uint8_t totalItems = s_itemCount;
   \                     ??S_Nv_EraseAll_Impl_1: (+1)
   \   00000024   0x....             LDR      R0,??DataTable27_2
   \   00000026   0x7D47             LDRB     R7,[R0, #+21]
   1257          
   1258                  // Traverse the item cache, removing all the non-persistent
   1259                  for ( uint8_t cacheIndex = 0; cacheIndex < totalItems; cacheIndex++ )
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0x....             LDR      R6,??DataTable27_9
   \   0000002C   0xE00A             B        ??S_Nv_EraseAll_Impl_3
   1260                  {
   1261                      uint16_t id = s_itemCache[cacheIndex].id;
   \                     ??S_Nv_EraseAll_Impl_4: (+1)
   \   0000002E   0x00A8             LSLS     R0,R5,#+2
   \   00000030   0x5A30             LDRH     R0,[R6, R0]
   1262          
   1263                      if ( !IsPersistent(id) )
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xD005             BEQ      ??S_Nv_EraseAll_Impl_5
   \   00000036   0x....             LDR      R1,??DataTable27_10  ;; 0xfff
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD002             BEQ      ??S_Nv_EraseAll_Impl_5
   1264                      {
   1265                          DeleteItemCache(id);
   \   0000003C   0x.... 0x....      BL       DeleteItemCache
   1266                          deletedItems++;
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   1267                      }
   1268                  }
   \                     ??S_Nv_EraseAll_Impl_5: (+1)
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \                     ??S_Nv_EraseAll_Impl_3: (+1)
   \   00000044   0xB2ED             UXTB     R5,R5
   \   00000046   0x42BD             CMP      R5,R7
   \   00000048   0xDBF1             BLT      ??S_Nv_EraseAll_Impl_4
   1269          
   1270                  // Were any items deleted? If so, do sector compaction!
   1271                  if ( deletedItems > 0 )
   \   0000004A   0x0624             LSLS     R4,R4,#+24
   \   0000004C   0xD007             BEQ      ??S_Nv_EraseAll_Impl_2
   1272                  {
   1273                      if ( !CompactSector() )
   \   0000004E   0x.... 0x....      BL       CompactSector
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD103             BNE      ??S_Nv_EraseAll_Impl_2
   1274                      {
   1275                          N_ERRH_FATAL();
   \   00000056   0x....             LDR      R1,??DataTable27_11  ;; 0x4fb
   \   00000058   0x....             ADR.N    R0,?_0
   \   0000005A   0x.... 0x....      BL       N_ErrH_Fatal
   1276                      }
   1277                  }
   1278              }
   1279          
   1280              // Only way we end up here is if all went well.
   1281              return S_Nv_ReturnValue_Ok;
   \                     ??S_Nv_EraseAll_Impl_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1282          }
   1283          
   1284          /** Interface function, see \ref S_Nv_SetPowerSupplyCheckingFunction. */

   \                                 In section .text, align 2, keep-with-next
   1285          void S_Nv_SetPowerSupplyCheckingFunction_Impl(S_Nv_PowerSupplyCheckingFunction_t pf)
   1286          {
   1287              s_powerSupplyCheckingFunction = pf;
   \                     S_Nv_SetPowerSupplyCheckingFunction_Impl: (+1)
   \   00000000   0x....             LDR      R1,??DataTable27_12
   \   00000002   0x6008             STR      R0,[R1, #+0]
   1288          }
   \   00000004   0x4770             BX       LR               ;; return
   1289          /** Interface function, see \ref S_Nv_IsItemAvailable.
   1290           *
   1291           * Important: This will check whether the item is found in the storage area
   1292           */

   \                                 In section .text, align 2, keep-with-next
   1293          bool S_Nv_IsItemAvailable_Impl(S_Nv_ItemId_t id)
   1294          {
   \                     S_Nv_IsItemAvailable_Impl: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1295            return ( FindItem(id) != 0x0000u );
   \   00000002   0x.... 0x....      BL       FindItem
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD000             BEQ      ??S_Nv_IsItemAvailable_Impl_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \                     ??S_Nv_IsItemAvailable_Impl_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1296          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     eraseSectorTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     s_powerSupplyCheckingFunction

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x0000FFF0         DC32     0xfff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     s_itemCache

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     eraseSectorTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x000002DB         DC32     0x2db

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     s_itemCache

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     eraseSectorTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x52 0x65          DC8 "Resizing NV item (id=%hu) from %hu to %hu"
   \              0x73 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x4E    
   \              0x56 0x20    
   \              0x69 0x74    
   \              0x65 0x6D    
   \              0x20 0x28    
   \              0x69 0x64    
   \              0x3D 0x25    
   \              0x68 0x75    
   \              0x29 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \              0x20 0x25    
   \              0x68 0x75    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x25 0x68    
   \              0x75 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x0000031B         DC32     0x31b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     compactSectorTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x0000034E         DC32     0x34e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     eraseSectorTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     eraseSectorTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x00001B58         DC32     0x1b58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x00000401         DC32     0x401

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x000003DF         DC32     0x3df

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x00000407         DC32     0x407

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x00000425         DC32     0x425

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     eraseSectorTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     compactItemTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     compactItemTimerFired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x00000BB8         DC32     0xbb8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x00000476         DC32     0x476

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x00000492         DC32     0x492

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \   00000000   0x000004A4         DC32     0x4a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \   00000000   0x........         DC32     s_itemCache

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_10:
   \   00000000   0x00000FFF         DC32     0xfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_11:
   \   00000000   0x000004FB         DC32     0x4fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_12:
   \   00000000   0x........         DC32     s_powerSupplyCheckingFunction

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x53 0x5F          DC8 "S_Nv"
   \              0x4E 0x76    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1297          #if defined(S_XNV_LOGGING)
   1298          
   1299          S_Nv_ReturnValue_t S_Nv_ItemInit_Impl(S_Nv_ItemId_t id, uint16_t itemLength, void* pDefaultData)
   1300          {
   1301              //hal_flash_readCount = 0u;
   1302              //hal_flash_readSize = 0u;
   1303              //hal_flash_writeCount = 0u;
   1304              //hal_flash_writeSize = 0u;
   1305              uint32_t stopwatch = N_Util_TimerStart();
   1306          
   1307              S_Nv_ReturnValue_t ret = S_Nv_ItemInit_Original(id, itemLength, pDefaultData);
   1308          
   1309              N_LOG_ALWAYS(("item_init(id=%Xh, l=%u, t=%lu, r=%u:%u, w=%u:%lu, h=%u): %hu",
   1310                  id, itemLength,
   1311                  N_Util_TimerElapsed(stopwatch),
   1312          //        hal_flash_readCount, hal_flash_readSize, hal_flash_writeCount, 4uL * hal_flash_writeSize,
   1313                  0u, 0u, 0u, 0uL,
   1314                  s_sectorHead,
   1315                  ret));
   1316          
   1317              return ret;
   1318          }
   1319          
   1320          S_Nv_ReturnValue_t S_Nv_Write_Impl(S_Nv_ItemId_t id, uint16_t offset, uint16_t dataLength, void* pData)
   1321          {
   1322              //hal_flash_readCount = 0u;
   1323              //hal_flash_readSize = 0u;
   1324              //hal_flash_writeCount = 0u;
   1325              //hal_flash_writeSize = 0u;
   1326              uint32_t stopwatch = N_Util_TimerStart();
   1327          
   1328              S_Nv_ReturnValue_t ret = S_Nv_Write_Original(id, offset, dataLength, pData);
   1329          
   1330              N_LOG_ALWAYS(("write(id=%Xh, o=%u, l=%u, t=%lu, r=%u:%u, w=%u:%lu, h=%u): %hu",
   1331                  id, offset, dataLength,
   1332                  N_Util_TimerElapsed(stopwatch),
   1333          //        hal_flash_readCount, hal_flash_readSize, hal_flash_writeCount, 4uL * hal_flash_writeSize,
   1334                  0u, 0u, 0u, 0uL,
   1335                  s_sectorHead,
   1336                  ret));
   1337          
   1338              return ret;
   1339          }
   1340          
   1341          S_Nv_ReturnValue_t S_Nv_Read_Impl(S_Nv_ItemId_t id, uint16_t offset, uint16_t dataLength, void* pData)
   1342          {
   1343              //hal_flash_readCount = 0u;
   1344              //hal_flash_readSize = 0u;
   1345              //hal_flash_writeCount = 0u;
   1346              //hal_flash_writeSize = 0u;
   1347              uint32_t stopwatch = N_Util_TimerStart();
   1348          
   1349              S_Nv_ReturnValue_t ret = S_Nv_Read_Original(id, offset, dataLength, pData);
   1350          
   1351              N_LOG_ALWAYS(("read(id=%Xh, o=%u, l=%u, t=%lu, r=%u:%u): %hu",
   1352                  id, offset, dataLength,
   1353                  N_Util_TimerElapsed(stopwatch),
   1354          //        hal_flash_readCount, hal_flash_readSize,
   1355                  0u, 0u,
   1356                  ret));
   1357          
   1358              return ret;
   1359          }
   1360          
   1361          #endif
   1362          #endif //#ifndef PDS_USE_EXTERNAL_FLASH
   1363          #endif // _ENABLE_PERSISTENT_SERVER_
   1364          #endif // #if PDS_ENABLE_WEAR_LEVELING == 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ActivateBlock
         8   -> WriteAndCheck
       8   ActivateSector
         8   -> WriteAndCheck
      48   CompactItem
        48   -> ActivateBlock
        48   -> CompactSectorIfNeeded
        48   -> D_Nv_Read_Impl
        48   -> FindItemCache
        48   -> GatherData
        48   -> N_ErrH_Fatal
        48   -> N_Log_Prepare
        48   -> N_Log_Trace
        48   -> PowerSupplyTooLow
        48   -> UpdateSectorHead
        48   -> WriteBlockHeader
      64   CompactSector
        64   -> ActivateBlock
        64   -> ActivateSector
        64   -> D_Nv_Read_Impl
        64   -> GatherData
        64   -> HAL_StartAppTimer
        64   -> HAL_StopAppTimer
        64   -> InitSector
        64   -> N_ErrH_Fatal
        64   -> SYS_StopTimer
        64   -> UpdateSectorHead
        64   -> WriteBlockHeader
       8   CompactSectorIfNeeded
         8   -> CompactSector
         8   -> N_ErrH_Fatal
         8   -> SYS_InitTimer
      12   ComputeHeaderCrc
      16   CreateItemCache
        16   -> FindItemCache
        16   -> N_ErrH_Fatal
       8   DeleteItemCache
         8   -> FindItemCache
         8   -> N_ErrH_Fatal
         8   -> __aeabi_memcpy
       8   FindItem
         8   -> FindItemCache
      16   FindItemCache
        16   -> N_ErrH_Fatal
      80   GatherData
        80   -> D_Nv_Read_Impl
        80   -> WriteAndCheck
      32   InitSector
        32   -> D_Nv_EraseSector_Impl
        32   -> D_Nv_IsEmpty_Impl
        32   -> WriteAndCheck
       8   PowerSupplyTooLow
         8   -- Indirect call
      32   S_Nv_Delete_Impl
        32   -> ActivateBlock
        32   -> CompactSectorIfNeeded
        32   -> DeleteItemCache
        32   -> FindItem
        32   -> N_ErrH_Fatal
        32   -> PowerSupplyTooLow
        32   -> WriteBlockHeader
      56   S_Nv_EarlyInit
        56   -> ActivateSector
        56   -> ComputeHeaderCrc
        56   -> CreateItemCache
        56   -> D_Nv_Read_Impl
        56   -> DeleteItemCache
        56   -> FindItemCache
        56   -> InitSector
        56   -> N_ErrH_Fatal
        56   -> UpdateSectorHead
      24   S_Nv_EraseAll_Impl
        24   -> CompactSector
        24   -> D_Nv_EraseSector_Impl
        24   -> DeleteItemCache
        24   -> N_ErrH_Fatal
        24   -> PDS_EraseSecureItems
        24   -> PowerSupplyTooLow
       8   S_Nv_Init
         8   -> S_Nv_EarlyInit
       8   S_Nv_IsItemAvailable_Impl
         8   -> FindItem
      40   S_Nv_ItemInit_Impl
        40   -> CompactItem
        40   -> CompactSectorIfNeeded
        40   -> CreateItemCache
        40   -> FindItem
        40   -> N_ErrH_Fatal
        40   -> PowerSupplyTooLow
        40   -> S_Nv_ItemLength_Impl
        40   -> S_Nv_Read_Impl
        40   -> WriteDataBlock
      24   S_Nv_ItemLength_Impl
        24   -> D_Nv_Read_Impl
        24   -> FindItem
        24   -> N_ErrH_Fatal
      24   S_Nv_Read_Impl
        24   -> FindItem
        24   -> GatherData
        24   -> N_ErrH_Fatal
       0   S_Nv_SetPowerSupplyCheckingFunction_Impl
      48   S_Nv_Write_Impl
        48   -> CompactSectorIfNeeded
        48   -> D_Nv_Read_Impl
        48   -> FindItemCache
        48   -> N_ErrH_Fatal
        48   -> PowerSupplyTooLow
        48   -> SYS_InitTimer
        48   -> WriteDataBlock
       0   UpdateSectorHead
      24   WriteAndCheck
        24   -> D_Nv_IsEqual_Impl
        24   -> D_Nv_Write_Impl
      16   WriteBlockHeader
        16   -> ComputeHeaderCrc
        16   -> D_Nv_IsEmpty_Impl
        16   -> UpdateSectorHead
        16   -> WriteAndCheck
      24   WriteDataBlock
        24   -> ActivateBlock
        24   -> UpdateSectorHead
        24   -> WriteAndCheck
        24   -> WriteBlockHeader
       8   compactItemTimerFired
         8   -> CompactItem
       8   compactSectorTimerFired
         8   -> CompactSector
         8   -> N_ErrH_Fatal
         8   -> PowerSupplyTooLow
       8   eraseSectorTimerFired
         8   -> D_Nv_EraseSector_Impl
         8   -> PowerSupplyTooLow


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
      12  ?Subroutine0
       8  ?_0
      44  ?_1
      14  ActivateBlock
      10  ActivateSector
     282  CompactItem
     254  CompactSector
      66  CompactSectorIfNeeded
      46  ComputeHeaderCrc
      62  CreateItemCache
      52  DeleteItemCache
      26  FindItem
      68  FindItemCache
     264  GatherData
     108  InitSector
      24  PowerSupplyTooLow
     102  S_Nv_Delete_Impl
     302  S_Nv_EarlyInit
      98  S_Nv_EraseAll_Impl
      28  S_Nv_Init
      16  S_Nv_IsItemAvailable_Impl
     176  S_Nv_ItemInit_Impl
      46  S_Nv_ItemLength_Impl
      78  S_Nv_Read_Impl
       6  S_Nv_SetPowerSupplyCheckingFunction_Impl
     210  S_Nv_Write_Impl
      16  UpdateSectorHead
      36  WriteAndCheck
      74  WriteBlockHeader
      90  WriteDataBlock
      24  compactItemTimer
       8  compactItemTimerFired
      28  compactSectorTimerFired
      54  eraseSectorTimer
          s_sector
          s_itemCount
          s_sectorToErase
          s_earlyInitDone
          compactSectorTimer
          s_sectorHead
          s_compactItemId
          s_compactItemLength
      20  eraseSectorTimerFired
     512  s_itemCache
       4  s_persistentItems
       4  s_powerSupplyCheckingFunction

 
   540 bytes in section .bss
    54 bytes in section .data
     4 bytes in section .rodata
 2 810 bytes in section .text
 
 2 810 bytes of CODE  memory
     4 bytes of CONST memory
   594 bytes of DATA  memory

Errors: none
Warnings: none
