###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:40:15
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ConfigServer\src\configServer.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ConfigServer\src\configServer.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\configServer.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\configServer.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\ConfigServer\src\configServer.c
      1          /******************************************************************************
      2            \file configServer.c
      3          
      4            \brief
      5              Configuration Server implementation
      6          
      7            \author
      8              Atmel Corporation: http://www.atmel.com \n
      9              Support email: avr@atmel.com
     10          
     11            Copyright (c) 2008-2015 , Atmel Corporation. All rights reserved.
     12            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     13          
     14            \internal
     15              History:
     16              19.10.10 A. Razinkov - Created.
     17          ******************************************************************************/
     18          
     19          /******************************************************************************
     20                              Includes section
     21          ******************************************************************************/
     22          #include <configServer.h>
     23          #include <macenvMem.h>
     24          #include <csSIB.h>
     25          #include <csDbg.h>
     26          #include <csBuffers.h>
     27          #include <sysAssert.h>
     28          #ifdef _ENABLE_PERSISTENT_SERVER_
     29          #include <pdsDataServer.h>
     30          #endif /* _ENABLE_PERSISTENT_SERVER_ */
     31          #ifndef _MAC2_
     32          #include <zdoZib.h>
     33          #else
     34          #include <macenvPib.h>
     35          #endif
     36          #ifdef ZAPPSI_HOST
     37          #include <zsiDriver.h>
     38          #include <zsiSysSerialization.h>
     39          #endif /* ZAPPSI_HOST */
     40          
     41          /******************************************************************************
     42                              External variables section
     43          ******************************************************************************/
     44          #ifndef ZAPPSI_HOST
     45          
     46          #if !defined(_USE_KF_MAC_)
     47          extern PIB_t csPIB;
     48          #endif // !defined(_USE_KF_MAC_)
     49          
     50          extern SIB_t csSIB;
     51          #ifndef _MAC2_
     52          extern NIB_t csNIB;
     53          extern AIB_t csAIB;
     54          extern ZIB_t csZIB;
     55          #endif
     56          extern CS_StackBuffers_t stackBuffers;
     57          #endif /* !ZAPPSI_HOST */
     58          
     59          extern CS_MemoryItem_t PROGMEM_DECLARE(csVarItems[]);
     60          extern CS_MemoryItem_t PROGMEM_DECLARE(csConstItems[]);
     61          extern CS_MemoryItem_t PROGMEM_DECLARE(csMemItems[]);
     62          
     63          #if defined(_USE_KF_MAC_)
     64          extern uint64_t tal_pib_IeeeAddress;
     65          #if defined(_MAC_BAN_NODE_)
     66          extern CS_ReadOnlyItems_t PROGMEM_DECLARE(csReadOnlyItems);
     67          #endif
     68          #endif
     69          
     70          /******************************************************************************
     71                              Prototypes section
     72          ******************************************************************************/
     73          static CS_MemoryItem_t csGetItem(CS_MemoryItemId_t itemId);
     74          #if !defined(ZAPPSI_HOST) || defined(ZCL_SUPPORT)
     75          static void csReadInternalParameter(CS_MemoryItemId_t parameterId,
     76            void *parameterValue);
     77          static void csWriteParameterInternal(CS_MemoryItemId_t parameterId,
     78            const void *parameterValue);
     79          #endif /* !ZAPPSI_HOST || ZCL_SUPPORT */
     80          
     81          /******************************************************************************
     82                              Implementation section
     83          ******************************************************************************/
     84          /******************************************************************************
     85          \brief Returns size of the particular item.
     86          
     87          \param[in] itemId - item identifier.
     88          
     89          \return size of the particular item.
     90          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     91          uint16_t CS_GetItemSize(CS_MemoryItemId_t itemId)
     92          {
   \                     CS_GetItemSize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     93            CS_MemoryItem_t item = csGetItem(itemId);
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      BL       csGetItem
     94          
     95            return item.size;
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x8880             LDRH     R0,[R0, #+4]
   \   00000010   0xBD0E             POP      {R1-R3,PC}       ;; return
     96          }
     97          
     98          /******************************************************************************
     99          \brief Configuration Server initialization
    100          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    101          void CS_Init(void)
    102          {
   \                     CS_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    103            csSetToDefault();
   \   00000002   0x.... 0x....      BL       csSetToDefault
    104          #ifdef _ENABLE_PERSISTENT_SERVER_
    105            PDS_Init();
   \   00000006   0x.... 0x....      BL       PDS_Init
    106          #endif /* _ENABLE_PERSISTENT_SERVER_ */
    107          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    108          
    109          /******************************************************************************
    110          \brief Gets allocated memory specified by memory identifier
    111          
    112          \param[in] memoryId - memory area Id
    113          \param[out] memoryPtr - pointer to the memory
    114          
    115          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    116          void CS_GetMemory(CS_MemoryItemId_t memoryId, void **memoryPtr)
    117          {
   \                     CS_GetMemory: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    118            CS_MemoryItem_t item = csGetItem(memoryId);
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       csGetItem
    119          
    120            SYS_E_ASSERT_FATAL(((memoryId & CS_TYPE_MASK) == CS_MEM_PARAM_TYPE), CS_GET_MEM0);
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x0200             LSLS     R0,R0,#+8        ;; #+65280
   \   00000014   0x4028             ANDS     R0,R0,R5
   \   00000016   0x2180             MOVS     R1,#+128
   \   00000018   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD004             BEQ      ??CS_GetMemory_0
   \   0000001E   0x....             LDR      R0,??DataTable5  ;; 0x6006
   \   00000020   0x....             LDR      R1,??DataTable5_19
   \   00000022   0x8008             STRH     R0,[R1, #+0]
   \   00000024   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    121          
    122            *memoryPtr = item.value.ramValue;
   \                     ??CS_GetMemory_0: (+1)
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    123          }
   \   0000002C   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    124          
    125          /******************************************************************************
    126          \brief Gets the parameter specified by it's identifier from internal or external
    127                 memory.
    128          
    129          \param[in] parameterId - ID of the parameter being read
    130          \param[out] parameterValue - pointer to the memory
    131          
    132          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    133          void CS_ReadParameter(CS_MemoryItemId_t parameterId, void *parameterValue)
    134          {
   \                     CS_ReadParameter: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    135            /*
    136            assert_static(ARRAY_SIZE(csVarItems) > UINT8_MAX);
    137            assert_static(ARRAY_SIZE(csConstItems) > UINT8_MAX);
    138            assert_static(ARRAY_SIZE(csMemItems) > UINT8_MAX);
    139            */
    140          
    141            /* Read parameter depending of it's location: from internal memory or external
    142               one (for ZAppSI HOST device). */
    143          #ifdef ZAPPSI_HOST
    144            switch (parameterId)
    145            {
    146          #if ZCL_SUPPORT == 1
    147              case CS_ZCL_MEMORY_BUFFERS_AMOUNT_ID:
    148              case CS_ZCL_BUFFERS_ID:
    149              case CS_ZCL_BUFFER_SIZE_ID:
    150          #if APP_USE_OTAU == 1
    151              case CS_ZCL_OTAU_DEFAULT_UPGRADE_SERVER_IEEE_ADDRESS_ID:
    152              case CS_ZCL_OTAU_DEFAULT_SERVER_DISCOVERY_PERIOD_ID:
    153              case CS_ZCL_OTAU_QUERY_INTERVAL_ID:
    154              case CS_ZCL_OTAU_MAX_RETRY_COUNT_ID:
    155              case CS_ZCL_OTAU_IMAGE_PAGE_REQUEST_ENABLE_ID:
    156              case CS_ZCL_OTAU_DISCOVERED_SERVER_AMOUNT_ID:
    157              case CS_ZCL_OTAU_CLIENT_SESSION_AMOUNT_ID:
    158              case CS_ZCL_OTAU_IMAGE_PAGE_REQUEST_RESPONSE_SPACING_ID:
    159              case CS_ZCL_OTAU_IMAGE_PAGE_REQUEST_PAGE_SIZE_ID:
    160              case CS_ZCL_OTAU_MISSED_BLOCKS_BUFFER_SIZE_ID:
    161              case CS_ZCL_OTAU_DISCOVERED_SERVER_RESULT_ID:
    162              case CS_ZCL_OTAU_CLIENT_SESSION_MEMORY_ID:
    163              case CS_ZCL_OTAU_MISSED_BLOCKS_BUFFER_ID:
    164              case CS_ZCL_OTAU_PAGE_REQUEST_PAGE_BUFFER_ID:
    165          #endif /* APP_USE_OTAU == 1 */
    166                csReadInternalParameter(parameterId, parameterValue);
    167                break;
    168          #endif /* ZCL_SUPPORT == 1 */
    169          
    170              default:
    171                zsiProcessCommand(ZSI_SREQ_CMD, &parameterId, zsiSerializeCS_ReadParameterReq,
    172                  parameterValue);
    173                return;
    174                break;
    175            }
    176          #else
    177            csReadInternalParameter(parameterId, parameterValue);
   \   00000002   0x.... 0x....      BL       csReadInternalParameter
    178          #endif /* ZAPPSI_HOST */
    179          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    180          
    181          #if !defined(ZAPPSI_HOST) || defined(ZCL_SUPPORT)
    182          /******************************************************************************
    183          \brief Gets the parameter specified by it's identifier from internal memory.
    184          
    185          \param[in] parameterId - ID of the parameter being read
    186          \param[out] parameterValue - pointer to the memory
    187          
    188          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    189          static void csReadInternalParameter(CS_MemoryItemId_t parameterId, void *parameterValue)
    190          {
   \                     csReadInternalParameter: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    191            CS_MemoryItem_t item = csGetItem(parameterId);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       csGetItem
    192          
    193            SYS_E_ASSERT_FATAL(parameterValue, CS_READ_PARAM0);
   \   0000000E   0x....             LDR      R6,??DataTable5_19
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD104             BNE      ??csReadInternalParameter_0
   \   00000014   0x20C0             MOVS     R0,#+192
   \   00000016   0x01C0             LSLS     R0,R0,#+7        ;; #+24576
   \   00000018   0x8030             STRH     R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    194          
    195            switch (parameterId & CS_TYPE_MASK)
   \                     ??csReadInternalParameter_0: (+1)
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x0200             LSLS     R0,R0,#+8        ;; #+65280
   \   00000022   0x4028             ANDS     R0,R0,R5
   \   00000024   0xD003             BEQ      ??csReadInternalParameter_1
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD106             BNE      ??csReadInternalParameter_2
    196            {
    197              case CS_RAM_PARAM_TYPE:
    198                memcpy(parameterValue, item.value.ramValue, item.size);
    199                break;
    200          
    201              case CS_FLASH_PARAM_TYPE:
    202                memcpy_P(parameterValue, item.value.flashValue, item.size);
   \                     ??csReadInternalParameter_1: (+1)
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x8882             LDRH     R2,[R0, #+4]
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       __aeabi_memcpy
    203                break;
   \   0000003A   0xBD73             POP      {R0,R1,R4-R6,PC}
    204          
    205              case CS_MEM_PARAM_TYPE:
    206              default:
    207                SYS_E_ASSERT_FATAL(0U, CS_READ_PARAM1);
   \                     ??csReadInternalParameter_2: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable5_16  ;; 0x6001
   \   0000003E   0x8030             STRH     R0,[R6, #+0]
   \   00000040   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    208                break;
    209            }
    210            return;
   \   00000044   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    211          }
    212          #endif /* !defined(ZAPPSI_HOST) || defined(ZCL_SUPPORT) */
    213          
    214          /******************************************************************************
    215          \brief Sets the parameter specified by it's identifier
    216          
    217          \param[in] parameterId - ID of the parameter being written
    218          \param[out] parameterValue - pointer to the parameter
    219          
    220          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    221          void CS_WriteParameter(CS_MemoryItemId_t parameterId, const void *parameterValue)
    222          {
   \                     CS_WriteParameter: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    223            /* Write parameter depending of it's location: to internal memory or external
    224               one (for ZAppSI HOST device). */
    225          #ifdef ZAPPSI_HOST
    226            switch (parameterId)
    227            {
    228          #if ZCL_SUPPORT == 1
    229              case CS_ZCL_MEMORY_BUFFERS_AMOUNT_ID:
    230              case CS_ZCL_BUFFERS_ID:
    231              case CS_ZCL_BUFFER_SIZE_ID:
    232          #if APP_USE_OTAU == 1
    233              case CS_ZCL_OTAU_DEFAULT_UPGRADE_SERVER_IEEE_ADDRESS_ID:
    234              case CS_ZCL_OTAU_DEFAULT_SERVER_DISCOVERY_PERIOD_ID:
    235              case CS_ZCL_OTAU_QUERY_INTERVAL_ID:
    236              case CS_ZCL_OTAU_MAX_RETRY_COUNT_ID:
    237              case CS_ZCL_OTAU_IMAGE_PAGE_REQUEST_ENABLE_ID:
    238              case CS_ZCL_OTAU_DISCOVERED_SERVER_AMOUNT_ID:
    239              case CS_ZCL_OTAU_CLIENT_SESSION_AMOUNT_ID:
    240              case CS_ZCL_OTAU_IMAGE_PAGE_REQUEST_RESPONSE_SPACING_ID:
    241              case CS_ZCL_OTAU_IMAGE_PAGE_REQUEST_PAGE_SIZE_ID:
    242              case CS_ZCL_OTAU_MISSED_BLOCKS_BUFFER_SIZE_ID:
    243              case CS_ZCL_OTAU_DISCOVERED_SERVER_RESULT_ID:
    244              case CS_ZCL_OTAU_CLIENT_SESSION_MEMORY_ID:
    245              case CS_ZCL_OTAU_MISSED_BLOCKS_BUFFER_ID:
    246              case CS_ZCL_OTAU_PAGE_REQUEST_PAGE_BUFFER_ID:
    247          #endif /* APP_USE_OTAU == 1 */
    248                csWriteParameterInternal(parameterId, parameterValue);
    249                break;
    250          #endif /* ZCL_SUPPORT == 1*/
    251              default:
    252                {
    253                  ZsiCsParameter_t zsiCsParameter;
    254          
    255                  zsiCsParameter.parameterId = parameterId;
    256                  zsiCsParameter.size = CS_GetItemSize(parameterId);
    257                  memcpy(zsiCsParameter.payload, parameterValue, zsiCsParameter.size);
    258          
    259                  zsiProcessCommand(ZSI_SREQ_CMD, &zsiCsParameter, zsiSerializeCS_WriteParameterReq,
    260                    NULL);
    261                  return;
    262                }
    263                break;
    264            }
    265          #else
    266            csWriteParameterInternal(parameterId, parameterValue);
   \   00000002   0x.... 0x....      BL       csWriteParameterInternal
    267          #endif /* ZAPPSI_HOST */
    268          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    269          
    270          #if !defined(ZAPPSI_HOST) || defined(ZCL_SUPPORT)
    271          /******************************************************************************
    272          \brief Sets the parameter specified by it's identifier to internal or external
    273                 memory.
    274          
    275          \param[in] parameterId - ID of the parameter being written
    276          \param[out] parameterValue - pointer to the parameter
    277          
    278          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    279          static void csWriteParameterInternal(CS_MemoryItemId_t parameterId,
    280            const void *parameterValue)
    281          {
   \                     csWriteParameterInternal: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    282            CS_MemoryItem_t item = csGetItem(parameterId);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       csGetItem
    283          
    284            SYS_E_ASSERT_FATAL(parameterValue, CS_WRITE_PARAM0);
   \   0000000E   0x....             LDR      R6,??DataTable5_19
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD103             BNE      ??csWriteParameterInternal_0
   \   00000014   0x....             LDR      R0,??DataTable5_1  ;; 0x6004
   \   00000016   0x8030             STRH     R0,[R6, #+0]
   \   00000018   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    285            SYS_E_ASSERT_FATAL(((parameterId & CS_TYPE_MASK) == CS_RAM_PARAM_TYPE), CS_WRITE_PARAM1);
   \                     ??csWriteParameterInternal_0: (+1)
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0x0200             LSLS     R0,R0,#+8        ;; #+65280
   \   00000020   0x4205             TST      R5,R0
   \   00000022   0xD003             BEQ      ??csWriteParameterInternal_1
   \   00000024   0x....             LDR      R0,??DataTable5_17  ;; 0x6005
   \   00000026   0x8030             STRH     R0,[R6, #+0]
   \   00000028   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    286          
    287            memcpy(item.value.ramValue, parameterValue, item.size);
   \                     ??csWriteParameterInternal_1: (+1)
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x8882             LDRH     R2,[R0, #+4]
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy
    288          }
   \   00000038   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    289          #endif /* !defined(ZAPPSI_HOST) || defined(ZCL_SUPPORT) */
    290          
    291          #ifndef ZAPPSI_HOST
    292          /******************************************************************************
    293          \brief Set PDS default
    294          
    295          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          void CS_PdsDefaultValue(void)
    297          {
   \                     CS_PdsDefaultValue: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    298          #if defined(_USE_KF_MAC_)
    299            tal_pib_IeeeAddress = CCPU_TO_LE64(CS_UID);
    300          #else
    301            csPIB.macAttr.extAddr = CCPU_TO_LE64(CS_UID);
   \   00000002   0x2080             MOVS     R0,#+128
   \   00000004   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR      R2,??DataTable5_2
   \   0000000A   0xC203             STM      R2!,{R0,R1}
    302          #endif // defined(_USE_KF_MAC_)
    303          
    304            csSIB.csRfTxPower = CS_RF_TX_POWER;
   \   0000000C   0x....             LDR      R0,??DataTable5_3
   \   0000000E   0x1D02             ADDS     R2,R0,#+4
   \   00000010   0x2303             MOVS     R3,#+3
   \   00000012   0x7013             STRB     R3,[R2, #+0]
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7051             STRB     R1,[R2, #+1]
    305          #ifdef _FFD_
    306          #ifdef _PENDING_EMPTY_DATA_FRAME_
    307            csSIB.csMacSendEmptyDataFrame = CS_MAC_SEND_EMPTY_DATA_FRAME;
    308          #endif /*_PENDING_EMPTY_DATA_FRAME_*/
    309          #endif /*_FFD_*/
    310          #ifndef _MAC2_
    311            csSIB.csExtPANID = CCPU_TO_LE64(CS_EXT_PANID);
   \   00000018   0x3048             ADDS     R0,R0,#+72
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x9C00             LDR      R4,[SP, #+0]
   \   00000022   0xC403             STM      R4!,{R0,R1}
    312            csZIB.channelMask = CS_CHANNEL_MASK;
   \   00000024   0x2080             MOVS     R0,#+128
   \   00000026   0x0380             LSLS     R0,R0,#+14       ;; #+2097152
   \   00000028   0x....             LDR      R1,??DataTable5_4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    313            csNIB.channelPage = CS_CHANNEL_PAGE;
   \   0000002C   0x....             LDR      R5,??DataTable5_5
   \   0000002E   0x2700             MOVS     R7,#+0
   \   00000030   0x2177             MOVS     R1,#+119
   \   00000032   0x546F             STRB     R7,[R5, R1]
    314            csNIB.deviceType = CS_DEVICE_TYPE;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x216E             MOVS     R1,#+110
   \   00000038   0x5468             STRB     R0,[R5, R1]
    315            csSIB.csRxOnWhenIdle = (CS_DEVICE_TYPE == DEVICE_TYPE_END_DEVICE) ? CS_RX_ON_WHEN_IDLE : true;
   \   0000003A   0x7710             STRB     R0,[R2, #+28]
    316            csSIB.csComplexDescriptorAvailable = CS_COMPLEX_DESCRIPTOR_AVAILABLE;
   \   0000003C   0x7757             STRB     R7,[R2, #+29]
    317            csSIB.csUserDescriptorAvailable = CS_USER_DESCRIPTOR_AVAILABLE;
   \   0000003E   0x7790             STRB     R0,[R2, #+30]
    318            csSIB.csNwkPanid = CCPU_TO_LE16(CS_NWK_PANID);
   \   00000040   0x....             LDR      R0,??DataTable5_6  ;; 0x1234
   \   00000042   0x8050             STRH     R0,[R2, #+2]
    319            csSIB.csNwkPredefinedPanid = CS_NWK_PREDEFINED_PANID,
    320            csNIB.networkAddress = CCPU_TO_LE16(CS_NWK_ADDR);
   \   00000044   0x7217             STRB     R7,[R2, #+8]
   \   00000046   0x....             LDR      R4,??DataTable5_7  ;; 0xffff
   \   00000048   0x207A             MOVS     R0,#+122
   \   0000004A   0x522C             STRH     R4,[R5, R0]
    321            csNIB.uniqueAddr = CS_NWK_UNIQUE_ADDR;
   \   0000004C   0x2171             MOVS     R1,#+113
   \   0000004E   0x546F             STRB     R7,[R5, R1]
    322            csNIB.leaveReqAllowed = CS_NWK_LEAVE_REQ_ALLOWED,
    323            csSIB.csDtrWakeup = CS_DTR_WAKEUP;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x2192             MOVS     R1,#+146
   \   00000054   0x5468             STRB     R0,[R5, R1]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9900             LDR      R1,[SP, #+0]
   \   0000005A   0x7208             STRB     R0,[R1, #+8]
    324          #if defined(_ENABLE_PERSISTENT_SERVER_)
    325            csNIB.parentNetworkAddress = CCPU_TO_LE16(0xFFFF);
   \   0000005C   0x802C             STRH     R4,[R5, #+0]
    326            csNIB.depth = 0;
   \   0000005E   0x7268             STRB     R0,[R5, #+9]
    327            csNIB.extendedPanId = CCPU_TO_LE64(CS_NWK_EXT_PANID);
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x002E             MOVS     R6,R5
   \   00000064   0x3680             ADDS     R6,R6,#+128
   \   00000066   0xC603             STM      R6!,{R0,R1}
    328            csSIB.csNwkLogicalChannel = 0;
   \   00000068   0x71D7             STRB     R7,[R2, #+7]
    329          #endif /* _ENABLE_PERSISTENT_SERVER_ */
    330          #if defined(_SECURITY_)
    331            csAIB.trustCenterAddress = CCPU_TO_LE64(CS_APS_TRUST_CENTER_ADDRESS);
   \   0000006A   0x....             LDR      R7,??DataTable5_8
   \   0000006C   0x....             ADR      R0,??DataTable5_9
   \   0000006E   0xC803             LDM      R0,{R0,R1}
   \   00000070   0x003E             MOVS     R6,R7
   \   00000072   0x3608             ADDS     R6,R6,#+8
   \   00000074   0xC603             STM      R6!,{R0,R1}
    332            csAIB.tcNwkAddr = CCPU_TO_LE16(CS_SHORT_TRUST_CENTER_ADDRESS);
   \   00000076   0x823C             STRH     R4,[R7, #+16]
    333            csSIB.csZdoSecurityStatus = CS_ZDO_SECURITY_STATUS;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x9900             LDR      R1,[SP, #+0]
   \   0000007C   0x7288             STRB     R0,[R1, #+10]
    334          #endif /* _SECURITY_ */
    335          
    336            /* Parameters not to store in EEPROM */
    337            csNIB.maxNeighborRouteCost = CS_MAX_NEIGHBOR_ROUTE_COST;
   \   0000007E   0x2605             MOVS     R6,#+5
   \   00000080   0x2175             MOVS     R1,#+117
   \   00000082   0x546E             STRB     R6,[R5, R1]
    338          #if defined _NWK_THRESHOLD_ROUTING_
    339            csNIB.softLinkCostThreshold = CS_SOFT_LINK_COST_THRESHOLD;
    340          #endif /* _NWK_THRESHOLD_ROUTING_ */
    341            csNIB.maxLinkRouteCost = CS_MAX_LINK_ROUTE_COST;
   \   00000084   0x2008             MOVS     R0,#+8
   \   00000086   0x2176             MOVS     R1,#+118
   \   00000088   0x5468             STRB     R0,[R5, R1]
    342            csSIB.csNwkMaxLinkStatusFailures = CS_NWK_MAX_LINK_STATUS_FAILURES;
   \   0000008A   0x7153             STRB     R3,[R2, #+5]
    343            csSIB.csNwkEndDeviceMaxFailures = CS_NWK_END_DEVICE_MAX_FAILURES;
   \   0000008C   0x7193             STRB     R3,[R2, #+6]
    344          #ifdef AT86RF212
    345            csSIB.csLbtMode = CS_LBT_MODE;
    346          #endif /* AT86RF212 */
    347          #if defined(_SECURITY_)
    348            csSIB.csSecurityOn = CS_SECURITY_ON;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x9900             LDR      R1,[SP, #+0]
   \   00000092   0x7248             STRB     R0,[R1, #+9]
    349          #endif /* _SECURITY_ */
    350          
    351            /* Buffers cleaning */
    352          #if defined(_ENABLE_PERSISTENT_SERVER_)
    353            memset(&stackBuffers.csNeibTable, 0, CS_NEIB_TABLE_SIZE);
   \   00000094   0x....             LDR      R4,??DataTable5_10
   \   00000096   0x2105             MOVS     R1,#+5
   \   00000098   0x20D8             MOVS     R0,#+216
   \   0000009A   0x0040             LSLS     R0,R0,#+1        ;; #+432
   \   0000009C   0x1820             ADDS     R0,R4,R0
   \   0000009E   0x.... 0x....      BL       __aeabi_memclr4
    354            #if defined(_BINDING_) && (CS_APS_BINDING_TABLE_SIZE > 0)
    355              memset(&stackBuffers.csApsBindingTable, 0, CS_APS_BINDING_TABLE_SIZE);
   \   000000A2   0x210E             MOVS     R1,#+14
   \   000000A4   0x....             LDR      R0,??DataTable5_11  ;; 0x14f8
   \   000000A6   0x1820             ADDS     R0,R4,R0
   \   000000A8   0x.... 0x....      BL       __aeabi_memclr4
    356            #endif /* _BINDING_ */
    357            #if defined(_SECURITY_)
    358            {
    359              csNIB.securityIB.securityLevel = CS_SECURITY_LEVEL;
   \   000000AC   0x208B             MOVS     R0,#+139
   \   000000AE   0x542E             STRB     R6,[R5, R0]
    360              csNIB.securityIB.secureAllFrames = CS_SECURITY_ALL_FRAMES;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x358C             ADDS     R5,R5,#+140
   \   000000B4   0x7028             STRB     R0,[R5, #+0]
    361              NWK_ResetSecurityIB();
   \   000000B6   0x.... 0x....      BL       NWK_ResetSecurityIB
    362            }
    363            #endif /* _SECURITY_ */
    364          #endif /* _ENABLE_PERSISTENT_SERVER_ */
    365          #if defined (_GROUP_TABLE_)
    366            memset(&stackBuffers.csGroupTable, 0, CS_GROUP_TABLE_SIZE);
   \   000000BA   0x20E2             MOVS     R0,#+226
   \   000000BC   0x0100             LSLS     R0,R0,#+4        ;; #+3616
   \   000000BE   0x1820             ADDS     R0,R4,R0
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0xC006             STM      R0!,{R1,R2}
    367          #endif /* _GROUP_TABLE_ */
    368          #if defined(_SECURITY_)
    369            #if defined _LINK_SECURITY_ && CS_APS_KEY_PAIR_DESCRIPTORS_AMOUNT > 0
    370              memset(&stackBuffers.csApsKeyPairDescriptors, 0, CS_APS_KEY_PAIR_DESCRIPTORS_AMOUNT);
   \   000000C6   0x2105             MOVS     R1,#+5
   \   000000C8   0x....             LDR      R0,??DataTable5_18  ;; 0x1808
   \   000000CA   0x1820             ADDS     R0,R4,R0
   \   000000CC   0x.... 0x....      BL       __aeabi_memclr4
    371            #endif /* _LINK_SECURITY_ */
    372          #endif /* _SECURITY_ */
    373          #if defined(_PERMISSIONS_) && CS_PERMISSIONS_TABLE_SIZE > 0
    374            memset(&stackBuffers.csPermissionsTable, 0, CS_PERMISSIONS_TABLE_SIZE);
    375          #endif /* _PERMISSIONS_ */
    376          #endif /* _MAC2_ */
    377          }
   \   000000D0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    378          
    379          #endif /* !ZAPPSI_HOST */
    380          
    381          /******************************************************************************
    382          \brief Returns Configuration Server item by it's identifier
    383          
    384          \param[in] itemId - ID of the parameter
    385          
    386          \return - Configuration Server item
    387          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    388          static CS_MemoryItem_t csGetItem(CS_MemoryItemId_t itemId)
    389          {
   \                     csGetItem: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000A             MOVS     R2,R1
    390            CS_MemoryItem_t item =
    391            {
    392              .size = 0,
    393              .value = {0}
    394            };
   \   00000006   0xBF00             Nop      
   \   00000008   0x....             ADR.N    R0,?_0
   \   0000000A   0xC803             LDM      R0,{R0,R1}
   \   0000000C   0x466B             MOV      R3,SP
   \   0000000E   0xC303             STM      R3!,{R0,R1}
    395            uint8_t itemInternalId = itemId & CS_ID_MASK;
   \   00000010   0x0610             LSLS     R0,R2,#+24
    396          
    397            /* Read item info from the FLASH */
    398            switch (itemId & CS_TYPE_MASK)
   \   00000012   0x0D40             LSRS     R0,R0,#+21
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x0209             LSLS     R1,R1,#+8        ;; #+65280
   \   00000018   0x4011             ANDS     R1,R1,R2
   \   0000001A   0xD007             BEQ      ??csGetItem_0
   \   0000001C   0x2280             MOVS     R2,#+128
   \   0000001E   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \   00000020   0x4291             CMP      R1,R2
   \   00000022   0xD006             BEQ      ??csGetItem_1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD006             BEQ      ??csGetItem_2
   \   0000002A   0xE00C             B        ??csGetItem_3
    399            {
    400              case CS_RAM_PARAM_TYPE:
    401                //sysAssert(itemInternalId < ARRAY_SIZE(csVarItems), CS_GET_ITEM0);
    402                memcpy_P(&item, &csVarItems[itemInternalId], sizeof(CS_MemoryItem_t));
   \                     ??csGetItem_0: (+1)
   \   0000002C   0x2208             MOVS     R2,#+8
   \   0000002E   0x....             LDR      R1,??DataTable5_12
   \   00000030   0xE004             B.N      ??csGetItem_4
    403                break;
    404          
    405              case CS_FLASH_PARAM_TYPE:
    406                //sysAssert(itemInternalId < ARRAY_SIZE(csConstItems), CS_GET_ITEM1);
    407                memcpy_P(&item, &csConstItems[itemInternalId], sizeof(CS_MemoryItem_t));
   \                     ??csGetItem_1: (+1)
   \   00000032   0x2208             MOVS     R2,#+8
   \   00000034   0x....             LDR      R1,??DataTable5_13
   \   00000036   0xE001             B.N      ??csGetItem_4
    408                break;
    409          
    410              case CS_MEM_PARAM_TYPE:
    411                //sysAssert(itemInternalId < ARRAY_SIZE(csMemItems), CS_GET_ITEM2);
    412                 memcpy_P(&item, &csMemItems[itemInternalId], sizeof(CS_MemoryItem_t));
   \                     ??csGetItem_2: (+1)
   \   00000038   0x2208             MOVS     R2,#+8
   \   0000003A   0x....             LDR      R1,??DataTable5_14
   \                     ??csGetItem_4: (+1)
   \   0000003C   0x1809             ADDS     R1,R1,R0
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy
    413                 break;
   \   00000044   0xE004             B        ??csGetItem_5
    414          
    415              default:
    416                SYS_E_ASSERT_FATAL(0U, CS_GET_ITEM3);
   \                     ??csGetItem_3: (+1)
   \   00000046   0x....             LDR      R0,??DataTable5_15  ;; 0x600a
   \   00000048   0x....             LDR      R1,??DataTable5_19
   \   0000004A   0x8008             STRH     R0,[R1, #+0]
   \   0000004C   0x.... 0x....      BL       SYS_DefAssertCallbackFatal
    417                break;
    418            }
    419          
    420            return item;
   \                     ??csGetItem_5: (+1)
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0xC803             LDM      R0,{R0,R1}
   \   00000054   0xC403             STM      R4!,{R0,R1}
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    421          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x0000             DC16 0
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x00006006         DC32     0x6006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x00006004         DC32     0x6004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     csPIB+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     csSIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     csZIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     csNIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x00001234         DC32     0x1234

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     csAIB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0xAAAAAAAA         DC32     0xAAAAAAAA,0xAAAAAAAA
   \              0xAAAAAAAA   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     stackBuffers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x000014F8         DC32     0x14f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     csVarItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     csConstItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     csMemItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x0000600A         DC32     0x600a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x00006001         DC32     0x6001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x00006005         DC32     0x6005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x00001808         DC32     0x1808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     gAssertDbgCode
    422          
    423          #if defined(_USE_KF_MAC_) && defined(_MAC_BAN_NODE_)
    424          /******************************************************************************
    425          \brief Returns the BAN table size
    426          
    427          \return - the BAN table size
    428          ******************************************************************************/
    429          MAC_BanTableSize_t csGetBanTableSize(void)
    430          {
    431            MAC_BanTableSize_t size;
    432          
    433            memcpy_P(&size, &csReadOnlyItems.csMacBanTableSize, sizeof(MAC_BanTableSize_t));
    434          
    435            return size;
    436          }
    437          
    438          /******************************************************************************
    439          \brief Returns the BAN table entry
    440          
    441          \return - pointer to the BAN table
    442          ******************************************************************************/
    443          MAC_BanTableEntry_t *csGetBanTableEntry(void)
    444          {
    445            return stackBuffers.csBanTable;
    446          }
    447          
    448          #endif // defined(_USE_KF_MAC_) && defined(_MAC_BAN_NODE_)
    449          
    450          /* eof configServer.c */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CS_GetItemSize
        16   -> csGetItem
      24   CS_GetMemory
        24   -> SYS_DefAssertCallbackFatal
        24   -> csGetItem
       8   CS_Init
         8   -> PDS_Init
         8   -> csSetToDefault
      24   CS_PdsDefaultValue
        24   -> NWK_ResetSecurityIB
        24   -> __aeabi_memclr4
       8   CS_ReadParameter
         8   -> csReadInternalParameter
       8   CS_WriteParameter
         8   -> csWriteParameterInternal
      16   csGetItem
        16   -> SYS_DefAssertCallbackFatal
        16   -> __aeabi_memcpy
      24   csReadInternalParameter
        24   -> SYS_DefAssertCallbackFatal
        24   -> __aeabi_memcpy
        24   -> csGetItem
      24   csWriteParameterInternal
        24   -> SYS_DefAssertCallbackFatal
        24   -> __aeabi_memcpy
        24   -> csGetItem


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       8  ??DataTable5_9
       8  ?_0
      18  CS_GetItemSize
      46  CS_GetMemory
      12  CS_Init
     210  CS_PdsDefaultValue
       8  CS_ReadParameter
       8  CS_WriteParameter
      88  csGetItem
      70  csReadInternalParameter
      58  csWriteParameterInternal

 
 610 bytes in section .text
 
 610 bytes of CODE memory

Errors: none
Warnings: none
