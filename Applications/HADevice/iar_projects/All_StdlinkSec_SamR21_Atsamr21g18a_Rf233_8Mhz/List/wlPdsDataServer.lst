###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:41:11
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\PersistDataServer\wl\src\wlPdsDataServer.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\PersistDataServer\wl\src\wlPdsDataServer.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\wlPdsDataServer.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\wlPdsDataServer.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\BitCloud\Components\PersistDataServer\wl\src\wlPdsDataServer.c
      1          /**************************************************************************//**
      2            \file wlPdsDataServer.c
      3          
      4            \brief PDS data server implementation.
      5          
      6            \author
      7              Atmel Corporation: http://www.atmel.com \n
      8              Support email: avr@atmel.com
      9          
     10            Copyright (c) 2008-2013, Atmel Corporation. All rights reserved.
     11            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     12          
     13            \internal
     14             History:
     15              21.05.13 A. Fomin - Created.
     16          ******************************************************************************/
     17          
     18          #if PDS_ENABLE_WEAR_LEVELING == 1
     19          #ifdef _ENABLE_PERSISTENT_SERVER_
     20          /******************************************************************************
     21                                         Includes section
     22          ******************************************************************************/
     23          #include <wlPdsMemIds.h>
     24          #include <wlPdsSecurity.h>
     25          #include <wlPdsBindings.h>
     26          #include <S_Nv_Init.h>
     27          #include <S_Nv.h>
     28          #include <wlPdsTaskManager.h>
     29          #include <wlPdsTypesConverter.h>
     30          #include <N_ErrH.h>
     31          #include <D_Nv_Init.h>
     32          #include <sysEvents.h>
     33          #include <wlPdsTypes.h>
     34          
     35          /******************************************************************************
     36                                        Defines section
     37          ******************************************************************************/
     38          #define EVENT_TO_MEM_ID_MAPPING(event, id)  {.eventId = event, .itemId = id}
     39          #define COMPID "wlPdsDataServer"
     40          
     41          /******************************************************************************
     42                                      Types section
     43          ******************************************************************************/
     44          typedef struct _EventToMemoryIdMapping_t
     45          {
     46            uint8_t        eventId;
     47            S_Nv_ItemId_t itemId;
     48          } EventToMemoryIdMapping_t;
     49          
     50          typedef uint8_t PDS_MemMask_t[PDS_ITEM_MASK_SIZE];
     51          
     52          /******************************************************************************
     53                              Prototypes section
     54          ******************************************************************************/
     55          static void pdsObserver(SYS_EventId_t eventId, SYS_EventData_t data);
     56          static void pdsStoreItem(S_Nv_ItemId_t id);
     57          static bool pdsRestoreItem(S_Nv_ItemId_t id);
     58          static bool pdsInitItemMask(S_Nv_ItemId_t memoryId, uint8_t *itemMask);
     59          
     60          /******************************************************************************
     61                              Static variables section
     62          ******************************************************************************/

   \                                 In section .data, align 4
     63          static SYS_EventReceiver_t pdsEventReceiver = { .func = pdsObserver};
   \                     pdsEventReceiver:
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000000C   0x........         DC32 pdsObserver
     64          
     65          /* Memory map, shows relationships between BitCloud events and memory which
     66             is updated on specific event. Such memory should be updated in non-volatile
     67             storage on an event occurrence. */

   \                                 In section .text, align 4, keep-with-next
     68          static EventToMemoryIdMapping_t PROGMEM_DECLARE(pdsMemoryMap[]) =
   \                     pdsMemoryMap:
   \   00000000   0x0E 0x00          DC8 14, 0
   \   00000002   0x0001             DC16 1
   \   00000004   0x0E 0x00          DC8 14, 0
   \   00000006   0x0002             DC16 2
   \   00000008   0x0E 0x00          DC8 14, 0
   \   0000000A   0x0004             DC16 4
   \   0000000C   0x0E 0x00          DC8 14, 0
   \   0000000E   0x0005             DC16 5
   \   00000010   0x0E 0x00          DC8 14, 0
   \   00000012   0x0006             DC16 6
   \   00000014   0x0E 0x00          DC8 14, 0
   \   00000016   0x0007             DC16 7
   \   00000018   0x0E 0x00          DC8 14, 0
   \   0000001A   0x0008             DC16 8
   \   0000001C   0x0E 0x00          DC8 14, 0
   \   0000001E   0x0009             DC16 9
   \   00000020   0x05 0x00          DC8 5, 0
   \   00000022   0x0001             DC16 1
   \   00000024   0x05 0x00          DC8 5, 0
   \   00000026   0x0002             DC16 2
   \   00000028   0x05 0x00          DC8 5, 0
   \   0000002A   0x0004             DC16 4
   \   0000002C   0x05 0x00          DC8 5, 0
   \   0000002E   0x0005             DC16 5
   \   00000030   0x05 0x00          DC8 5, 0
   \   00000032   0x0006             DC16 6
   \   00000034   0x05 0x00          DC8 5, 0
   \   00000036   0x0007             DC16 7
   \   00000038   0x05 0x00          DC8 5, 0
   \   0000003A   0x0008             DC16 8
   \   0000003C   0x05 0x00          DC8 5, 0
   \   0000003E   0x0009             DC16 9
   \   00000040   0x04 0x00          DC8 4, 0
   \   00000042   0x0001             DC16 1
   \   00000044   0x04 0x00          DC8 4, 0
   \   00000046   0x0002             DC16 2
   \   00000048   0x04 0x00          DC8 4, 0
   \   0000004A   0x0004             DC16 4
   \   0000004C   0x04 0x00          DC8 4, 0
   \   0000004E   0x0006             DC16 6
   \   00000050   0x04 0x00          DC8 4, 0
   \   00000052   0x0005             DC16 5
   \   00000054   0x04 0x00          DC8 4, 0
   \   00000056   0x0007             DC16 7
   \   00000058   0x04 0x00          DC8 4, 0
   \   0000005A   0x0008             DC16 8
   \   0000005C   0x04 0x00          DC8 4, 0
   \   0000005E   0x0009             DC16 9
   \   00000060   0x06 0x00          DC8 6, 0
   \   00000062   0x0001             DC16 1
   \   00000064   0x02 0x00          DC8 2, 0
   \   00000066   0x0002             DC16 2
   \   00000068   0x03 0x00          DC8 3, 0
   \   0000006A   0x0002             DC16 2
   \   0000006C   0x09 0x00          DC8 9, 0
   \   0000006E   0x0003             DC16 3
   \   00000070   0x15 0x00          DC8 21, 0
   \   00000072   0x0003             DC16 3
   \   00000074   0x20 0x00          DC8 32, 0
   \   00000076   0x0003             DC16 3
   \   00000078   0x14 0x00          DC8 20, 0
   \   0000007A   0x0004             DC16 4
   \   0000007C   0x14 0x00          DC8 20, 0
   \   0000007E   0x0005             DC16 5
   \   00000080   0x14 0x00          DC8 20, 0
   \   00000082   0x0006             DC16 6
   \   00000084   0x10 0x00          DC8 16, 0
   \   00000086   0x0007             DC16 7
   \   00000088   0x11 0x00          DC8 17, 0
   \   0000008A   0x0008             DC16 8
   \   0000008C   0x12 0x00          DC8 18, 0
   \   0000008E   0x0008             DC16 8
   \   00000090   0x1F 0x00          DC8 31, 0
   \   00000092   0x0006             DC16 6
   \   00000094   0x26 0x00          DC8 38, 0
   \   00000096   0x0009             DC16 9
   \   00000098   0x24 0x00          DC8 36, 0
   \   0000009A   0x0001             DC16 1
     69          {
     70            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             BC_EXT_GEN_MEMORY_ITEM_ID),
     71            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             CS_NEIB_TABLE_ITEM_ID),
     72            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             CS_NWK_SECURITY_IB_ITEM_ID),
     73            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             CS_NWK_SECURITY_KEYS_ITEM_ID),
     74            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             NWK_SECURITY_COUNTERS_ITEM_ID),
     75            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             CS_APS_BINDING_TABLE_ITEM_ID),
     76            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             CS_GROUP_TABLE_ITEM_ID),
     77            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_ENTERED,             NWK_RREQ_IDENTIFIER_ITEM_ID),
     78          
     79            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             BC_EXT_GEN_MEMORY_ITEM_ID),
     80            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             CS_NEIB_TABLE_ITEM_ID),
     81            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             CS_NWK_SECURITY_IB_ITEM_ID),
     82            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             CS_NWK_SECURITY_KEYS_ITEM_ID),
     83            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             NWK_SECURITY_COUNTERS_ITEM_ID),
     84            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             CS_APS_BINDING_TABLE_ITEM_ID),
     85            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             CS_GROUP_TABLE_ITEM_ID),
     86            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_STARTED,             NWK_RREQ_IDENTIFIER_ITEM_ID),
     87          
     88            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                BC_EXT_GEN_MEMORY_ITEM_ID),
     89            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                CS_NEIB_TABLE_ITEM_ID),
     90            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                CS_NWK_SECURITY_IB_ITEM_ID),
     91            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                NWK_SECURITY_COUNTERS_ITEM_ID),
     92            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                CS_NWK_SECURITY_KEYS_ITEM_ID),
     93            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                CS_APS_BINDING_TABLE_ITEM_ID),
     94            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                CS_GROUP_TABLE_ITEM_ID),
     95            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_LEFT,                NWK_RREQ_IDENTIFIER_ITEM_ID),
     96          
     97            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NETWORK_UPDATE,              BC_EXT_GEN_MEMORY_ITEM_ID),
     98          
     99            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_CHILD_JOINED,                CS_NEIB_TABLE_ITEM_ID),
    100            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_CHILD_REMOVED,               CS_NEIB_TABLE_ITEM_ID),
    101          
    102            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_KEY_PAIR_DELETED,            CS_APS_KEY_PAIR_DESCRIPTORS_ITEM_ID),
    103            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_APS_SECURITY_TABLES_UPDATED, CS_APS_KEY_PAIR_DESCRIPTORS_ITEM_ID),
    104            EVENT_TO_MEM_ID_MAPPING(BC_SECURITY_APS_COUNTERS_UPDATE,      CS_APS_KEY_PAIR_DESCRIPTORS_ITEM_ID),
    105          
    106            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NWK_SECURITY_TABLES_UPDATED, CS_NWK_SECURITY_IB_ITEM_ID),
    107            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NWK_SECURITY_TABLES_UPDATED, CS_NWK_SECURITY_KEYS_ITEM_ID),
    108            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NWK_SECURITY_TABLES_UPDATED, NWK_SECURITY_COUNTERS_ITEM_ID),
    109          
    110            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_BIND_TABLE_UPDATED,          CS_APS_BINDING_TABLE_ITEM_ID),
    111          
    112            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_GROUP_TABLE_UPDATED,         CS_GROUP_TABLE_ITEM_ID),
    113            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_GROUPS_REMOVED,              CS_GROUP_TABLE_ITEM_ID),
    114          
    115            EVENT_TO_MEM_ID_MAPPING(BC_SECURITY_NWK_COUNTERS_UPDATE,      NWK_SECURITY_COUNTERS_ITEM_ID),
    116          
    117            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_NWK_RREQ_ID_UPDATED,         NWK_RREQ_IDENTIFIER_ITEM_ID),
    118          
    119            EVENT_TO_MEM_ID_MAPPING(BC_EVENT_CHANNEL_CHANGED,             BC_EXT_GEN_MEMORY_ITEM_ID)
    120          };
    121          

   \                                 In section .bss, align 4
    122          static uint8_t itemsToStore[PDS_ITEM_MASK_SIZE];
   \                     itemsToStore:
   \   00000000                      DS8 8
    123          
    124          /******************************************************************************
    125                             Implementation section
    126          ******************************************************************************/
    127          /**************************************************************************//**
    128          \brief Restores data from non-volatile storage
    129          
    130          PDS files not included in the current build configuration will be ignored.
    131          Restoring process will be performed only if all files, expected for actual
    132          configuration, are presented in NV storage
    133          
    134          \param[in] memoryId - an identifier of PDS file or directory to be restored
    135                                from non-volatile memory
    136          
    137          \return true, if all expected files have been restored, false - otherwise
    138          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    139          bool PDS_Restore(PDS_MemId_t memoryId)
    140          {
   \                     PDS_Restore: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    141            uint8_t itemsToRestore[PDS_ITEM_MASK_SIZE] = {0U};
   \   00000004   0xA904             ADD      R1,SP,#+16
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xC10C             STM      R1!,{R2,R3}
    142            uint8_t i, j;
    143          
    144            if (!pdsInitItemMask(memoryId, itemsToRestore))
   \   0000000C   0xA904             ADD      R1,SP,#+16
   \   0000000E   0x.... 0x....      BL       pdsInitItemMask
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD03D             BEQ      ??PDS_Restore_0
   \   00000016   0x2600             MOVS     R6,#+0
    145              return false;
    146          
    147            for (i = 0U; i < PDS_ITEM_MASK_SIZE; i++)
    148              for (j = 0U; j < 8U; j++)
   \                     ??PDS_Restore_1: (+1)
   \   00000018   0x2400             MOVS     R4,#+0
    149                if (itemsToRestore[i] & (1U << j))
   \                     ??PDS_Restore_2: (+1)
   \   0000001A   0xA804             ADD      R0,SP,#+16
   \   0000001C   0x5D80             LDRB     R0,[R0, R6]
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x40A1             LSLS     R1,R1,R4
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD037             BEQ      ??PDS_Restore_3
    150                  if (!pdsRestoreItem(((S_Nv_ItemId_t)i << 3U) + j))
   \   00000026   0x00F0             LSLS     R0,R6,#+3
   \   00000028   0x1907             ADDS     R7,R0,R4
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0xB2B8             UXTH     R0,R7
   \   0000002E   0x.... 0x....      BL       pdsGetItemDescr
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD02D             BEQ      ??PDS_Restore_0
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x8840             LDRH     R0,[R0, #+2]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ      ??PDS_Restore_4
   \   0000003E   0x9801             LDR      R0,[SP, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD104             BNE      ??PDS_Restore_5
   \                     ??PDS_Restore_4: (+1)
   \   00000044   0x21FF             MOVS     R1,#+255
   \   00000046   0x3198             ADDS     R1,R1,#+152      ;; #+407
   \   00000048   0x....             ADR.N    R0,?_2
   \   0000004A   0x.... 0x....      BL       N_ErrH_Fatal
   \                     ??PDS_Restore_5: (+1)
   \   0000004E   0x9802             LDR      R0,[SP, #+8]
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0xD000             BEQ      ??PDS_Restore_6
   \   00000054   0x4780             BLX      R0
   \                     ??PDS_Restore_6: (+1)
   \   00000056   0xB2B8             UXTH     R0,R7
   \   00000058   0x.... 0x....      BL       S_Nv_ItemLength_Impl
   \   0000005C   0x0005             MOVS     R5,R0
   \   0000005E   0x9A01             LDR      R2,[SP, #+4]
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0x8841             LDRH     R1,[R0, #+2]
   \   00000064   0xB2B8             UXTH     R0,R7
   \   00000066   0x.... 0x....      BL       S_Nv_ItemInit_Impl
   \   0000006A   0x2802             CMP      R0,#+2
   \   0000006C   0xD011             BEQ      ??PDS_Restore_0
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD006             BEQ      ??PDS_Restore_7
   \   00000072   0x21FF             MOVS     R1,#+255
   \   00000074   0x31AE             ADDS     R1,R1,#+174      ;; #+429
   \   00000076   0xBF00             Nop      
   \   00000078   0x....             ADR.N    R0,?_2
   \   0000007A   0x.... 0x....      BL       N_ErrH_Fatal
   \   0000007E   0xE008             B        ??PDS_Restore_0
   \                     ??PDS_Restore_7: (+1)
   \   00000080   0x002B             MOVS     R3,R5
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x8842             LDRH     R2,[R0, #+2]
   \   00000086   0x9901             LDR      R1,[SP, #+4]
   \   00000088   0xB2B8             UXTH     R0,R7
   \   0000008A   0x.... 0x....      BL       pdsUpdateMemory
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD101             BNE      ??PDS_Restore_3
    151                    return false;
   \                     ??PDS_Restore_0: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE008             B        ??PDS_Restore_8
   \                     ??PDS_Restore_3: (+1)
   \   00000096   0x1C64             ADDS     R4,R4,#+1
   \   00000098   0xB2E4             UXTB     R4,R4
   \   0000009A   0x2C08             CMP      R4,#+8
   \   0000009C   0xD3BD             BCC      ??PDS_Restore_2
   \   0000009E   0x1C76             ADDS     R6,R6,#+1
   \   000000A0   0xB2F6             UXTB     R6,R6
   \   000000A2   0x2E06             CMP      R6,#+6
   \   000000A4   0xD3B8             BCC      ??PDS_Restore_1
    152          
    153            return true;
   \   000000A6   0x2001             MOVS     R0,#+1
   \                     ??PDS_Restore_8: (+1)
   \   000000A8   0xB007             ADD      SP,SP,#+28
   \   000000AA   0xBDF0             POP      {R4-R7,PC}       ;; return
    154          }
    155          
    156          /**************************************************************************//**
    157          \brief Deletes data from non-volatile storage
    158          
    159          \param[in] memoryId - an identifier of PDS item or directory to be deleted
    160                                from non-volatile memory
    161          
    162          \return PDS_DataServerState_t - status of PDS delete
    163          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    164          PDS_DataServerState_t PDS_Delete(PDS_MemId_t memoryId)
    165          {
   \                     PDS_Delete: (+1)
   \   00000000   0xB560             PUSH     {R5,R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    166            uint8_t itemsToDelete[PDS_ITEM_MASK_SIZE] = {0U};
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xC10C             STM      R1!,{R2,R3}
    167            uint8_t i, j;
    168          
    169            if (!pdsInitItemMask(memoryId, itemsToDelete))
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x.... 0x....      BL       pdsInitItemMask
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD012             BEQ      ??PDS_Delete_0
    170              return false;
    171          
    172            for (i = 0U; i < PDS_ITEM_MASK_SIZE; i++)
   \   00000016   0x2500             MOVS     R5,#+0
    173              for (j = 0U; j < 8U; j++)
   \                     ??PDS_Delete_1: (+1)
   \   00000018   0x2600             MOVS     R6,#+0
    174                if (itemsToDelete[i] & (1U << j))
   \                     ??PDS_Delete_2: (+1)
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x5D40             LDRB     R0,[R0, R5]
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x40B1             LSLS     R1,R1,R6
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD004             BEQ      ??PDS_Delete_3
    175                  S_Nv_Delete(((S_Nv_ItemId_t)i << 3U) + j);
   \   00000026   0x00E8             LSLS     R0,R5,#+3
   \   00000028   0x1980             ADDS     R0,R0,R6
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       S_Nv_Delete_Impl
   \                     ??PDS_Delete_3: (+1)
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   \   00000032   0x2E08             CMP      R6,#+8
   \   00000034   0xD3F1             BCC      ??PDS_Delete_2
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \   00000038   0x2D06             CMP      R5,#+6
   \   0000003A   0xD3ED             BCC      ??PDS_Delete_1
    176          
    177            return PDS_SUCCESS;
   \                     ??PDS_Delete_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD6E             POP      {R1-R3,R5,R6,PC}  ;; return
    178          }
    179          /**************************************************************************//**
    180          \brief Stores data in non-volatile memory in background, not blocking other
    181                 processes.
    182          
    183          \ingroup pds
    184          
    185          All PDS files which are absent in the current build configuration will be ignored.
    186          
    187          \param[in] memoryId - an identifier of PDS file or directory to be stored
    188                                in non-volatile memory.
    189          
    190          \return True, if storing process has begun, false - otherwise.
    191          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    192          bool PDS_Store(PDS_MemId_t memoryId)
    193          {
   \                     PDS_Store: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    194            if (!pdsInitItemMask(memoryId, itemsToStore))
   \   00000002   0x....             LDR      R1,??DataTable9
   \   00000004   0x.... 0x....      BL       pdsInitItemMask
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ      ??PDS_Store_0
    195              return false;
    196            
    197            pdsPostTask(PDS_STORE_ITEM_TASK_ID);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       pdsPostTask
    198          
    199            return true;
   \   00000012   0x2001             MOVS     R0,#+1
   \                     ??PDS_Store_0: (+1)
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    200          }
    201          
    202          /**************************************************************************//**
    203          \brief Deletes data from non-volatile storage except the Persistant items
    204                 depending on the parameter passed.
    205          
    206          \param[in] includingPersistentItems - deletes persistant items if TRUE
    207                                                deletes all other items except persistant 
    208                                                items if FALSE
    209          
    210          \return PDS_DataServerState_t - status of PDS DeleteAll
    211          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    212          PDS_DataServerState_t PDS_DeleteAll(bool includingPersistentItems)
    213          {
   \                     PDS_DeleteAll: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    214            S_Nv_EraseAll(includingPersistentItems);
   \   00000002   0x.... 0x....      BL       S_Nv_EraseAll_Impl
    215            return PDS_SUCCESS;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    216          }
    217          
    218          /******************************************************************************
    219          \brief PDS store item hadler
    220          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    221          void pdsStoreItemTaskHandler(void)
    222          {
   \                     pdsStoreItemTaskHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    223            uint8_t i, j;
    224            bool breakLoop = false;
    225          
    226            // run through all items and store the first item
    227            for (i = 0U; i < PDS_ITEM_MASK_SIZE; i++)
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR      R7,??DataTable9
    228            {
    229              for (j = 0U; j < 8U; j++)
   \                     ??pdsStoreItemTaskHandler_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x187A             ADDS     R2,R7,R1
   \   0000000E   0x7813             LDRB     R3,[R2, #+0]
    230                if (itemsToStore[i] & (1U << j))
   \                     ??pdsStoreItemTaskHandler_1: (+1)
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0x4084             LSLS     R4,R4,R0
   \   00000014   0x4223             TST      R3,R4
   \   00000016   0xD002             BEQ      ??pdsStoreItemTaskHandler_2
    231                {
    232                  itemsToStore[i] &= ~(1U << j);
   \   00000018   0x43A3             BICS     R3,R3,R4
   \   0000001A   0x7013             STRB     R3,[R2, #+0]
    233                  breakLoop = true;
    234                  break;
   \   0000001C   0xE007             B        ??pdsStoreItemTaskHandler_3
    235                }
   \                     ??pdsStoreItemTaskHandler_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2808             CMP      R0,#+8
   \   00000024   0xD3F4             BCC      ??pdsStoreItemTaskHandler_1
    236              if (breakLoop)
    237                break;
    238            }
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0xB2C9             UXTB     R1,R1
   \   0000002A   0x2906             CMP      R1,#+6
   \   0000002C   0xD3ED             BCC      ??pdsStoreItemTaskHandler_0
    239          
    240          #ifdef PDS_SECURITY_CONTROL_ENABLE
    241            if (!pdsIsItemUnderSecurityControl(((S_Nv_ItemId_t)i << 3U) + j) && !S_Nv_IsItemAvailable(((S_Nv_ItemId_t)i << 3U) + j))
    242          #else
    243            if (!S_Nv_IsItemAvailable(((S_Nv_ItemId_t)i << 3U) + j))
   \                     ??pdsStoreItemTaskHandler_3: (+1)
   \   0000002E   0x00C9             LSLS     R1,R1,#+3
   \   00000030   0x180C             ADDS     R4,R1,R0
   \   00000032   0xBF00             Nop      
   \   00000034   0x....             ADR.N    R6,?_2
   \   00000036   0xB2A0             UXTH     R0,R4
   \   00000038   0x.... 0x....      BL       S_Nv_IsItemAvailable_Impl
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD115             BNE      ??pdsStoreItemTaskHandler_4
    244          #endif
    245            {
    246              ItemIdToMemoryMapping_t itemDescr;
    247          
    248              if(pdsGetItemDescr(((S_Nv_ItemId_t)i << 3U) + j, &itemDescr))
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0xB2A0             UXTH     R0,R4
   \   00000044   0x.... 0x....      BL       pdsGetItemDescr
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD035             BEQ      ??pdsStoreItemTaskHandler_5
    249              {
    250                // Not finding item so initialize it
    251                S_Nv_ReturnValue_t ret;
    252                
    253                if (itemDescr.filler)
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0x0001             MOVS     R1,R0
   \   00000050   0xD000             BEQ      ??pdsStoreItemTaskHandler_6
    254                  itemDescr.filler();
   \   00000052   0x4780             BLX      R0
    255                ret = S_Nv_ItemInit(((S_Nv_ItemId_t)i << 3U) + j, itemDescr.itemSize, itemDescr.itemData);
   \                     ??pdsStoreItemTaskHandler_6: (+1)
   \   00000054   0x9A02             LDR      R2,[SP, #+8]
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x8841             LDRH     R1,[R0, #+2]
   \   0000005A   0xB2A0             UXTH     R0,R4
   \   0000005C   0x.... 0x....      BL       S_Nv_ItemInit_Impl
    256                N_ERRH_ASSERT_FATAL((S_Nv_ReturnValue_DidNotExist == ret) || (S_Nv_ReturnValue_Ok == ret));
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD029             BEQ      ??pdsStoreItemTaskHandler_5
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD027             BEQ      ??pdsStoreItemTaskHandler_5
   \   00000068   0x2180             MOVS     R1,#+128
   \   0000006A   0xE021             B        ??pdsStoreItemTaskHandler_7
    257              }
    258            }
    259            else
    260            {
    261              // store found item
    262              pdsStoreItem((((S_Nv_ItemId_t)i) << 3U) + j);
   \                     ??pdsStoreItemTaskHandler_4: (+1)
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x8004             STRH     R4,[R0, #+0]
   \   00000070   0xA901             ADD      R1,SP,#+4
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x.... 0x....      BL       pdsGetItemDescr
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD01D             BEQ      ??pdsStoreItemTaskHandler_5
   \   0000007C   0xAC01             ADD      R4,SP,#+4
   \   0000007E   0x8860             LDRH     R0,[R4, #+2]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ      ??pdsStoreItemTaskHandler_8
   \   00000084   0x9802             LDR      R0,[SP, #+8]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD104             BNE      ??pdsStoreItemTaskHandler_9
   \                     ??pdsStoreItemTaskHandler_8: (+1)
   \   0000008A   0x21BB             MOVS     R1,#+187
   \   0000008C   0x0049             LSLS     R1,R1,#+1        ;; #+374
   \   0000008E   0x0030             MOVS     R0,R6
   \   00000090   0x.... 0x....      BL       N_ErrH_Fatal
   \                     ??pdsStoreItemTaskHandler_9: (+1)
   \   00000094   0x9803             LDR      R0,[SP, #+12]
   \   00000096   0x0001             MOVS     R1,R0
   \   00000098   0xD000             BEQ      ??pdsStoreItemTaskHandler_10
   \   0000009A   0x4780             BLX      R0
   \                     ??pdsStoreItemTaskHandler_10: (+1)
   \   0000009C   0x9B02             LDR      R3,[SP, #+8]
   \   0000009E   0x8862             LDRH     R2,[R4, #+2]
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x4668             MOV      R0,SP
   \   000000A4   0x8800             LDRH     R0,[R0, #+0]
   \   000000A6   0x.... 0x....      BL       S_Nv_Write_Impl
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD004             BEQ      ??pdsStoreItemTaskHandler_5
   \   000000AE   0x21C2             MOVS     R1,#+194
   \                     ??pdsStoreItemTaskHandler_7: (+1)
   \   000000B0   0x0049             LSLS     R1,R1,#+1        ;; #+388
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0x.... 0x....      BL       N_ErrH_Fatal
    263            }
    264          
    265            // check whether there is any item to store
    266            for (i = 0U; i < PDS_ITEM_MASK_SIZE; i++)
    267              if (itemsToStore[i])
   \                     ??pdsStoreItemTaskHandler_5: (+1)
   \   000000B8   0x5D78             LDRB     R0,[R7, R5]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD003             BEQ      ??pdsStoreItemTaskHandler_11
    268              {
    269                pdsPostTask(PDS_STORE_ITEM_TASK_ID);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       pdsPostTask
    270                break;
   \   000000C4   0xE003             B        ??pdsStoreItemTaskHandler_12
    271              }
   \                     ??pdsStoreItemTaskHandler_11: (+1)
   \   000000C6   0x1C6D             ADDS     R5,R5,#+1
   \   000000C8   0xB2ED             UXTB     R5,R5
   \   000000CA   0x2D06             CMP      R5,#+6
   \   000000CC   0xD3F4             BCC      ??pdsStoreItemTaskHandler_5
    272          }
   \                     ??pdsStoreItemTaskHandler_12: (+1)
   \   000000CE   0xB005             ADD      SP,SP,#+20
   \   000000D0   0xBDF0             POP      {R4-R7,PC}       ;; return
    273          
    274          /**************************************************************************//**
    275          \brief Provides PDS with information about memory that should be kept up-to-date
    276                 in the non-volatile storage
    277                 Data will be saved im non-volatile memory upon specific events
    278          
    279          \param[in] memoryId - an identifier of PDS file or directory to be stored
    280                                in non-volatile memory
    281          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    282          void PDS_StoreByEvents(PDS_MemId_t memoryId)
    283          {
   \                     PDS_StoreByEvents: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
    284            EventToMemoryIdMapping_t evMemoryIdMapping;
    285          
    286            for (uint8_t i = 0U; i < ARRAY_SIZE(pdsMemoryMap); i++)
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x....             LDR      R7,??DataTable9_1
   \   00000008   0x....             ADR.N    R6,pdsMemoryMap
    287            {
    288              memcpy_P(&evMemoryIdMapping, &pdsMemoryMap[i], sizeof(EventToMemoryIdMapping_t));
   \                     ??PDS_StoreByEvents_0: (+1)
   \   0000000A   0x2204             MOVS     R2,#+4
   \   0000000C   0x00A0             LSLS     R0,R4,#+2
   \   0000000E   0x1831             ADDS     R1,R6,R0
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    289              if ((BC_ALL_MEMORY_MEM_ID == memoryId) || (evMemoryIdMapping.itemId == memoryId))
   \   00000016   0x....             LDR      R0,??DataTable9_2  ;; 0x4001
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD003             BEQ      ??PDS_StoreByEvents_1
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x8840             LDRH     R0,[R0, #+2]
   \   00000020   0x42A8             CMP      R0,R5
   \   00000022   0xD104             BNE      ??PDS_StoreByEvents_2
    290                SYS_SubscribeToEvent(evMemoryIdMapping.eventId, &pdsEventReceiver);
   \                     ??PDS_StoreByEvents_1: (+1)
   \   00000024   0x0039             MOVS     R1,R7
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       SYS_SubscribeToEvent
    291            }
   \                     ??PDS_StoreByEvents_2: (+1)
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
   \   00000030   0x2C27             CMP      R4,#+39
   \   00000032   0xD3EA             BCC      ??PDS_StoreByEvents_0
    292          }
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    293          
    294          /**************************************************************************//**
    295          \brief Checks if the specified PDS file or directory can be restored
    296                 from non-volatile memory
    297                 PDS files not included in the current build configuration will be ignored
    298          
    299          \param[in] memoryId - an identifier of PDS file or directory to be checked
    300          
    301          \return true, if the specified memory can be restored; false - otherwise
    302          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          bool PDS_IsAbleToRestore(PDS_MemId_t memoryId)
    304          {
   \                     PDS_IsAbleToRestore: (+1)
   \   00000000   0xB560             PUSH     {R5,R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    305            uint8_t itemsToBeAbleRestore[PDS_ITEM_MASK_SIZE] = {0U};
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xC10C             STM      R1!,{R2,R3}
    306            uint8_t i, j;
    307          
    308            if (!pdsInitItemMask(memoryId, itemsToBeAbleRestore))
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x.... 0x....      BL       pdsInitItemMask
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00E             BEQ      ??PDS_IsAbleToRestore_0
    309              return false;
    310          
    311            for (i = 0U; i < PDS_ITEM_MASK_SIZE; i++)
   \   00000016   0x2500             MOVS     R5,#+0
    312              for (j = 0U; j < 8U; j++)
   \                     ??PDS_IsAbleToRestore_1: (+1)
   \   00000018   0x2600             MOVS     R6,#+0
    313                if (itemsToBeAbleRestore[i] & (1U << j))
   \                     ??PDS_IsAbleToRestore_2: (+1)
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x5D40             LDRB     R0,[R0, R5]
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x40B1             LSLS     R1,R1,R6
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD008             BEQ      ??PDS_IsAbleToRestore_3
    314          #ifdef PDS_SECURITY_CONTROL_ENABLE
    315                {
    316                  if (pdsIsItemUnderSecurityControl(((S_Nv_ItemId_t)i << 3U) + j))
    317                  {
    318                    if (!pdsIsSecureItemAvailable(((S_Nv_ItemId_t)i << 3U) + j))
    319                       return false;
    320                  }
    321                  else
    322                  {
    323                    if (!S_Nv_IsItemAvailable(((S_Nv_ItemId_t)i << 3U) + j))
    324                       return false;
    325                  }
    326                }
    327          #else
    328                if (!S_Nv_IsItemAvailable(((S_Nv_ItemId_t)i << 3U) + j))
   \   00000026   0x00E8             LSLS     R0,R5,#+3
   \   00000028   0x1980             ADDS     R0,R0,R6
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       S_Nv_IsItemAvailable_Impl
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE      ??PDS_IsAbleToRestore_3
    329                    return false;
   \                     ??PDS_IsAbleToRestore_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD6E             POP      {R1-R3,R5,R6,PC}
   \                     ??PDS_IsAbleToRestore_3: (+1)
   \   00000038   0x1C76             ADDS     R6,R6,#+1
   \   0000003A   0xB2F6             UXTB     R6,R6
   \   0000003C   0x2E08             CMP      R6,#+8
   \   0000003E   0xD3EC             BCC      ??PDS_IsAbleToRestore_2
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \   00000042   0xB2ED             UXTB     R5,R5
   \   00000044   0x2D06             CMP      R5,#+6
   \   00000046   0xD3E7             BCC      ??PDS_IsAbleToRestore_1
    330          #endif
    331          
    332            return true;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xBD6E             POP      {R1-R3,R5,R6,PC}  ;; return
    333          }
    334          
    335          /******************************************************************************
    336          \brief PDS observer routine. Force parameters storing by an event occurrence
    337          
    338          \param[in] eventId - occured event identifier;
    339          \param[in] data    - associated data
    340          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    341          static void pdsObserver(SYS_EventId_t eventId, SYS_EventData_t data)
    342          {
   \                     pdsObserver: (+1)
   \   00000000   0xB5D9             PUSH     {R0,R3,R4,R6,R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    343            EventToMemoryIdMapping_t evMemoryIdMapping;
    344            bool post = false;
   \   00000004   0x2700             MOVS     R7,#+0
    345          
    346            for (uint8_t i = 0U; i < ARRAY_SIZE(pdsMemoryMap); i++)
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x....             ADR.N    R6,pdsMemoryMap
    347            {
    348              memcpy_P(&evMemoryIdMapping, &pdsMemoryMap[i], sizeof(EventToMemoryIdMapping_t));
   \                     ??pdsObserver_0: (+1)
   \   0000000A   0x2204             MOVS     R2,#+4
   \   0000000C   0x00A0             LSLS     R0,R4,#+2
   \   0000000E   0x1831             ADDS     R1,R6,R0
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    349          
    350              if (evMemoryIdMapping.eventId == eventId)
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x7A09             LDRB     R1,[R1, #+8]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD10C             BNE      ??pdsObserver_1
    351              {
    352                itemsToStore[evMemoryIdMapping.itemId / 8U] |= 1U << (evMemoryIdMapping.itemId % 8U);
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x8840             LDRH     R0,[R0, #+2]
   \   00000026   0x....             LDR      R1,??DataTable9
   \   00000028   0x08C2             LSRS     R2,R0,#+3
   \   0000002A   0x1889             ADDS     R1,R1,R2
   \   0000002C   0x780A             LDRB     R2,[R1, #+0]
   \   0000002E   0x0740             LSLS     R0,R0,#+29
   \   00000030   0x0F40             LSRS     R0,R0,#+29
   \   00000032   0x2301             MOVS     R3,#+1
   \   00000034   0x4083             LSLS     R3,R3,R0
   \   00000036   0x4313             ORRS     R3,R3,R2
   \   00000038   0x700B             STRB     R3,[R1, #+0]
    353                post = true;
   \   0000003A   0x2701             MOVS     R7,#+1
    354              }
    355            }
   \                     ??pdsObserver_1: (+1)
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \   0000003E   0x2C27             CMP      R4,#+39
   \   00000040   0xD3E3             BCC      ??pdsObserver_0
    356          
    357            if (post)
   \   00000042   0x2F00             CMP      R7,#+0
   \   00000044   0xD002             BEQ      ??pdsObserver_2
    358              pdsPostTask(PDS_STORE_ITEM_TASK_ID);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      BL       pdsPostTask
    359          
    360            (void)data;
    361          }
   \                     ??pdsObserver_2: (+1)
   \   0000004C   0xBDDF             POP      {R0-R4,R6,R7,PC}  ;; return
    362          
    363          /******************************************************************************
    364          \brief Stores item
    365          
    366          \param[in] id - item id to store
    367          ******************************************************************************/
    368          static void pdsStoreItem(S_Nv_ItemId_t id)
    369          {
    370            ItemIdToMemoryMapping_t itemDescr;
    371          
    372            if (pdsGetItemDescr(id, &itemDescr))
    373            {
    374              N_ERRH_ASSERT_FATAL((0U != itemDescr.itemSize) && (NULL != itemDescr.itemData));
    375              
    376              if (itemDescr.filler)
    377                itemDescr.filler();
    378          
    379          #ifdef PDS_SECURITY_CONTROL_ENABLE
    380              if (pdsIsItemUnderSecurityControl(id))
    381                pdsStoreSecuredItem(id, itemDescr.itemSize, itemDescr.itemData);
    382              else
    383          #endif
    384              {
    385                S_Nv_ReturnValue_t ret;
    386          
    387                ret = S_Nv_Write(id, 0U, itemDescr.itemSize, itemDescr.itemData);
    388                N_ERRH_ASSERT_FATAL(ret == S_Nv_ReturnValue_Ok);
    389              }
    390            }
    391          }
    392          
    393          /******************************************************************************
    394          \brief Restores item
    395          
    396          \param[in] id - item id to store
    397          
    398          \return true item was restored, false otherwise
    399          ******************************************************************************/
    400          static bool pdsRestoreItem(S_Nv_ItemId_t id)
    401          {
    402            ItemIdToMemoryMapping_t itemDescr;
    403            uint16_t oldSize;
    404            
    405            if (pdsGetItemDescr(id, &itemDescr))
    406            {
    407              N_ERRH_ASSERT_FATAL((0U != itemDescr.itemSize) && (NULL != itemDescr.itemData));
    408          
    409              if (itemDescr.filler)
    410                itemDescr.filler();
    411          
    412          #ifdef PDS_SECURITY_CONTROL_ENABLE
    413              if (pdsIsItemUnderSecurityControl(id))
    414              {
    415                oldSize = pdsSecureItemLength(id);
    416                bool result = pdsRestoreSecuredItem(id, itemDescr.itemSize, itemDescr.itemData);
    417          
    418                if (result)
    419                  if (!pdsUpdateMemory(id, itemDescr.itemData, itemDescr.itemSize, oldSize))
    420                    return false;
    421                return result;
    422              }
    423              else
    424          #endif
    425              {
    426                oldSize = S_Nv_ItemLength(id);
    427                S_Nv_ReturnValue_t ret = S_Nv_ItemInit(id, itemDescr.itemSize, itemDescr.itemData);
    428          
    429                N_ERRH_ASSERT_FATAL((S_Nv_ReturnValue_DidNotExist == ret) || (S_Nv_ReturnValue_Ok == ret));
    430          
    431                if (S_Nv_ReturnValue_Ok == ret)
    432                  if (!pdsUpdateMemory(id, itemDescr.itemData, itemDescr.itemSize, oldSize))
    433                    return false;
    434                return (S_Nv_ReturnValue_Ok == ret);
    435              }
    436            }
    437            return false;
    438          }
    439          
    440          /******************************************************************************
    441          \brief To init the itemmask for the given memory ID
    442          
    443          \param[in] memoryId - memeory id to initialize itemMask
    444          \param[in] itemMask - itemMask to be initialized
    445          
    446          \return true itemMask is initialized, false otherwise
    447          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    448          static bool pdsInitItemMask(S_Nv_ItemId_t memoryId, uint8_t *itemMask)
    449          {
   \                     pdsInitItemMask: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
    450            if (PDS_ALL_EXISTENT_MEMORY == memoryId)
   \   00000004   0x....             LDR      R1,??DataTable9_3  ;; 0x4002
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD109             BNE      ??pdsInitItemMask_0
    451            {
    452              memset(itemMask, 0xFFU, PDS_ITEM_MASK_SIZE);
   \   0000000A   0x22FF             MOVS     R2,#+255
   \   0000000C   0x2106             MOVS     R1,#+6
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       __aeabi_memset
    453              itemMask[0] &= 0xFEU;
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x21FE             MOVS     R1,#+254
   \   00000018   0x4001             ANDS     R1,R1,R0
   \   0000001A   0x7021             STRB     R1,[R4, #+0]
   \   0000001C   0xE02C             B        ??pdsInitItemMask_1
    454            }
    455            else if (PDS_DIRECTORY_MASK & memoryId)
   \                     ??pdsInitItemMask_0: (+1)
   \   0000001E   0x2607             MOVS     R6,#+7
   \   00000020   0x2501             MOVS     R5,#+1
   \   00000022   0x0441             LSLS     R1,R0,#+17
   \   00000024   0xD521             BPL      ??pdsInitItemMask_2
    456            {
    457              PDS_DirDescr_t dirDescr;
    458              PDS_MemId_t memId;
    459          
    460              if (pdsGetDirDescr(memoryId, &dirDescr))
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x.... 0x....      BL       pdsGetDirDescr
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD024             BEQ      ??pdsInitItemMask_3
    461              {
    462                for (uint8_t index=0U; index < dirDescr.filesCount; index++)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??pdsInitItemMask_4: (+1)
   \   00000032   0xB2C1             UXTB     R1,R0
   \   00000034   0xAA01             ADD      R2,SP,#+4
   \   00000036   0x8892             LDRH     R2,[R2, #+4]
   \   00000038   0x4291             CMP      R1,R2
   \   0000003A   0xD21D             BCS      ??pdsInitItemMask_1
    463                {
    464                  memcpy_P(&memId, (void const FLASH_PTR *)(dirDescr.list + index), sizeof(uint16_t));
   \   0000003C   0x9901             LDR      R1,[SP, #+4]
   \   0000003E   0xB2C0             UXTB     R0,R0
   \   00000040   0x0042             LSLS     R2,R0,#+1
   \   00000042   0x1889             ADDS     R1,R1,R2
   \   00000044   0x466A             MOV      R2,SP
   \   00000046   0x780B             LDRB     R3,[R1, #0]
   \   00000048   0x7013             STRB     R3,[R2, #0]
   \   0000004A   0x784B             LDRB     R3,[R1, #+1]
   \   0000004C   0x7053             STRB     R3,[R2, #+1]
    465                  itemMask[memId / 8U] |= 1U << (memId % 8U);
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x8809             LDRH     R1,[R1, #+0]
   \   00000052   0x08C9             LSRS     R1,R1,#+3
   \   00000054   0x1861             ADDS     R1,R4,R1
   \   00000056   0x780A             LDRB     R2,[R1, #+0]
   \   00000058   0x466B             MOV      R3,SP
   \   0000005A   0x881B             LDRH     R3,[R3, #+0]
   \   0000005C   0x4033             ANDS     R3,R3,R6
   \   0000005E   0x2701             MOVS     R7,#+1
   \   00000060   0x409F             LSLS     R7,R7,R3
   \   00000062   0x4317             ORRS     R7,R7,R2
   \   00000064   0x700F             STRB     R7,[R1, #+0]
    466                }
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0xE7E3             B        ??pdsInitItemMask_4
    467              }
    468              else
    469                return false;
    470            }
    471            else
    472            {
    473              itemMask[memoryId / 8] |= 1 << (memoryId % 8);
   \                     ??pdsInitItemMask_2: (+1)
   \   0000006A   0x08C1             LSRS     R1,R0,#+3
   \   0000006C   0x1861             ADDS     R1,R4,R1
   \   0000006E   0x780A             LDRB     R2,[R1, #+0]
   \   00000070   0x4006             ANDS     R6,R6,R0
   \   00000072   0x40B5             LSLS     R5,R5,R6
   \   00000074   0x4315             ORRS     R5,R5,R2
   \   00000076   0x700D             STRB     R5,[R1, #+0]
    474            }
    475          
    476            return true;
   \                     ??pdsInitItemMask_1: (+1)
   \   00000078   0x2001             MOVS     R0,#+1
   \                     ??pdsInitItemMask_3: (+1)
   \   0000007A   0xBDFE             POP      {R1-R7,PC}       ;; return
    477          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     itemsToStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     pdsEventReceiver

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x00004001         DC32     0x4001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x00004002         DC32     0x4002

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x77 0x6C          DC8 "wlPdsDataServer"
   \              0x50 0x64    
   \              0x73 0x44    
   \              0x61 0x74    
   \              0x61 0x53    
   \              0x65 0x72    
   \              0x76 0x65    
   \              0x72 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    478          #endif // _ENABLE_PERSISTENT_SERVER_
    479          #endif // PDS_ENABLE_WEAR_LEVELING == 1
    480          // eof wlpdsDataServer.c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   PDS_Delete
        24   -> S_Nv_Delete_Impl
        24   -> pdsInitItemMask
       8   PDS_DeleteAll
         8   -> S_Nv_EraseAll_Impl
      24   PDS_IsAbleToRestore
        24   -> S_Nv_IsItemAvailable_Impl
        24   -> pdsInitItemMask
      48   PDS_Restore
        48   -- Indirect call
        48   -> N_ErrH_Fatal
        48   -> S_Nv_ItemInit_Impl
        48   -> S_Nv_ItemLength_Impl
        48   -> pdsGetItemDescr
        48   -> pdsInitItemMask
        48   -> pdsUpdateMemory
       8   PDS_Store
         8   -> pdsInitItemMask
         8   -> pdsPostTask
      24   PDS_StoreByEvents
        24   -> SYS_SubscribeToEvent
        24   -> __aeabi_memcpy
      32   pdsInitItemMask
        32   -> __aeabi_memset
        32   -> pdsGetDirDescr
      32   pdsObserver
        32   -> __aeabi_memcpy
        32   -> pdsPostTask
      40   pdsStoreItemTaskHandler
        40   -- Indirect call
        40   -> N_ErrH_Fatal
        40   -> S_Nv_IsItemAvailable_Impl
        40   -> S_Nv_ItemInit_Impl
        40   -> S_Nv_Write_Impl
        40   -> pdsGetItemDescr
        40   -> pdsPostTask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       8  ?_0
       8  ?_1
      16  ?_2
       8  ?_3
      64  PDS_Delete
      10  PDS_DeleteAll
      76  PDS_IsAbleToRestore
     172  PDS_Restore
      22  PDS_Store
      54  PDS_StoreByEvents
       8  itemsToStore
      16  pdsEventReceiver
     124  pdsInitItemMask
     156  pdsMemoryMap
      78  pdsObserver
     210  pdsStoreItemTaskHandler

 
   8 bytes in section .bss
  16 bytes in section .data
  24 bytes in section .rodata
 998 bytes in section .text
 
 998 bytes of CODE  memory
  24 bytes of CONST memory
  24 bytes of DATA  memory

Errors: none
Warnings: none
