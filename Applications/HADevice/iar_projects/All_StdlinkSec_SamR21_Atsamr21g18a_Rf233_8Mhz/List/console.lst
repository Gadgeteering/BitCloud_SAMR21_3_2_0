###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        31/Mar/2015  18:40:16
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\common\src\console.c
#    Command line =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\common\src\console.c
#        -D BOARD_SAMR21 -D BOARD_QTOUCH_XPRO -D AT86RF233 -D ATSAMR21G18A -D
#        HAL_8MHz -D STACK_TYPE_ALL -D STDLINK_SECURITY_MODE -lC
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\
#        --diag_suppress Pa050,Pe188 -o
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.30\arm\INC\c\DLib_Config_Full.h" --preinclude
#        MakerulesBc_All_StdlinkSec_Atsamr21g18a_Rf233_Iar.h -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/..\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmableLight/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../dimmerSwitch/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../multiSensor/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../thermostat/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../ias_ace/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../combinedInterface/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../common/clusters/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/SAMR21/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/lib\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/BSP/QTouch_XPRO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/NWK/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZDO/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/APS/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/SystemEnvironment/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ConfigServer/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/std/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/PersistDataServer/wl/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Types/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Util/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Timer/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Task/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_ErrH/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Log/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Memory/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/Infrastructure/N_Init/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_Nv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/D_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZLLPlatform/ZLL/S_XNv/src\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/TrustCentre/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/Security/ServiceProvider/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/drivers/VCP/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/HAL/cortexm0+/atsamr21/common/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include/private\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/ZCL/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_ENV/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWI/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/PHY/include\
#        -I
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects/../../../BitCloud/Components/MAC_PHY/MAC_HWD_PHY/RF231_RF212/MAC_HWD/include\
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/List\console.lst
#    Object file  =  
#        D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\iar_projects\All_StdlinkSec_SamR21_Atsamr21g18a_Rf233_8Mhz/Obj\console.o
#
###############################################################################

D:\support_project\Qtouch_samr21_validation\BitCloud_SAMR21_3_2_0\BitCloud_SAMR21_3_2_0\Applications\HADevice\common\src\console.c
      1          /**************************************************************************//**
      2            \file console.c
      3          
      4            \brief
      5              Serial interface console implementation.
      6          
      7            \author
      8              Atmel Corporation: http://www.atmel.com \n
      9              Support email: avr@atmel.com
     10          
     11            Copyright (c) 2008-2015, Atmel Corporation. All rights reserved.
     12            Licensed under Atmel's Limited License Agreement (BitCloudTM).
     13          
     14            \internal
     15              History:
     16              22.05.12 N. Fomin - Created.
     17          ******************************************************************************/
     18          #if APP_ENABLE_CONSOLE == 1
     19          
     20          /******************************************************************************
     21                              Includes section
     22          ******************************************************************************/
     23          #include <ctype.h>
     24          #include <string.h>
     25          #include <stdint.h>
     26          #include "console.h"
     27          
     28          /******************************************************************************
     29                              Definitions section
     30          ******************************************************************************/
     31          #define VT100_ESCAPE        0x1B
     32          #define VT100_ERASE_LINE    "\x1B[2K"
     33          #define CMD_PROMPT          "$"
     34          
     35          #define CMD_BUF_SIZE        85
     36          #define MAX_NUM_OF_ARGS     10
     37          #define CRLF                "\r\n"
     38          #define FORCE_LOWCASE 0
     39          
     40          /******************************************************************************
     41                              Types section
     42          ******************************************************************************/
     43          typedef struct
     44          {
     45            ScanValue_t *top;
     46            ScanValue_t args[MAX_NUM_OF_ARGS];
     47            ScanValue_t end[0];
     48          } ScanStack_t;
     49          
     50          /******************************************************************************
     51                                        Local variables
     52          ******************************************************************************/

   \                                 In section .bss, align 4
     53          static const ConsoleCommand_t *cmdTable;
   \                     cmdTable:
   \   00000000                      DS8 4
     54          
     55          /******************************************************************************
     56                              Prototypes section
     57          ******************************************************************************/
     58          static uint8_t tokenizeStr(char *str, ScanStack_t *stk);
     59          static uint8_t unpackArgs(const ConsoleCommand_t *cmd, ScanStack_t *args);
     60          static void processCommand(char *str);
     61          
     62          /******************************************************************************
     63                              Implementation section
     64          ******************************************************************************/
     65          /**************************************************************************//**
     66          \brief Converts decimal string to unsigned long
     67          
     68          \param[in] str - string to be converted
     69          \param[out] out - pointer to converted number
     70          
     71          \returns 1 if conversation was successful, 0 - otherwise
     72          ******************************************************************************/
     73          // No check for overflow

   \                                 In section .text, align 2, keep-with-next
     74          uint8_t decimalStrToUlong(const char *str, uint32_t *out)
     75          {
   \                     decimalStrToUlong: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     76            uint32_t decCnt = 1;
   \   00000002   0x2301             MOVS     R3,#+1
     77            uint32_t ret = 0;
   \   00000004   0x2200             MOVS     R2,#+0
     78            const char *p;
     79          
     80            if (!*str)
   \   00000006   0x7804             LDRB     R4,[R0, #+0]
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD014             BEQ      ??decimalStrToUlong_0
     81              return 0;  // Empty
     82          
     83            for (p = str; *p; p++);                    // Rewind to the end of string
   \   0000000C   0x0004             MOVS     R4,R0
   \   0000000E   0xE000             B        ??decimalStrToUlong_1
   \                     ??decimalStrToUlong_2: (+1)
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \                     ??decimalStrToUlong_1: (+1)
   \   00000012   0x7825             LDRB     R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD1FB             BNE      ??decimalStrToUlong_2
     84          
     85            for (p--; p >= str; p--, decCnt *= 10)     // locStrP points to the last symbol at the loop start
   \   00000018   0x1E64             SUBS     R4,R4,#+1
   \   0000001A   0xE005             B        ??decimalStrToUlong_3
     86            {
     87              if (!isdigit((int)*p))
     88                return 0;
     89          
     90              ret += (*p - '0') * decCnt;
   \                     ??decimalStrToUlong_4: (+1)
   \   0000001C   0x3D30             SUBS     R5,R5,#+48
   \   0000001E   0x435D             MULS     R5,R3,R5
   \   00000020   0x1952             ADDS     R2,R2,R5
   \   00000022   0x1E64             SUBS     R4,R4,#+1
   \   00000024   0x250A             MOVS     R5,#+10
   \   00000026   0x436B             MULS     R3,R5,R3
   \                     ??decimalStrToUlong_3: (+1)
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD306             BCC      ??decimalStrToUlong_5
   \   0000002C   0x7825             LDRB     R5,[R4, #+0]
   \   0000002E   0x002E             MOVS     R6,R5
   \   00000030   0x3E30             SUBS     R6,R6,#+48
   \   00000032   0x2E0A             CMP      R6,#+10
   \   00000034   0xD3F2             BCC      ??decimalStrToUlong_4
   \                     ??decimalStrToUlong_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}
     91            }
     92          
     93            *out = ret;
   \                     ??decimalStrToUlong_5: (+1)
   \   0000003A   0x600A             STR      R2,[R1, #+0]
     94            return 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
     95          }
     96          
     97          /**************************************************************************//**
     98          \brief Converts decimal string to signed long
     99          
    100          \param[in] str - string to be converted
    101          \param[out] out - pointer to converted number
    102          
    103          \returns 1 if conversation was successful, 0 - otherwise
    104          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    105          uint8_t decimalStrToSlong(const char *str, int32_t *out)
    106          {
   \                     decimalStrToSlong: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    107            uint32_t ret;
    108          
    109            if (*str == '-')
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x292D             CMP      R1,#+45
   \   0000000A   0xD109             BNE      ??decimalStrToSlong_0
    110            {
    111              if (decimalStrToUlong(++str, &ret))
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x.... 0x....      BL       decimalStrToUlong
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD00E             BEQ      ??decimalStrToSlong_1
    112              {
    113                *out = -ret;
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x4241             RSBS     R1,R0,#+0
   \   0000001C   0x6021             STR      R1,[R4, #+0]
    114                return 1;
   \   0000001E   0xE008             B.N      ??decimalStrToSlong_2
    115              }
    116            }
    117            else if (*str)
   \                     ??decimalStrToSlong_0: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD008             BEQ      ??decimalStrToSlong_1
    118            {
    119              if (decimalStrToUlong(str, &ret))
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x.... 0x....      BL       decimalStrToUlong
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD003             BEQ      ??decimalStrToSlong_1
    120              {
    121                *out = ret;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x6020             STR      R0,[R4, #+0]
    122                return 1;
   \                     ??decimalStrToSlong_2: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD16             POP      {R1,R2,R4,PC}
    123              }
    124            }
    125          
    126            return 0;
   \                     ??decimalStrToSlong_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    127          }
    128          
    129          /**************************************************************************//**
    130          \brief Converts hex string to unsigned long
    131          
    132          \param[in] str - string to be converted
    133          \param[out] out - pointer to converted number
    134          
    135          \returns 1 if conversation was successful, 0 - otherwise
    136          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          uint8_t hexStrToUlong(const char *str, uint32_t *out)
    138          {
   \                     hexStrToUlong: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    139            uint32_t shift = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    140            uint32_t ret = 0;
   \   00000004   0x2200             MOVS     R2,#+0
    141            const char *p;
    142          
    143            if (!*str)
   \   00000006   0x7804             LDRB     R4,[R0, #+0]
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD022             BEQ      ??hexStrToUlong_0
    144              return 0;  // Empty
    145          
    146            for (p = str; *p; p++);                  // Rewind to the end of string
   \   0000000C   0x0004             MOVS     R4,R0
   \   0000000E   0xE000             B        ??hexStrToUlong_1
   \                     ??hexStrToUlong_2: (+1)
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \                     ??hexStrToUlong_1: (+1)
   \   00000012   0x7825             LDRB     R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD1FB             BNE      ??hexStrToUlong_2
    147          
    148            for (p--; p >= str && shift < 32; p--, shift += 4)     // locStrP points to the last symbol at the loop start
   \   00000018   0x1E64             SUBS     R4,R4,#+1
   \   0000001A   0xE005             B        ??hexStrToUlong_3
    149            {
    150              char chr = *p;
    151          
    152              if (chr >= 'a' && chr <= 'f')
    153                chr -= 'a' - 0xA;
   \                     ??hexStrToUlong_4: (+1)
   \   0000001C   0x3D57             SUBS     R5,R5,#+87
   \                     ??hexStrToUlong_5: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5
    154              else if (chr >= 'A' && chr <= 'F')
    155                chr -= 'A' - 0xA;
    156              else if (chr >= '0' && chr <= '9')
    157                chr -= '0';
    158              else
    159                return 0;
    160          
    161              ret += (uint32_t)chr << shift;
   \   00000020   0x409D             LSLS     R5,R5,R3
   \   00000022   0x1952             ADDS     R2,R2,R5
   \   00000024   0x1E64             SUBS     R4,R4,#+1
   \   00000026   0x1D1B             ADDS     R3,R3,#+4
   \                     ??hexStrToUlong_3: (+1)
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD314             BCC      ??hexStrToUlong_6
   \   0000002C   0x2B20             CMP      R3,#+32
   \   0000002E   0xD212             BCS      ??hexStrToUlong_6
   \   00000030   0x7825             LDRB     R5,[R4, #+0]
   \   00000032   0x002E             MOVS     R6,R5
   \   00000034   0x3E61             SUBS     R6,R6,#+97
   \   00000036   0x2E06             CMP      R6,#+6
   \   00000038   0xD3F0             BCC      ??hexStrToUlong_4
   \   0000003A   0x002E             MOVS     R6,R5
   \   0000003C   0x3E41             SUBS     R6,R6,#+65
   \   0000003E   0x2E06             CMP      R6,#+6
   \   00000040   0xD201             BCS      ??hexStrToUlong_7
   \   00000042   0x3D37             SUBS     R5,R5,#+55
   \   00000044   0xE7EB             B        ??hexStrToUlong_5
   \                     ??hexStrToUlong_7: (+1)
   \   00000046   0x002E             MOVS     R6,R5
   \   00000048   0x3E30             SUBS     R6,R6,#+48
   \   0000004A   0x2E0A             CMP      R6,#+10
   \   0000004C   0xD201             BCS      ??hexStrToUlong_0
   \   0000004E   0x3D30             SUBS     R5,R5,#+48
   \   00000050   0xE7E5             B        ??hexStrToUlong_5
   \                     ??hexStrToUlong_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD70             POP      {R4-R6,PC}
    162            }
    163          
    164            *out = ret;
   \                     ??hexStrToUlong_6: (+1)
   \   00000056   0x600A             STR      R2,[R1, #+0]
    165            return 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
    166          }
    167          
    168          /**************************************************************************//**
    169          \brief Register commands in console
    170          
    171          \param[in] table - pointer to an array of commands
    172          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    173          void consoleRegisterCommands(const ConsoleCommand_t *table)
    174          {
    175            cmdTable = table;
   \                     consoleRegisterCommands: (+1)
   \   00000000   0x....             LDR      R1,??DataTable3
   \   00000002   0x6008             STR      R0,[R1, #+0]
    176          }
   \   00000004   0x4770             BX       LR               ;; return
    177          
    178          /**************************************************************************//**
    179          \brief Processes single char read from serial interface
    180          
    181          \param[in] char - read char
    182          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    183          void consoleRx(char chr)
    184          {
   \                     consoleRx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    185            static char cmdBuf[CMD_BUF_SIZE + 1];             // Additional space for end-of-string
    186            static char *p = cmdBuf;
    187          
    188            if (chr != '\n')                             // Not EOL
   \   00000004   0x....             LDR      R5,??DataTable3_1
   \   00000006   0x1D2F             ADDS     R7,R5,#+4
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2C0A             CMP      R4,#+10
   \   0000000C   0xD020             BEQ      ??consoleRx_0
    189            {
    190              if (isprint((int)chr))
   \   0000000E   0x9400             STR      R4,[SP, #+0]
   \   00000010   0x3820             SUBS     R0,R0,#+32
   \   00000012   0x285F             CMP      R0,#+95
   \   00000014   0xD312             BCC      ??consoleRx_1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       isalpha
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10D             BNE      ??consoleRx_1
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x.... 0x....      BL       ispunct
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD108             BNE      ??consoleRx_1
    191              {
    192                if ((p - cmdBuf) < CMD_BUF_SIZE)  // Put to buffer
    193                {
    194          #if FORCE_LOWCASE
    195                  chr = tolower(chr);
    196          #endif
    197                  *p++ = chr;
    198                  //consoleTx(chr);                   // Echo
    199                }
    200              }
    201              else if (chr == '\b')                   // Backspace: erase symbol
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xD10D             BNE      ??consoleRx_2
    202              {
    203                if (p > cmdBuf)                     // There are symbols in buffer - delete'em
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x4287             CMP      R7,R0
   \   00000032   0xD216             BCS      ??consoleRx_3
    204                {
    205                  *(--p) = 0;                      // Rewind and terminate
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x6028             STR      R0,[R5, #+0]
   \   00000038   0x7006             STRB     R6,[R0, #+0]
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}
    206                  //console_tx_str(VT100_ERASE_LINE"\r" CMD_PROMPT);// Reprint string
    207                  //console_tx_str(cmdBuf);
    208                }
    209              }
   \                     ??consoleRx_1: (+1)
   \   0000003C   0x6828             LDR      R0,[R5, #+0]
   \   0000003E   0x1BC1             SUBS     R1,R0,R7
   \   00000040   0x2955             CMP      R1,#+85
   \   00000042   0xDA0E             BGE      ??consoleRx_3
   \   00000044   0x7004             STRB     R4,[R0, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xE00A             B        ??consoleRx_4
    210              else if (chr == VT100_ESCAPE)                  // Escape: flush buffer and erase symbols
   \                     ??consoleRx_2: (+1)
   \   0000004A   0x2C1B             CMP      R4,#+27
   \   0000004C   0xD109             BNE      ??consoleRx_3
    211              {
    212                p = cmdBuf;
   \   0000004E   0xE006             B        ??consoleRx_5
    213                //console_tx_str(VT100_ERASE_LINE"\r" CMD_PROMPT);
    214              }
    215            }
    216            else                                            // End of command string
    217            {
    218              if (p > cmdBuf)                         // Non-empty command
   \                     ??consoleRx_0: (+1)
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x4287             CMP      R7,R0
   \   00000054   0xD203             BCS      ??consoleRx_5
    219              {
    220                *p = 0;                              // Mark an end of string
   \   00000056   0x7006             STRB     R6,[R0, #+0]
    221                processCommand(cmdBuf);
   \   00000058   0x1D28             ADDS     R0,R5,#+4
   \   0000005A   0x.... 0x....      BL       processCommand
    222              }
    223          
    224              p = cmdBuf;                              // Drop buffer
   \                     ??consoleRx_5: (+1)
   \   0000005E   0x1D28             ADDS     R0,R5,#+4
   \                     ??consoleRx_4: (+1)
   \   00000060   0x6028             STR      R0,[R5, #+0]
    225              //console_tx_str(CRLF CMD_PROMPT);             // Command prompt
    226            }
    227          }
   \                     ??consoleRx_3: (+1)
   \   00000062   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .data, align 4
   \                     ??p:
   \   00000000   0x........         DC32 ??cmdBuf
   \                     ??cmdBuf:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000034   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    228          
    229          /**************************************************************************//**
    230          \brief Processes command
    231          
    232          \param[in] Str - string with command
    233          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    234          static void processCommand(char *Str)
    235          {
   \                     processCommand: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0001             MOVS     R1,R0
    236            ScanStack_t stk;
    237          
    238            //console_tx_str(CRLF);
    239          
    240            if (!tokenizeStr(Str, &stk))
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x466B             MOV      R3,SP
   \   0000000C   0x1D1B             ADDS     R3,R3,#+4
   \   0000000E   0x9300             STR      R3,[SP, #+0]
   \   00000010   0x466C             MOV      R4,SP
   \   00000012   0xE005             B        ??processCommand_0
   \                     ??processCommand_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x6029             STR      R1,[R5, #+0]
   \                     ??processCommand_2: (+1)
   \   00000018   0x9B00             LDR      R3,[SP, #+0]
   \   0000001A   0x1D1B             ADDS     R3,R3,#+4
   \   0000001C   0x9300             STR      R3,[SP, #+0]
   \                     ??processCommand_3: (+1)
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \                     ??processCommand_0: (+1)
   \   00000020   0x780B             LDRB     R3,[R1, #+0]
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD023             BEQ      ??processCommand_4
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD014             BEQ      ??processCommand_5
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD003             BEQ      ??processCommand_6
   \   0000002E   0xD30B             BCC      ??processCommand_7
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xD005             BEQ      ??processCommand_8
   \   00000034   0xE7F3             B        ??processCommand_3
   \                     ??processCommand_6: (+1)
   \   00000036   0x2B22             CMP      R3,#+34
   \   00000038   0xD1F1             BNE      ??processCommand_3
   \   0000003A   0x2003             MOVS     R0,#+3
   \                     ??processCommand_9: (+1)
   \   0000003C   0x700A             STRB     R2,[R1, #+0]
   \   0000003E   0xE7EE             B        ??processCommand_3
   \                     ??processCommand_8: (+1)
   \   00000040   0x2B20             CMP      R3,#+32
   \   00000042   0xD160             BNE      ??processCommand_10
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE7EA             B        ??processCommand_3
   \                     ??processCommand_7: (+1)
   \   00000048   0x2B22             CMP      R3,#+34
   \   0000004A   0xD05C             BEQ      ??processCommand_10
   \   0000004C   0x2B20             CMP      R3,#+32
   \   0000004E   0xD1E6             BNE      ??processCommand_3
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE7F3             B.N      ??processCommand_9
   \                     ??processCommand_5: (+1)
   \   00000054   0x2B20             CMP      R3,#+32
   \   00000056   0xD0E2             BEQ      ??processCommand_3
   \   00000058   0x9D00             LDR      R5,[SP, #+0]
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x302C             ADDS     R0,R0,#+44
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD251             BCS      ??processCommand_10
   \   00000062   0x2B22             CMP      R3,#+34
   \   00000064   0xD1D6             BNE      ??processCommand_1
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x1C4B             ADDS     R3,R1,#+1
   \   0000006A   0x602B             STR      R3,[R5, #+0]
   \   0000006C   0xE7D4             B        ??processCommand_2
   \                     ??processCommand_4: (+1)
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD049             BEQ      ??processCommand_10
    241              return;
    242          
    243            if (stk.top == stk.args)                        // No command name
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x1D20             ADDS     R0,R4,#+4
   \   00000076   0x4281             CMP      R1,R0
   \   00000078   0xD045             BEQ      ??processCommand_10
    244              return;
    245          
    246            /** Seek for a matching command */
    247            for (const ConsoleCommand_t *cmd = cmdTable; cmd->name; cmd++)
   \   0000007A   0x....             LDR      R0,??DataTable3
   \   0000007C   0x6805             LDR      R5,[R0, #+0]
   \   0000007E   0xE000             B        ??processCommand_11
   \                     ??processCommand_12: (+1)
   \   00000080   0x3510             ADDS     R5,R5,#+16
   \                     ??processCommand_11: (+1)
   \   00000082   0x6829             LDR      R1,[R5, #+0]
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD03A             BEQ      ??processCommand_13
    248            {
    249              if (strcmp(stk.args[0].str, cmd->name) == 0)    // Command match
   \   00000088   0x9801             LDR      R0,[SP, #+4]
   \   0000008A   0x.... 0x....      BL       strcmp
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD1F6             BNE      ??processCommand_12
    250              {
    251                if (!unpackArgs(cmd, &stk))
   \   00000092   0x686F             LDR      R7,[R5, #+4]
   \   00000094   0x466E             MOV      R6,SP
   \   00000096   0x3608             ADDS     R6,R6,#+8
   \   00000098   0xE007             B        ??processCommand_14
   \                     ??processCommand_15: (+1)
   \   0000009A   0x6830             LDR      R0,[R6, #+0]
   \   0000009C   0x7841             LDRB     R1,[R0, #+1]
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD126             BNE      ??processCommand_16
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x7030             STRB     R0,[R6, #+0]
   \                     ??processCommand_17: (+1)
   \   000000A6   0x1C7F             ADDS     R7,R7,#+1
   \   000000A8   0x1D36             ADDS     R6,R6,#+4
   \                     ??processCommand_14: (+1)
   \   000000AA   0x7838             LDRB     R0,[R7, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD01C             BEQ      ??processCommand_18
   \   000000B0   0x9900             LDR      R1,[SP, #+0]
   \   000000B2   0x428E             CMP      R6,R1
   \   000000B4   0xD21C             BCS      ??processCommand_16
   \   000000B6   0x2863             CMP      R0,#+99
   \   000000B8   0xD0EF             BEQ      ??processCommand_15
   \   000000BA   0x2864             CMP      R0,#+100
   \   000000BC   0xD001             BEQ      ??processCommand_19
   \   000000BE   0x2869             CMP      R0,#+105
   \   000000C0   0xD1F1             BNE      ??processCommand_17
   \                     ??processCommand_19: (+1)
   \   000000C2   0x6830             LDR      R0,[R6, #+0]
   \   000000C4   0x7801             LDRB     R1,[R0, #+0]
   \   000000C6   0x2930             CMP      R1,#+48
   \   000000C8   0xD109             BNE      ??processCommand_20
   \   000000CA   0x7841             LDRB     R1,[R0, #+1]
   \   000000CC   0x2978             CMP      R1,#+120
   \   000000CE   0xD001             BEQ      ??processCommand_21
   \   000000D0   0x2958             CMP      R1,#+88
   \   000000D2   0xD104             BNE      ??processCommand_20
   \                     ??processCommand_21: (+1)
   \   000000D4   0x0031             MOVS     R1,R6
   \   000000D6   0x1C80             ADDS     R0,R0,#+2
   \   000000D8   0x.... 0x....      BL       hexStrToUlong
   \   000000DC   0xE002             B.N      ??processCommand_22
   \                     ??processCommand_20: (+1)
   \   000000DE   0x0031             MOVS     R1,R6
   \   000000E0   0x.... 0x....      BL       decimalStrToSlong
   \                     ??processCommand_22: (+1)
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD1DE             BNE      ??processCommand_17
   \   000000E8   0xE002             B        ??processCommand_16
   \                     ??processCommand_18: (+1)
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0x4286             CMP      R6,R0
   \   000000EE   0xD001             BEQ      ??processCommand_23
    252                  consoleTxStr(cmd->helpMsg);
   \                     ??processCommand_16: (+1)
   \   000000F0   0x68E8             LDR      R0,[R5, #+12]
   \   000000F2   0xE006             B        ??processCommand_24
    253                else
    254                  cmd->handler(stk.args + 1);
   \                     ??processCommand_23: (+1)
   \   000000F4   0x3408             ADDS     R4,R4,#+8
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0x68A9             LDR      R1,[R5, #+8]
   \   000000FA   0x4788             BLX      R1
    255                return;
   \   000000FC   0xE003             B        ??processCommand_10
    256              }
    257            }
    258          
    259            consoleTxStr("unknown command\r\n");
   \                     ??processCommand_13: (+1)
   \   000000FE   0xBF00             Nop      
   \   00000100   0x....             ADR.N    R0,?_0
   \                     ??processCommand_24: (+1)
   \   00000102   0x.... 0x....      BL       consoleTxStr
    260          }
   \                     ??processCommand_10: (+1)
   \   00000106   0xB00B             ADD      SP,SP,#+44
   \   00000108   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     cmdTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ??p

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x75 0x6E          DC8 "unknown command\015\012"
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
    261          
    262          /**************************************************************************//**
    263          \brief Unpacks arguments according to the format string
    264          
    265          \param[in] Cmd - command descriptor;
    266          \param[in] Args - stack with pointers to arguments (some of them would be
    267                         replaced by literal values after unpack)
    268          
    269          \returns 1 if case of successful unpacking, 0 - otherwise
    270          ******************************************************************************/
    271          static uint8_t unpackArgs(const ConsoleCommand_t *cmd, ScanStack_t *args)
    272          {
    273            // Now we have a command and a stack of arguments
    274            const char *fmt = cmd->fmt;
    275            ScanValue_t *val = args->args + 1;
    276          
    277            // Unpack arguments of command according to format specifier
    278            for (; *fmt; fmt++, val++)
    279            {
    280              if (val >= args->top)
    281                return 0;
    282          
    283              switch (*fmt)
    284              {
    285                case 's':                                   // String, leave as is
    286                  break;
    287          
    288                case 'c':                                   // Single char
    289                  if (val->str[1])                        // Check next char - must be zero terminator
    290                    return 0;
    291                  val->chr = val->str[0];
    292                  break;
    293          
    294                case 'd':                                   // Integer
    295                case 'i':
    296                  // Lookup for hex prefix. Negative hex is not supported
    297                  if (val->str[0] == '0' && (val->str[1] == 'x' || val->str[1] == 'X'))
    298                  {
    299                    if (!hexStrToUlong(&val->str[2], &val->uint32))
    300                      return 0;
    301                  }
    302                  else                                    // Decimal
    303                  {
    304                    if (!decimalStrToSlong(val->str, &val->int32))
    305                      return 0;
    306                  }
    307                  break;
    308          
    309                default:
    310                  break;
    311              }
    312            }
    313          
    314            if (val != args->top)                           // Starvation of arguments
    315              return 0;
    316          
    317            return 1;
    318          }
    319          
    320          /**************************************************************************//**
    321          \brief Splits string to white-separated tokens; "quotes" on tokens are supported
    322          
    323          \param[in] Str - cinput string; each token(substring) would be zero-terminated;
    324          \param[in] Stk - stack for pointers to tokens
    325          
    326          \returns 1 if case of successful unpacking, 0 - otherwise
    327          ******************************************************************************/
    328          static uint8_t tokenizeStr(char *str, ScanStack_t *stk)
    329          {
    330            enum tokStates
    331            {
    332              WHITE,          // Inside of whitespaces
    333              TOK,            // Inside of token
    334              QTOK,           // Inside of quoted token
    335              POST_QTOK,      // Just after quoted token - waiting for whitespace
    336            };
    337          
    338            enum tokStates St = WHITE;
    339          
    340            stk->top = stk->args;
    341          
    342            for (; *str; str++)
    343            {
    344              switch (St)
    345              {
    346                case WHITE:
    347                  if (*str == ' ')
    348                    break;
    349          
    350                  if (stk->top >= stk->end)          // No more space in stack
    351                    return 0;
    352          
    353                  if (*str == '"')
    354                  {
    355                    St = QTOK;
    356                    (*stk->top++).str = str + 1;    // Store token position in stack (skipping quote)
    357                  }
    358                  else                                // Other symbol
    359                  {
    360                    St = TOK;
    361                    (*stk->top++).str = str;        // Store token position in stack
    362                  }
    363                  break;
    364          
    365                case TOK:
    366                  if (*str == '"')                    // Quotes are forbidden inside of plain token
    367                    return 0;
    368          
    369                  if (*str == ' ')
    370                  {
    371                    St = WHITE;
    372                    *str = 0;                       // Put terminator
    373                  }
    374                  break;
    375          
    376                case QTOK:                              // Put terminator
    377                  if (*str == '"')
    378                  {
    379                    St = POST_QTOK;
    380                    *str = 0;
    381                  }
    382                  break;
    383          
    384                case POST_QTOK:
    385                  if (*str != ' ')
    386                    return 0;
    387                  St = WHITE;
    388                  break;
    389              }
    390            }
    391          
    392            if (St == QTOK)                             // Scan ended while inside of quote
    393              return 0;
    394          
    395            return 1;
    396          }
    397          
    398          #endif // APP_ENABLE_CONSOLE == 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   consoleRegisterCommands
      24   consoleRx
        24   -> isalpha
        24   -> ispunct
        24   -> processCommand
      16   decimalStrToSlong
        16   -> decimalStrToUlong
      16   decimalStrToUlong
      16   hexStrToUlong
      64   processCommand
        64   -- Indirect call
        64   -> consoleTxStr
        64   -> decimalStrToSlong
        64   -> hexStrToUlong
        64   -> strcmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      20  ?_0
       4  cmdTable
       6  consoleRegisterCommands
     100  consoleRx
      58  decimalStrToSlong
      64  decimalStrToUlong
      92  hexStrToUlong
      92  p
          cmdBuf
     266  processCommand

 
   4 bytes in section .bss
  92 bytes in section .data
 614 bytes in section .text
 
 614 bytes of CODE memory
  96 bytes of DATA memory

Errors: none
Warnings: none
